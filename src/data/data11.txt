Error accessing #identity-resolution-overview: Invalid URL '#identity-resolution-overview': No scheme supplied. Perhaps you meant https://#identity-resolution-overview?
Crawling: https://segment.com/docs/
Paragraphs:
Learn how to use Segment to collect, responsibly manage, and integrate your customer data with hundreds of tools.
Learn about Segment, plan and work through a basic implementation, and explore features and extensions.
Integrate the tools you need for analytics, growth, marketing, and more.
Prevent data quality issues with a tracking schema and enforcement with Protocols.
Build audiences and journeys from real-time customer data to personalize experiences on every channel.
Keep customer data private with Segment's data discovery and policy enforcement tools.
The Segment Spec helps you identify, capture, and format meaningful data for use with Segment libraries and APIs as well as downstream tools.
Use Track, Page, Identify, and other Segment tracking calls.
Save time by letting Segment calls collect information for you.
Use our business-case specs to ensure that your tools get the most from your data.
The basics of your Segment implementation.
Over a dozen how-to guides that help you accomplish common tasks.
Segment's Analytics Academy walks you through the wide world of analytics, including best practices, an overview of the most popular tools, and case studies of how other developers have achieved success.
For a more hands-on tutorial of Segment, check out Segment University. It offers step-by-step instructions, starting with first steps and going through some of our more advanced features.


Headings:
Segment Documentation
Getting started with Segment
How can Segment help you?
Simplify data collection
Protect data integrity
Personalize experiences
Respect users' privacy
Get Data into Segment
Segment calls
Common traits
Use case specs
Learning about Segment
Segment for Developers
How-To Guides
Connect your app to Segment
JavaScript
Swift
All other Sources
Additional Resources
Totally new to Analytics?
Want more hands-on guidance?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/
Paragraphs:
With Segment, you can collect, transform, send, and archive yourfirst-party customer data. Segment simplifies the process of collecting data and connecting new tools, allowing you to spend more time using your data, and less time trying to collect it. You can use Segment to track events that happen when a user interacts with the interfaces. “Interfaces” is Segment’s generic word for any digital properties you own: your website, mobile apps, and processes that run on a server or OTT device.
When you capture interaction data in Segment, you can send it (often in real-time) to your marketing, product, and analytics tools, as well as to data warehouses. In most cases, you won’t even need to touch your tracking code to connect to new tools.
Let's walk through the steps to get up and running on Segment. Let's go!

Headings:
What is Segment?
nextReady to get started?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/01-what-is-segment/
Paragraphs:
On this page
In a nutshell, the Segment libraries (Sources) generate messages about what’s happening in your site or app, and send them to the Segment servers. Segment then translates the content of those messages into different formats for use by other tools (which Segment callsDestinations), and sends the translated messages to those tools. The Segment servers also archive a copy of the data, and cansend data to your storage systems(such as databases, warehouses, or bulk-storage buckets).

Segment Spec methodsare how you collect interaction data from your interfaces, and theSourcesare what you package with your interfaces to collect and route the data.
Once you’ve collected your interaction data, there are several different actions you can take:
You can collect data by implementing Segment’s tracking libraries as your Sources:
Segment also offers these other source libraries to cover less straightforward cases:
Segment also offersCloud App Sourcesto integrate data from your third-party tools:
Segment supports several ways to implement tracking. The two most common are to usedevice-basedorserver-basedlibraries. You can use Segment’s device-based libraries, such as JavaScript, iOS, and Android, to make calls on users’ browsers or mobile devices. You can also track data with Segment’s server-based libraries, such as Node, Python, or PHP, where the calls are triggered on your own servers and then sent to the Segment servers.
When you collect data using device-based libraries, you can choose between these two different connection modes:
Although there are some tradeoffs between the two approaches, neither is better than the other, and Segment recommends that you implement a mix of both. In general, more direct interaction data is available using a device-based library, but server-based collection is more secure, reliable, and can’t be blocked by ad blockers.
The Segment libraries generate messages about what happens on your interface, translate those messages into different formats for use by destinations, and transmit the messages to those tools.
There are severaltracking API methods, that you can call to generate messages. The four most important methods are:
Every call shares the samecommon fields. When you use these methodsas intended, it allows Segment to detect a specific type of data and correctly translate it to send it on to downstream destinations.
Segment maintains a catalog of destinations where you can send your data.

Walk through a disposable, demo implementation.


Headings:
How Segment Works
Overview
Sources for collecting data
Sources for unique cases
Cloud App Sources
How you can track data
The Segment Methods
Where you can send data
backGetting Started Overview
nextA simple Segment installation
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/implementation-guide/
Paragraphs:
On this page
Welcome to Segment! This doc mirrors Segment’s in-product guide, and walks you through each of the tasks to level up your workspace strength and become familiar with Segment.
The guide is broken into three categories of tasks:
The tasks included in Basics help you send and debug your very first data from aSource(a library that sends data to Segment), and into aDestination(tools you use to analyze or act on your data).
The Basic tasks include:
Segment allows you to invite team members to your workspace. To decide who on your team should be added to Segment, think about who might be responsible for implementing, owning, or using your data in downstream tools.
For example, as a developer, you might invite:
To invite team members to your workspace:
A Source is a website, server library, mobile SDK, or cloud application which can send data into Segment. It’s where your data originates. Add a Source to collect data to understand who your customers are and how they’re using your product. Create a source for each website or app you want to track.
To add a Source:
Learn More
Once you’ve added your Segment Source, you’re ready to send data into Segment. The simplest data to send into Segment is a Page call (for website Sources) or Screen call (for mobile Sources). Page and screen calls send automatically once you install the Segment snippet or SDK on your website or mobile app. Page and screen calls allow you to record whenever a user sees a page of your website or screen of your app, along with any optional properties about the page or screen.
Learn how toinstall the Segment snippet or SDK on your website or mobile appto start sending data.
Learn More
Destinations are the business tools or apps that Segment forwards your data to. Adding Destinations allow you to act on your data and learn more about your customers in real time.
To add a Destination:
Learn More
The Source Debugger is a real-time tool that helps you validate that API calls made from your website, mobile app, or servers arrive at your source. You can use the Source Debugger to make sure that your source functions properly and your events actively send.
The Debugger shows a live stream of events that flow through your Segment Source, so that you can check that your events send in the correct format. When you click on a specific event, you’ll be able to see these two views of an event:
To access your Source Debugger:
Learn More
The tasks in this phase help you create a data strategy and send additional types of data (identify and track calls) to get a clearer picture of who your users are and what actions they’re taking.
The Instrumentation tasks include:
The Identify call allows you to tie a user to their actions and record traits about them. It includes a unique User ID and any optional traits you know about the user, like their email, name, and address. Sending an Identify call is your first step towards understanding who your users are.
An example of the types of details you might want to learn and track about your users in an Identify call are:
Learn More
The Segment Track call allows you to record any actions your users perform, along with any properties that describe the action. Sending a track call is your first step towards understanding what your users are doing.
Each action that a user takes is known as an event. Each event has a name and properties. For example, the User Registered event might have properties likeplanoraccountType.
To save time on instrumentation, be sure to check ifone of Segment’s Business Specsmeets your needs.
Learn More
Segment recommends you to create and maintain a Tracking Plan to have data clarity and team alignment about what customer data you need to collect and why. It’s best to think about the measurable business outcomes you’re trying to track or improve, and then drill down to track the events needed for each business outcome.
For example, if you’re looking to reduce cart abandonment, you may want to engage cart abandoners by sending emails and in-app messaging to them using Customer.io and Intercom. You also might want to track events like Product Added or Cart Viewed along this customer journey.
Segment maintains a number of industry or product-specific specs to help you get started:
Learn More
When it comes to data collection, the best way to set your company up for success is to establish consistent naming conventions. This makes your code easier to read, and it helps everyone at your company understand what your events mean.
Segment recommends the best practice of using an “Object Action” (Noun Verb) naming convention for all Track events (for example, Menu Clicked) and using noun_noun snake case for property names (for example, property_name). You can view all the event names you’re currently tracking in the Schema view to ensure you’re using consistent conventions and casing.
To view your event names in the Source Schema:
Learn More
A data warehouse is a central location where you can store your raw customer data from multiple sources. A data warehouse gives you flexibility to query your data, which allows you to answer analytical questions that may not be possible with a standard analytics tool.
A data warehouse also allows you to collect and compile data from third party tools asCloud Sourcesin Segment, to help you gain a 360 view of your customer touchpoints.
Learn More
Adding more destinations allows you to connect all your business tools to run through Segment. This gives you the confidence that they are all acting on the same data. Most users connect a variety of marketing, advertising, product, and analytics tools.
With all your tools acting on the same set of customer data, you can personalize your customer engagement and deliver a consistent message across multiple channels
To add more destinations:
Learn More
The tasks in this phase help you to optimize your Segment implementation and take it to the next level.
The optimization tasks include:
Adding any additional data sources that you might have, like a mobile app, marketing website, server, or cloud tool will give you a more complete view of your customer.
Each touchpoint you have with your customers is a potential area to gain a better understanding of them.
To add more sources:
Learn More
Cloud sources allow you to pull in customer data from third-party tools (like Twilio or Stripe) into a data warehouse for complex querying. Consolidating your customer data enables you to eliminate data silos to get a single view of your customer.
Before adding a cloud source, you need to make sure you:
Once you have the necessary credentials, to add a cloud source:
Learn More
Protocols automate and scale thedata quality best practicesdeveloped over years of helping users implement Segment. Investing in data quality improves trust in your data, reduces time spent by your engineering and business teams navigating and validating data, and allows your business to grow faster.
There are steps to take when you use Protocols:
Learn More
Engage is a powerful personalization platform that enables you to create unified customer profiles in Segment, to build and enrich audiences, and to activate audiences across marketing tools.
Engage allows you to enrich user profiles with custom traits, allowing you to create granular audiences for campaigns, advertising, and analysis.

Headings:
Getting Started Guide
Basics
Invite Teammates
Add a Source
Add page or screen tracking
Add a Destination
Testing and Debugging
Instrumentation
Send an Identify call
Send a Track call
Choose what to track
Event anatomy and naming standards
Add a data warehouse
Add more destinations
Optimization
Add more sources
Add a cloud source
Explore Protocols
Explore Engage
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/02-simple-install/
Paragraphs:
On this page
When you implement Segment, you add Segment code to your website, app, or server. This code generates messages based on specific triggers you define.
In a basic implementation, the code can be a snippet of JavaScript that you copy and paste into the HTML of a website to track page views. It can also be as complex as Segment calls embedded in a React mobile app to send messages when the app is opened or closed, when the user performs different actions, or when time based conditions are met (for example “ticket reservation expired” or “cart abandoned after 2 hours”).
The best way to learn about how Segment works is to see it in action. This tutorial walks you through an installation using one of Segment’s libraries: JavaScript, PHP, or the iOS library.
Before you start your Segment implementation, you need:
Tip! If you don’t have any of those things, consider creating a simpleGitHub Pages website.
When you develop and test sources, Segment recommends you to create and use separate sources for each of your environments (production, development, staging) to prevent testing and development activities from filling production systems with invalid data.
You can give each source an environment label when you create it, and Segment strongly suggests that you use these labels to sort your sources. When you create a source during the steps below, make sure you enter an environment label.
Double-check when you enter write keys for dev and production environments to make sure that you send the right data to the right place.
To create a Segment source:
The write key is a unique identifier for a source that tells Segment which source the data comes from, to which workspace the data belongs, and which destinations should receive the data.
To find your write key:
Make note of or write down your write key, as you’ll need it in the next steps.
Any time you change a library’s settings in the Segment App, the write key regenerates.

Cloud-sourcesdo not have write keys, as they use a token or key from your account with that service. Cloud-sources have other considerations and aren’t part of this tutorial.
Click a tab below to see the tutorial content for the specific library you chose.
NavigateConnections > Sources > JavaScriptin the Segment app and copy the snippet from the JavaScript Source overview page and paste it into the<head>tag of your site.That snippet loads Analytics.js onto the pageasynchronously, so it won’t affect your page load speed. Once the snippet runs on your site, you can turn on destinations from the destinations page in your workspace and data starts loading on your site automatically.
Note:If you only want the most basic Google Analytics setup you can stop reading right now. You’re done! Just toggle on Google Analytics from the Segment App.
The Segment snippet version history available onGitHub. Segment recommends that you use the latest snippet version whenever possible.

Theidentifymethod is how you tell Segment who the current user is. It includes a unique User ID and any optional traits you know about them. You can read more about it in theidentify method reference.
Note:You don’t need to callidentifyfor anonymous visitors to your site. Segment automatically assigns them ananonymousId, so just callingpageandtrackworks just fine withoutidentify.
Here’s an example of what a basic call toidentifymight look like:
This identifies Michael by his unique User ID (in this case,f4ca124298, which is what you know him by in your database) and labels him withnameandemailtraits. When you put that code on your site, you need to replace those hard-coded trait values with the variables that represent the details of the currently logged-in user.To do that, Segment recommends that you use a backend template to inject anidentifycall into the footer ofevery pageof your site where the user is logged in. That way, no matter what page the user first lands on, they will always be identified. You don’t need to callidentifyif your unique identifier (userId) is not known.Depending on your templating language, your actual identify call might look something like this:
With that call in your page footer, you successfully identify every user that visits your site.
Note:If you only want to use a basic CRM set up, you can stop here. Just enable Salesforce, Intercom, or any other CRM system from your Segment workspace, and Segment starts sending all of your user data to it.

Thetrackmethod is how you tell Segment about the actions your users are performing on your site. Every action triggers what Segment calls an “event”, which can also have associated properties. You can read more abouttrackin thetrack method reference.Here’s an example of what a call totrackmight look like when a user signs up:
This example shows that your user triggered theSigned Upevent and chose your hypothetical'Enterprise'plan.Properties can be anything you want to record, for example:
If you’re just getting started, some of the events you should track are events that indicate the success of your site, likeSigned Up,Item PurchasedorArticle Bookmarked. Segment recommends that you track a few important events as you can always add more later.Once you add a fewtrackcalls, you’re done with setting up Segment. You successfully installed Analytics.js tracking. Now you’re ready to turn on any destination you like from the Segment App.
To install Analytics-iOS, Segment recommends you to useCocoaPods, because it allows you to create a build with specific bundled destinations, and because it makes it simple to install and upgrade.1) Add theAnalyticsdependency to yourPodfileby adding the following line:
2) In your application delegate’s- application:didFinishLaunchingWithOptions:method, set up the SDK like so:

You don’tneedto use initialization config parameters to track lifecycle events (Application Opened,Application Installed,Application Updated) and screen views automatically, but Segment highly recommends that you do, so you can start off already tracking some important core events.
3) Import the SDK in the files that you use it by adding the following line:

To keep the Segment SDK lightweight, theAnalyticspod only installs the Segment library. This means all of the data goes first to Segment’s servers, and is then forwarded to any destination tools which accept the datafrom Segment.Some destinations don’t accept data from the Segment servers, and instead require that you collect the data from the device. In these cases you must bundle some additional destination code with the Segment SDK. This document skips over this part, but you can see the instructions onhow to bundle the destination tools.Now that the SDK is installed and set up, you’re ready to start making calls.
Theidentifymethod is how you tell Segment who the current user is. It takes a unique User ID, and any optional traits you know about them. You can read more about it in theidentify reference.Here’s an example of what a basic call toidentifymight look like:
This call identifies Michael by his unique User ID (f4ca124298, which is the one you know him by in your database) and labels him withnameandemailtraits.
Note:When you put that code in your iOS app, you need to replace those hard-coded trait values with the variables that represent the details of the currently logged-in user.

Thetrackmethod is how you tell Segment about the actions your users are performing in your app. Every action triggers what we call an “event”, which can also have associated properties. You can read more abouttrackin thetrack method reference.
The Segment iOS SDK can automatically track a few important common events, such asApplication Installed,Application Updated, andApplication Opened. You can enable this option during initialization by adding the following lines:
You should also track events that indicate success in your mobile app, likeSigned Up,Item Purchased, orArticle Bookmarked. Segment recommends that you track a few important events as you can always add more later.Here’s what atrackcall might look like when a user signs up:
This tells us that your user triggered theSigned Upevent, and chose your hypothetical'Enterprise'plan.Properties can be anything you want to record, for example:
Once you’ve added a fewtrackcalls, you’re all set. You successfully instrumented your app, and can enable destinations from your Segment workspace.
To install the library:1) Clone the repository from GitHub into your desired application directory. (If you’re a composer user,you can use this.)
2) Add the following to your PHP script to load the Segment analytics library in your code:
3) In your initialization script, make the following call (In the example, Segment first renames this module toAnalyticsfor convenience):
4) ReplaceYOUR_WRITE_KEYwith the actual write key, which you can find in Segment under your project settings. Otherwise, all that data goes straight to/dev/null.You only need to callinitonce when your php file is requested. All of your files then have access to the sameAnalyticsclient.
Note:The default PHP consumer is thelibcurl consumer. If this is not working well for you, or if you have a high-volume project, you might try one of Segment’s other consumers like thefork-curl consumer.

Theidentifymethod is how you tell Segment who the current user is. It includes a unique User ID and any optional traits that you might know about them.Here’s what a basic call toidentifymight look like:
This identifies Michael by his unique User ID (in this case,f4ca124298, which is what you know him by in your database) and labels him withnameandemailtraits.
Note:When you actually put that code on your site, you need to replace those hard-coded trait values with the variables that represent the details of the currently logged-in user. The easiest way in PHP is to keep a$uservariable in memory.
With that call on the page, you’re now identifying every user that visits your site.If you only want to use a basic CRM set up, you can stop here. Just enable Salesforce, Intercom, or any other CRM system from your Segment workspace, and Segment starts sending all of your user data to it.

Thetrackmethod is how you tell Segment about the actions your users are performing on your site. Every action triggers what Segment calls an “event”, which can also have associated properties.Here’s what a call totrackmight look like when a user signs up:
This tells us that the user triggered theSigned Upevent, and chose your hypotheticalEnterpriseplan.Properties can be anything you want to record, for example:
If you’re just getting started, some of the events you should track are events that indicate the success of your site, likeSigned Up,Item PurchasedorArticle Bookmarked.To get started, Segment recommends you to track track a few important events as you can always add more later.

Call the Segmentflush()method. This manually sends all the queued call data to make sure it makes it to the Segment servers. This is normally done automatically by the runtime, but some PHP installations won’t do it for you, so it’s worth calling at the end of your script, just to be safe.
You’ve successfully installed PHP tracking. Now you’re ready to turn on any destination from the Segment App.
Once you’ve set up your Segment library, and instrumented at least one call, you can look at the Debugger tab for the Source to check that it produces data as you expected.
The Source Debugger is a real-time tool that helps you confirm that API calls made from your website, mobile app, or servers arrive at your Segment Source, so you can quickly see how calls are received by your Segment source, so you can troubleshoot quickly without having to wait for data processing.

The Debugger is separate from your workspace’s data pipeline, and is not an exhaustive view of all the events ever sent to your Segment workspace. The Debugger only shows a sample of the events that the Source receives in real time, with a cap of 500 events. The Debugger is a great way to test specific parts of your implementation to validate that events are being fired successfully and arriving to your Source.
Tip: To see a more complete view of all your events, you might consider setting up either awarehouseor anS3 destination.
The Debugger shows a live stream of sampled events arriving at the Source, but you can also toggle from “Live” to “Pause” to stop the stream and prevent it from displaying new events. Events continue to arrive to your Source while you Pause the stream, they just are not displayed.
You can search on any information you know is available in an event payload to search in the Debugger and show only matching payloads. You can also use advanced search options to limit the results to a specific event.

Two views are available when viewing a payload:
Once you’re satisfied that data is arriving from your new source, it’s time to set up your first destination! As long as you havepageorscreendata coming from the source, you can quickly enable Google Analytics to look at the page view statistics.
If you don’t have a Google Analytics account, you can either set up a free account, or look at the Destination Catalog for a different destination to enable.
You’ll need a tracking ID for Google Analytics (either a “website” or “serverside” tracking ID), or another API key if you’re substituting another destination. Make a note of this ID or key as you’ll need it to connect your destination.
To set up your first destination:
Congratulations! Data is now flowing from the source you set up, to the first destination. Do some test browsing on your site or app, then log in to your downstream tool to see the data in place.
You can click around and load pages to see your Segment calls in action, watch them arrive in the Debugger, and see them arrive in the destination tool.
Note:When you’re done with this test source and destination, you can delete them. This prevents you from getting unplanned “demo” data in your production environment later.
The basics of the Segment platform and what you can do with it.
Think through your goals, plan your calls, and set yourself up for success.
This page was last modified: 13 Aug 2024
Questions? Problems? Need more info? Contact Segment Support for assistance!

Headings:
A Basic Segment Installation
Before you begin
Create separate dev and prod sources
Create a Segment source
Find your write key
Installing Segment
Step 1: Copy the Snippet
Step 2: Identify Users
Step 3: Track Actions
Step 1: Install the SDK
Bundling Client Side SDKs
Step 2: Identify Users
Step 3: Track Actions
Step 1: Download the library
Step 2: Identify Users
Step 3: Track Actions
Step 4: Flush the data
Test that it’s working
Set up your first destination
backWhat is Segment
nextPlanning a Full Installation
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/03-planning-full-install/
Paragraphs:
On this page
Now that you’ve seen Segment in action, step back and think through what a full implementation of Segment for your organization would look like. Figuring out what events to track in Segment can feel overwhelming. You should expect this planning process to have the following steps:
Be prepared to invest time deciding with stakeholders how to track your data, and planning how you’ll analyze it. The time you spend here will save you lots of time in the future, as following Segment’s best practices allows you to easily change your tracking later.
Tracking is about learning and taking action. Think about what you want to know about your product or customers. Think about what assumptions need to be tested and what theories need to be proven true or false. Think about the unknowns. Here are some helpful questions to get started:
While it may seem obvious, we highly recommend documenting your high-level business objectives. More specifically, ask yourself: what are the measurable business outcomes you want to achieve this year? Do you want to acquire new customers? Generate more new sign-ups, drive more incremental revenue among your current customer base?
The best way to answer this question is to interview stakeholders in your organization who will consume the data.
With your business goals documented, the next step is to map user actions to those business goals. For example, if one of your goals is to activate new signups, you want to think about which activities are related to a signup. Ask yourself, what actions do people takebeforesigning up? Do specific actions predict a user signing up?
As an example, you might end up with a list like this:
While this list represents a tiny fraction of the user actions youcouldtrack, it gives a list focused on your top business objectives. This helps break up the huge project of data collection into smaller chunks.
With your business objectives documented and mapped to user actions, it’s time to build standards that you can use when deciding what to track. With your stakeholders, make a list of the actual events (page or screen views, and user actions) that you want to track. Think about all of the ways your users can interact with your site or app
When you’re first starting out, we recommend that you limit your tracking plan to a few core events, but add lots of properties to provide context about them. We generally see more success with the “less is more” philosophy of tracking data, but you might also decide to take a more liberal “track more and analyze later” approach. Like everything, each alternative has pros and cons that are important to consider especially as it relates to your company’s needs.
Segment maintains several “Business Specs”, which are recommendations based on your type of business that give recommendations on what to track, what additional traits or properties to collect, and how to format them. The two most common are the B2B (business-to-business) Spec, Ecommerce Spec, and Mobile and Video specs.
If these specs meet your business needs, you’re in luck. These specs are built into Segment tracking plan templates, so you don’t need to start from a blank slate.
If your organization sells a product or services to other businesses, you might have different analytics and marketing needs than most companies. You need to understand your customer behaviors both at the user-level, and also at the company or team-level.  You can read more abouthow Segment thinks about B2B tracking, andread more about the B2B Spec.
If your organization sells products online, the E-commerce Spec covers the customer’s journey as they browse your store, click on promotions, view products, add those products to a cart, and complete a purchase. It also provides recommendations about off-page interactions, including interactions with email promotions, coupons, and other systems. You can read more aboutwhy companies need an Ecommerce Spec, read more aboutEcommerce tracking plans, and dive directly into ourEcommerce Spec.
The native Mobile Spec is a common blueprint for the mobile user lifecycle. The Spec outlines the most important events for mobile apps to track, and automatically collects many of these events when you use theSegment Android and iOS SDKs. Read more about thebenefits of the native mobile spec, or read throughthe Native Mobile Specdirectly.
Segment’s video spec helps you understand how customers engage with your video and ad content, including playback events, types of media displayed, and performance metrics. You canread more about our Video Spec.
Regardless of approach, here are some important best practices to keep in mind:
Pick a casing convention:We recommendTitle Casefor event names andsnake_casefor property names. Make sure you pick a casing standard and enforce it across your events and properties.
Pick an event name structure:As you may have noticed from ourspecs, we’re big fans of the Object (Blog Post) + Action (Read) framework for event names. Pick a convention and stick to it.
Don’t create event names dynamically:Avoid creating events that pull a dynamic value into the event name (for example,User Signed Up (11-01-2019)). If and when you send these to a warehouse for analysis, you end up with huge numbers of tables and schema bloat.
Don’t create events to track properties:Avoid adding values to event names when they could be a property. Instead, add values as a property. For example, rather than having an event called “Read Blog Post - Best Tracking Plans Ever”, create a “Blog Post Read” event and with a property like"blog_post_title":"Best Tracking Plans Ever".
Don’t create property keys dynamically:Avoid creating property names like"feature_1":"true","feature_2":"false"as these are ambiguous and very difficult to analyze

Got all that? Great. You’re now ready to develop a Tracking Plan.
Atracking planclarifies what events to track, where those events live in the code base, and why you’re tracking those events (from a business perspective).A good tracking plan represents the single source of truth about what data you collect, and why.
Your tracking plan is probably maintained in a spreadsheet (unless you use Segment’s tracking-plan tool,Protocols), and serves as a project management tool to get your organization in agreement about what data to use to make decisions. A tracking plan helps build a shared understanding of the data among marketers, product managers, engineers, analysts, and any other data users.
The Identify call updates all records of the user with a set of traits, and so is extremely important for building your understanding of your users. But how do you choose which traits to include?
The example below shows an Identify call usinganalytics.js) for Segment:
The traits represent dimensions in your data that you can group or pivot on. For example, in the above, you can easily create cohorts of all types that areusersor accounts created within a time window of your choosing.
When you plan your deployment, think about what information you can collect as traits that would be useful to you when grouping users together, and plan how you will collect that information.
The Group call is similar to the Identify call, but it adds traits associated with a parent account to the user’s profile. If your organization is a B2B company, you should also plan the group traits to collect, and how you’ll use them once they’re applied to a user account.
We recommend starting with fewer events that are directly tied to one of yourbusiness objectives, to help avoid becoming overwhelmed by endless number of possible actions to track. As you get more comfortable, you can add more events to your tracking plan that can answer more specialized questions.
At Segment, we started out tracking these events:
Then we added some peripheral events to to better understand how we’re performing, for the following reasons:
For an Ecommerce company, however, the main events might be something like:
Tip: As mentionedabove, Segment has a set of “reserved” event names specifically for ecommerce, called theEcommerce Spec. Check it out to see which events Segment covers and how they are used in downstream destinations.
An online community, on the other hand, has an entirely different set of actions that indicate engagement, as listed below. For example, a community might want to track actions like:
With these actions tracked, the community can develop metrics around engagement, and understand how users move towards their ultimate conversion events. You can read more inthis article from the online community GrowthHackersabout the events they track and why.
Each Track call can accept an optional dictionary of properties, which can contain any key-value pair. These properties act as dimensions that allow destination tools to group, filter, and analyze the events. They give you additional detail on broader events.
Events should be generic and high-level, but properties should be specific and detailed. For example, at Segment,Business Tier Workspace Createdis a horrible event name. Instead, we usedWorkspace Createdwith apropertyofaccount_tierand value ofbusiness:
Similar to the traits in the Identify call, the properties provide a column that you can pivot against or filter on in your analytics tools or allow you to create a cohort of users in email tools.
Don’t create dynamically generated property names in the properties dictionary. Eachkeycreates a new column in your downstream tools, and dynamically generated keys clutter your tools with fragmented data that makes it difficult and confusing to use later.
Here is Segment’sLead CapturedTrack call:
The high-level event isLead Captured, and all of the details appear in the properties dictionary. Because of this, we can easily see in our downstream tools how many leads were captured, and from which parts of the site.
If you want to learn more about how properties are used by downstream tools, check outThe Anatomy of a Track Call.
Once you’ve completed your tracking plan, there’s one more step you might want to do before you move on to actually implementing Segment. TheSegment destination catalogcontains hundreds of tools, many of which you’ll be familiar with already.
If your organization has an established set of analytics tools, look for those tools in the catalog and bookmark their documentation pages. These docs pages contain important information about how Segment transforms data for the destination tool, and they also contain useful details about troubleshooting, set-up, and implementation considerations.
Once you have an initial list of the destination tools your organization uses, you can also checkwhich Segment methods those tools accept. This helps you at implementation time to ensure that the calls you use can be consumed by the tools they’re intended for.
Additionally, you should checkwhich connection modes each tool supports, so you know ahead of time which destinations may need to be bundled.
Tip: If you know you’re looking for a tool for a specific purpose, but haven’t chosen one yet, you can also check theConnection Modes by category pageto see which tools might be compatible with the least implementation changes.
Walk through a disposable, demo implementation.
Take your plans, and make them real.
Headings:
Planning a Full Installation
Define Business Objectives
Decide what to collect
Shortcut: Check if a Business Spec meets your needs
B2B Spec
Ecommerce Spec
Mobile Spec
Video Spec
Create naming conventions
Develop a tracking plan
Plan your Identify and Group calls
Plan your Track events
Define your Track event properties
Plan for destination tools
backA simple Segment installation
nextA full Segment implementation
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/04-full-install/
Paragraphs:
On this page
Related content
Before you start implementing from your tracking plan, let’s review the Segment methods, what they do, and when you should use each.
Segment’s libraries generate and send messages to our tracking API in JSON format, and provide a standard structure for the basic API calls. We also provide recommended JSON structure (also known as a schema, or ‘Spec’) that helps keep the most important parts of your data consistent, while allowing great flexibility in what other information you collect and where.
There are six calls in the basic tracking API, which answer specific questions:
Among these calls, you can think of Identify, Group, and Alias as similar types of calls, all to do with updating our understanding of the user who is triggering Segment messages. You can think of these calls as adding information to, or updating an object record in a database.Objectsare described using “traits”, which you can collect as part of your calls.
The other three, Track, Page, and Screen, can be considered as increasingly specific types of events.Eventscan occur multiple times, but generate separate records which append to a list, instead of being updated over time.
A Track call is the most basic type of call, and can represent any type of event. Page and Screen are similar and are triggered by a user viewing a page or screen, however Page calls can come from both web and mobile-web views, while Screen callsonlyoccur on mobile devices. Because of the difference in platform, the context information collected is very different between the two types of calls.
Segment recommends that you always use the Page and Screen calls when recording a page-view, rather than creating a “Page Viewed” Track event, because the Page/Screen calls automatically collect more contextual information.
The most basic Segment message requires only auserIDoranonymousID; all other fields are optional to allow for maximum flexibility. However, a normal Segment message has three main parts: thecommon fields, the“context” object, and the properties (if it’s an event) or traits (if it’s an object).
The common fields include information specific to how the call was generated, like the timestamp and library name and version. The fields in the context object are usually generated by the library, and include information about the environment in which the call was generated: page path, user agent, OS, locale settings, etc. The properties and traits are optional and are where you customize the information you want to collect for your implementation.
Another common part of a Segment message istheintegrationsobject, which you can use to explicitly filter which destinations the call is forwarded to. However this object is optional, and is often omitted in favor of non-code based filtering options.
The Identify call allows Segment to knowwhois triggering an event.
Call Identify when the user first provides identifying information about themselves (usually during log in), or when they update their profile information.
When called as part of the login experience, you should call Identify as soon as possible after the user logs in. When possible, follow the Identify call with a Track event that records what caused the user to be identified.
When you make an Identify call as part of a profile update, you only need to send the changed information to Segment. You can send all profile info on every Identify call if that makes implementation easier, but this is optional.
Learn More
Best Practices for Identifying Users
These are calledtraitsfor Identify calls, andpropertiesfor all other methods.
The most important trait to pass as part of the Identify call is userId, which uniquely identifies a user across all applications.
You should use a hash value to ensure uniqueness, although other values are acceptable; for example, email address isn’t the best thing to use as a userid, but is usually acceptable since it will be unique, and doesn’t change often.
Beyond that, the Identify call is your opportunity to provide information about the user that can be used for future reporting, so you should try to send any fields that you might want to report on later.
Consider using Identify and traits when:
You can call Identify from any of Segment’s device-based or server-based libraries, includingJavascript,iOS,Android,Ruby, andPython.
Here are two examples of calling Identify from two different libraries:
When a user explicitly signs out of one of your applications, you can callanalytics.reset()to stop logging further event activity to that user, and create a newanonymousIdfor subsequent activity (until the user logins in again and is subsequently identify-ed).This call is most relevant for client-side Segment libraries, as it clears cookies in the user’s browser.
Make areset()call as soon as possible after sign-out occurs, and only after it succeeds (not immediately when the user clicks sign out). For more info on this call,see the JavaScript source documentation.
The Page and Screen calls tell Segment what web page or mobile screen the user is on. This call automatically captures important context traits, so you don’t have to manually implement and send this data.
You can alwaysoverride the auto-collected Page/Screen propertieswith your own, and set additional custom page or screen properties.
Some downstream tools (likeMarketo) require that you attach specific properties (like email address) to every Page call.
This is considered a destination-specific implementation nuance, and you should check the documentation for each destination you plan to use and make a list of these nuances before you start implementation.
You can specify a page “Name” at the start of the page or Screen call, which is especially useful to make list of page names into something more succinct for analytics. For example, on an ecommerce site you might want to callanalytics.page( "Product" )and then provide properties for that product:
Segment automatically calls a Page event whenever a web page loads. This might be enough for most of your needs, but if you change the URL path without reloading the page, for example in single page web apps, you must call Page manually .
If the presentation of user interface components don’t substantially change the user’s context (for example, if a menu is displayed, search results are sorted/filtered, or an information panel is displayed on the exiting UI)measure the event with a Track call, not a Page call.
Note: When you trigger a Page call manually, make sure the call happensafterthe UI element is successfully displayed, not when it is called. It shouldn’t be called as part of the click event that initiates it.
For more info on Page calls, reviewPage specandAnalytics.js docs.
Segment Screen calls are essentially the Page method, except for mobile apps. Mobile Screen calls are treated similarly to standard Page tracking, only they contain more context traits about the device. The goal is to have as much consistency between web and mobile as is feasible.
The Track call allows Segment to knowwhatthe user is doing.
The Track call is used to track user and system events, such as:
Your Track calls should include both events and properties.Events are the actions you want to track, andproperties are the dataaboutthe event that are sent with each event.
Propertiesare powerful. They enable you to capture as much context about the event as you’d like, and then cross-tabulate or filter your downstream tools. For example, let’s say an eLearning website is tracking whenever a user bookmarks an educational article on a page. Here’s what a robust analytics.js Track call could look like:
With this Track call, we can analyze which authors had the most popular articles, which months and years led to the greatest volume of bookmarking overall, which button locations drive the most bookmark clicks, or which users gravitate towards infographics related to Data Planning.
Each event you track must have a name that describes the event, like ‘Article Bookmarked’ above. That name is passed in at the beginning of the Track call, and should be standardized across all your properties so you can compare the same actions on different properties.
Segment’s best practice is to use an “Object Action” (Noun<>Verb) naming convention for allTrackevents, for example, ‘Article Bookmarked’.
Segment maintains a set ofBusiness Specswhich follow this naming convention around different use cases such as eCommerce, B2B SaaS, and Mobile.
Let’s dive deeper into the Object Action syntax that all Segment Track events should use.
Nouns are the entities or objects that the user or the system acts upon.
It’s important to be thoughtful when naming objects so that they are referred to consistently within an application, and so that you refer to the same objects that might exist in multiple applications or sites by the same name.
Use the following list of objects to see if there is a logical match with your application. If you have objects that aren’t in this list, name it in a way that makes sense if it were to appear in other applications, and/or run it by Product Analytics.
Verbs indicate the action taken by either a user on your site. When you name a new Track event, consider if you can describe the current interaction using a verb from the list below.
If you can’t, choose a verb that describes what the user is trying to do in your specific case, but try to be flexible enough so that you could use it in other scenarios.
Segment recommends that you record property names usingsnake case(for exampleproperty_name), and that you format property values to match how they are captured. For example, ausernamevalue would be captured in whatever case it the user typed it in as.
Ultimately, you can decide to use a casing different from our recommendations; however,the single most important aspect is that you’re consistent across your entire tracking with one casing method.
You can read more aboutbest practices for Track calls, .
All of the basicSegment methodshave a common structure and common fields which are automatically collected on every call. You can see these in thecommon fields documentation.
The following properties should be sent with every Track call:
You can make a Track call from any of Segment’s client-side or server-side libraries, includingJavaScript,iOS,Android,Ruby, andPython. Here are two examples of calling Track from two different libraries:
Think through your goals, plan your calls, and set yourself up for success.
Unlock the power of Segment with Destinations.

Headings:
A Full Segment Implementation
Segment methods in detail
Anatomy of a Segment message
Identify calls
When to call Identify
Traits in Identify calls
How to Call Identify
Using analytics.reset()
Page and Screen
Page and Screen call properties
Named Page & Screen Calls
When to Call Page
When to call Screen
Track calls
When to call Track
Events and Properties
Event Naming Best Practices
Objects are Nouns
Some suggested Nouns
Actions are Verbs
Some suggested Verbs
Property naming best practices
Common properties to send with a Track call
How to call Track
backPlanning a Full Installation
nextSending data to Destinations
Further reading
Best Practices for Event Calls
Best Practices for Identifying Users
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/05-data-to-destinations/
Paragraphs:
On this page
Once you’ve got data flowingintoSegment, what do you do with it? The Segment Destination catalog lists all of the places we can send your data.
When you enable a destination in the Segment App, you link it to a specific source (or sources). By default, Segment first processes the data from the selected source(s), then translates it and routes it from the Segment servers to the API endpoint for that destination.
This means that if you previously had loaded code or a snippet for that tool on your website or app, you should remove it once you have Segment implemented so you don’t send duplicate data.
You might also want to enable tools that need to be loaded on the user’s device (either a computer or mobile device) in order to function properly. For our Analytics.js library, you can make these changes from the Segment App, and the Segment systems then update the bundle of code served when users request the page to include code required by the destination. You can read more about this in ourdocumentation on Connection Modes.
Adding a destination is quick and easy from the Segment App. You’ll need a token or API key for the tool, or some way to confirm your account in the tool.
If you’re just starting out, we know thecatalogcan be really overwhelming. How do you choose from all of the available destinations?
We’ve written a lot abouthow to choose your tools, but as a start, we recommend that you have one tool from each of the following categories:
If you’re adding more destinations after you’ve done your Segment instrumentation, you might want to check that the destinations you choosecan accept the methodsyou’re already using, and that they canuse the Connection Modesyou’re already using.
We also feel that it’s really important to have a data warehouse, so you can get aclearer view of all of your datafor analytics purposes. More on that just below.
Warehouses are a special type of destination which receive streaming data from your Segment sources, and store it in a tableschema based on your Segment calls. This allows you to do a lot of interesting analytics work to answer your own questions about what your users are doing and why.
All customers can connect a data warehouse to Segment. Free and Team customers can connect one, while Business customers can connect as many as needed.
You should spend a bit of timeconsidering the benefits and tradeoffs of the warehouse options, and then choose one from ourwarehouse catalog.
When you choose a warehouse, you can then use the steps in the documentation to connect it. This may require that you create a new dedicated user (or “service user”) to allow Segment to access the database.
Once your warehouse is configured and running, you can connect to it using a Business Intelligence (BI) tool (such as Looker, Mode, Tableau, or others) to analyze your data in-depth.
There are also a number of Business tier features you can then use with your warehouse, includingselective syncandReplay.
Check out our course on warehouses in Segment University. (Must be logged in to access.)
Take your plans, and make them real.
Test your implementation and see where your data is and isn't arriving.
This page was last modified: 09 Aug 2022
Questions? Problems? Need more info? Contact Segment Support for assistance!
Thanks for your feedback!
Can we improve this doc?Send us feedback!
On this page
Was this page helpful?
Thanks for your feedback!
Can we improvethis doc?Send us feedback!
Product
For Developers
Company
Support
© 2025 Segment.io, Inc.

Headings:
Sending data to destinations
Routing data to destinations
Adding new destinations
Recommended destinations
Adding a warehouse
Segment University: Warehouses
backA full Segment implementation
nextTesting and Debugging
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/06-testing-debugging/
Paragraphs:
On this page
One of the most important questions you’ll ask early on is“How do I know if Segment is working?”
There are several ways to check if your data is flowing. One is theDebugger tab in each Sourcein the Segment web app, where you can see data coming from a source into Segment. Another is theEvent Delivery toolwhich shows which data is arriving at specific destinations.
For monitoring purposes, you’ll also see alerts in theWorkspace Healthtool if your sources or destinations produce repeated errors.
Want more? Check out our course on debugging and troubleshooting. (Must be logged in to access.)
The Source Debugger is a real-time tool that helps you confirm that API calls made from your website, mobile app, or servers arrive to your Segment Source, so you can troubleshoot your Segment set up even quicker. With the Debugger, you can check that you’re sending calls in the expected format, without having to wait for any data processing.

The Debugger is separate from your workspace’s data pipeline and is not an exhaustive view of all the events ever sent to your Segment workspace. The Debugger only shows a sample of the events that the Source receives in real time, with a cap of 500 events. The Debugger is a great way to test specific parts of your implementation to validate that events are being fired successfully and arriving to your Source.
To see a more complete view of all your events, we recommend that you set up either awarehouseor anS3 destination.
The Debugger shows a live stream of sampled events arriving into the Source, but you can also pause the stream from displaying new events by toggling “Live” to “Pause”. Events continue to arrive to your Source while you Pause the stream.
You can search in the Debugger to find a specific payload using any information you know is available in the event’s raw payload. You can also use advanced search options to limit the results to a specific event.

Two views are available when viewing a payload:
The Event Delivery tool helps you see if Segment is encountering issues delivering your data from your sources to their connected destinations.
Segment sends billions of events to destinations every week. If our systems encounter errors when trying to deliver your data, we report them in the Event Delivery tool.
Here is an example of what the Event Delivery tool looks like:

Event Delivery is most useful when:
You can access the Event Delivery tool from the destinationSettingstab in any supported destination.

Event Delivery is only available for cloud-mode destinations, which receive data through the Segment servers. Device-mode destinations receive data through an API endpoint outside the Segment servers, where we cannot monitor or report on it.Event delivery is not available for Warehouses or Amazon S3 destinations.
The UI shows three parts that report on Segment’s ability to deliver your source data: Key Metrics, Error Details, and Delivery Trends.
Before you begin,select a time period from the drop down menu at the right. The Event Delivery display updates to show only information about your selected time period.

This panel displays quantitative information about the destination’s data flow:
Delivered:The number of messages Segment successfully delivered to the destination in the selected time period.
Not Delivered:The number of messages Segment was unable to deliver. If this number is greater than zero, the reasons for these failures appear in the errors table below.
P95 Latency:The time it takes for Segment to deliver the slowest 5% of your data (known as P95 latency). The latency reported is end-to-end: from the event being received through the Segment API, to the event being delivered to partner API. This helps tell you if there is a delay in your data pipeline, and how severe it is.
The Error details table displays a summary of the errors in a given period, and the most important information about them. You can click any row in the table to expand it to show more information.

The Error Details view gives you as much information as possible to help you resolve the issue. The example below shows an example Error Details panel.

This view includes:
You Sent- the data you sent to Segment’s API.
Request to Destination- the request Segment made to the Partner API. This payload will likely be different from what you sent it because Segment is mapping your event to the partner’s spec to ensure the message is successfully delivered.
Response from Destination- the response Segment received from the Partner API. This will have the raw partner error. If you need to troubleshoot an issue with a Partner’s Success team, this is usually something they’ll want to see.
View Segment’s list ofIntegration Error Codesfor more information about what might cause an error.
When debugging, it’s helpful to see when issues start, stop and how they trend over time.
The Event Delivery view shows a graph with the following information:
Delivered: The number of events that were successfully delivered in the time period you selected.
Not delivered: The number of events that were not successfully delivered in the time period you selected.
The Latency view shows the end-to-end P95 latency during the time period you selected.

Unlock the power of Segment with Destinations
Learn about what you can do next with Segment
This page was last modified: 06 Jul 2022
Questions? Problems? Need more info? Contact Segment Support for assistance!
Thanks for your feedback!
Can we improve this doc?Send us feedback!
On this page
Was this page helpful?
Thanks for your feedback!
Can we improvethis doc?Send us feedback!
Product
For Developers
Company
Support
© 2025 Segment.io, Inc.

Headings:
Testing and Debugging
Segment University: Debugging and Troubleshooting
The Source Debugger
Event Delivery
Using Event Delivery
Key metrics
Error details
Trends
backSending data to Destinations
nextWhat's next?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/whats-next/
Paragraphs:
On this page
You’re just getting started with Segment, but there’s so much more to explore!
Segment includes a free suite of Privacy tools to help your organization comply with regulations like the GDPR and the CCPA.
ThePrivacy Portalallows you to easily audit, monitor, and enforce privacy rules against your Segment data, to proactively protect your customers.
You had a taste of the planning needed to set up clear, consistent, reliable and extensible data schemas inPlanning a Full Install.
Business tier customers can use Segment’sProtocolspackage to help with this process, to keep track of what data is being collected where, and to normalize their data as it flows through Segment. Clean, consistent data helps you move faster to build marketing campaigns and act on analytics insights.
With Protocols, you can useTracking Plansto build consensus in your organization about which events and property you intend to collect across your web, mobile or server-side data sources. Once defined, you can connect the Tracking Plan to your Sources to automaticallyvalidatethe data is flowing correctly. You can also turn onenforcementto block bad data, and even fix incorrect data withTransformations.
Engageis a powerful personalization platform that enables you to create unified customer profiles in Segment, to build and enrich audiences, and to activate audiences across marketing tools.
With Engage, you can create unified customer profiles, enrich those profiles with new traits, build Audiences using those profiles, and sync audiences to marketing tools to power personalized experiences, and better understand and market to your customers.
Segment Universityis Segment’s free, online classroom for learning the basics of Segment.
Analytics Academyis a series of lessons designed to help you understand the value of analytics as a discipline, and to help you think through your analytics needs, and get started creating robust and flexible analytics systems to help you grow.
Need ideas or prior art?Segment Recipesare some cool things you can do by hooking your Segment workspace up to different Destination tools. Everything from sending tailored onboarding emails, to joining and cleaning your data with third party tools
Still hungry for more? Check out our list ofother Segment Resources!
If you’re experiencing problems, have questions about implementing Segment, or want to report a bug, you can fill out oursupport contact form hereand our Product Support Engineers will get back to you.
You need a Segment.com account in order to file a support request. Don’t worry! You can always sign up for a free workspace if you don’t already have one.
Back to the Getting Started index

Headings:
What's Next
Privacy tools and filtering
Improve data quality with Protocols
Single view of the customer with Engage
More learning resources
Segment University
Analytics Academy
Recipes
Other Resources
Technical Support
Back to the index
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/use-cases//
Paragraphs:
On this page
Use Cases are pre-built Segment setup guides tailored to common business goals.
Use Cases eliminate guesswork with a structured approach to onboarding, helping you configure Segment correctly and align its features to your business objectives.
You can onboard to Segment with a Use Case if you’re a new Business Tier customer or haven’t yet connected a source and destination.
Not sure where to start? Read through Segment's Choosing a Use Case guide, which breaks down the available business goals and their associated use cases.
Follow the steps in the Use Cases Setup guide to get up and running with Segment.
Looking for something more technical? View the Use Cases Reference, which lists the tracking events, connections, and destinations Segment recommends for each use case.
Explore the following core Segment features, all of which power Use Cases.
Collect event data from your mobile apps, websites, and servers.
Forward your data to the business tools and apps your business uses.
Track user interactions, resolve their identities, and explore Profiles.
Build, enrich, and activate audiences with Segment's personalization platform.
This page was last modified: 08 Oct 2024
Questions? Problems? Need more info? Contact Segment Support for assistance!
Thanks for your feedback!
Can we improve this doc?Send us feedback!
On this page
Was this page helpful?
Thanks for your feedback!
Can we improvethis doc?Send us feedback!
Product
For Developers
Company
Support
© 2025 Segment.io, Inc.

Headings:
Use Cases Overview
Onboard to Segment with Use Cases
Choosing a Use Case
Step-by-Step Use Cases Setup Guide
Use Cases Reference
Take the next step
Connections
Destinations
Unify
Engage
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/use-cases/guide//
Paragraphs:
On this page
Segment built Use Cases to streamline the process of implementing Segment for specific business objectives.
This guide will help you navigate through the available use cases and select the one that best aligns with your business goals.
You can onboard to Segment with a Use Case if you’re a new Business Tier customer or haven’t yet connected a source and destination.
Segment supports 25 use cases, organized into 4 main business goals:
These goals represent key ways businesses often use customer data for improved performance and growth.
Looking for a technical breakdown of each use case? View theUse Cases Reference.
Follow these steps to identify which use case to implement:
The use case you select will guide your Segment setup, including the events you’ll track and the integrations you’ll implement. However, Segment’s flexibility allows you to adapt and expand your strategy over time as your business needs evolve.
The following sections explore each business goal and associated use cases in detail.
TheOptimize advertisingbusiness goal focuses on improving the efficiency and effectiveness of your advertising efforts. By using your customer data effectively, you can create more targeted campaigns, reduce wasted ad spend, and increase your return on investment (ROI).
Key considerations for this goal:
Use cases in this category include:
ThePersonalize first conversiongoal focuses on optimizing the initial interactions a potential customer has with your brand. By personalizing these early touchpoints, you can increase the likelihood of converting prospects into customers.
Key considerations for this goal:
Use cases in this category include:
TheBoost retention, upsell, and cross-sellbusiness goal focuses on maximizing the value of your existing customer base. By analyzing customer behavior and preferences, you can create targeted strategies to encourage repeat purchases, introduce customers to higher-value products or services, and increase overall customer lifetime value.
Key considerations for this goal:
Use cases in this category include:
ThePersonalize communications and product experiencesbusiness goal focuses on creating tailored experiences for your customers across all touchpoints. With this business goal, you can create more relevant and engaging communications and product experiences, leading to increased satisfaction and loyalty.
Key considerations for this goal:
Use cases in this category include:
Once you’ve selected a use case, follow theUse Cases Setup Guide, which explains how to set up a use case.

Headings:
Choosing a Use Case
Understanding business goals and use cases
Selecting your use case
Optimize advertising
Personalize first conversion
Boost retention, upsell, and cross-sell
Personalize communications and product experiences
Next steps
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/use-cases/setup//
Paragraphs:
On this page
Use Cases help you onboard quickly and efficiently to Segment by guiding you through specific steps tailored to your business needs.
This page walks you through the steps to set up a use case in your Segment instance.
Permissions
To implement a use case, you’ll need to be a Workspace Owner for your Segment account. See theRolesdocumentation for more information.
You can onboard to Segment with a Use Case if you’re a new Business Tier customer or haven’t yet connected a source and destination.
From a high level, setting Segment up with a use case takes place in four stages:
This section provides a detailed, step-by-step guide to setting up thePersonalize Winbackuse case from thePersonalize communications and product experiencesbusiness goal in your Segment account. All use cases follow this same setup flow.
Choosing a use case
Segment lets you implement one use case. If you’re not sure which use case to choose, viewChoosing a Use Case.
For most cases, you’ll want to start with development or staging sources to test and debug your Segment implementation. This approach lets you verify that everything is working correctly before sending live data downstream. To facilitate this, Segment automatically creates development (dev) and production (prod) spaces for you and labels your sources accordingly to simplify tracking.
Segment strongly recommends beginning your setup in the dev environment. This allows for thorough testing and debugging of your configuration. Once you’re confident in your dev setup, Segment will guide you on how to apply these configurations to your live production sources.
Changing your use case
Once you’ve reviewed the suggested events for a use case, you won’t be able to change the use case. If you want to see a full breakdown of each use case before commiting to one, clickChange use caseto begin the use case flow again. You can also view theUse Cases Reference guideto see what Segment recommends for each use case.
On theSetup checklistpage, you’ll see the full checklist for the use case you’ve chosen. This checklist applies to all use cases, though the suggested events, sources, and destinations differ between use cases.
This table shows Segment’s recommended events and properties for the Personalize winback use case:
Make sure that you’re tracking these events to get the most of the Personalize winback campaign. For more information on event tracking, seeData Collection Best Practices.
You’re now ready to connect sources to your dev environment.
Adding a warehouse as a souce
If you connect a warehouse as a source, Segment automatically creates a Profiles destination that shows up in theConnect your datatab. Do not delete this destination, as Segment requires this destination to create profiles from your warehouse.
Cloud object sources
If you connect a cloud object source, you’ll need to create a warehouse to sync profiles into Segment. For more information, seeCloud Sources.
With sources connected, you can now connect destinations to your dev environment.
Until this point, you’ve set up event tracking and connected sources and destinations to a development environment.
After you’ve confirmed that data is flowing from your sources into your destinations as expected, you’re ready to publish your setup to a production environment.
Your data is now in production, and you’ve successfully configured Segment.
Now that you’ve successfully set up Connections and Destinations, you can build upon your Segment implementation with Unify and Engage.
Accessing Unify and Engage
Unify and Engage may not yet be enabled for your account. To add Engage to your Segment workspace, clickRequest a demoin the Unify and Engage tabs on the Guided Setup page.
Your identifiers are now set up in your dev space, though it could take a few minutes for Segment to create profiles from your selected identifiers.
For more information, see theUnify documentation.
Segment then begins sending your new audience(s) to the destinations in your dev environment. Verify in those destinations that the audiences are coming through as intended, then clickMark complete.
For more information on Audiences, see theEngage documentation.
At this point, you’ll have already published your initial setup to a prod environment. Next, you’ll publish your Unify and Engage setup to the same prod environment.
Segment then begins sending your new audience(s) to the destinations in your dev environment. Verify in those destinations that your audiences are coming through as intended, then clickMark complete.
Use Cases pulls together a number of core Segment features, likeSources,Destinations,data collection, andReverse ETL. View the documentation for each to learn how you can continue to expand and build on what you’ve alreay achieved.

Headings:
Use Cases Setup
Use case setup overview
Example setup: Personalize winback
Step 1: Navigate to Use Cases
Step 2: Pick your business goal and select a use case
Working with dev and prod environments
Step 3: Review suggested events
Step 4: Connect dev sources
Step 5: Connect dev destinations
Step 6: Publish your setup to a prod environment
Activate your data with Unify and Engage
Step 1: Set up identifiers with Unify
Step 2: Create audiences with Engage
Step 3: Republish to a prod environment
Next steps
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/getting-started/use-cases/reference//
Paragraphs:
On this page
This reference guide provides detailed information on the suggested events, sources, and destinations for each Segment use case. Use this guide to ensure you’re tracking the right events and connecting the best sources and destinations for your specific needs.
The business goal you select during onboarding determines the use cases that Segment shows you.
This table lists each business goal and each of its corresponding use cases:
This section contains tables for the different events, sources, and destinations that Segment recommends for each use case.
Click on each use case in this section to view Segment’s recommendations for the Optimize advertising business goal, which helps you improve return on ad spend.
This table shows the event and properties Segment recommends you track for the Build high value lookalikes use case, which helps you build from high-value purchasers through specific channels:
And this table shows the source and destination types that Segment recommends you set up for the Build high-value lookalikes use case:
This table shows the events and properties Segment recommends you track for the Build lookalikes for app install use case, which helps you build lookalikes from app installers in specific channels:
And this table shows the source and destination types that Segment recommends you set up for the Build lookalikes for app install use case:
This table shows the events and properties Segment recommends you track for the Increase signups with lookalikes use case, which helps you build lookalikes from signups through specific channels.:
And this table shows the source and destination types that Segment recommends you set up for the Increase signups with lookalikes use case:
This table shows the events and properties Segment recommends you track for the Mitigate cart abandonment use case, which helps you win back users to drive purchases and understand funnel:
And this table shows the source and destination types that Segment recommends you set up for the Mitigate cart abandonment use case, which helps you win back users to drive purchases and understand funnel:
This table shows the event and properties Segment recommends you track for the Mitigate high value churn use case, which helps you anticipate churn for your highest value users and prevent them from churning:
And this table shows the source and destination types that Segment recommends you set up for the Mitigate high value churn use case:
This table shows the event and properties Segment recommends you track for the Suppress based on time use case, which helps you suppress users after a few days to keep campaigns fresh:
And this table shows the source and destination types that Segment recommends you set up for the Suppress based on time use case:
This table shows the events and properties Segment recommends you track for the Suppress with purchase use case, which helps you suppress converted users immediately after a conversion:
And this table shows the source and destination types that Segment recommends you set up for the Suppress with purchase use case:
Click on each use case in this section to view Segment’s recommendations for the Personalize first conversion business goal, which helps you convert prospective or free customers.
This table shows the events and properties Segment recommends you track for the Accelerate app install use case, which helps you encourage app install with personalized messaging:
And this table shows the source and destination types that Segment recommends you set up for the Accelerate app install use case:
This table shows the events and properties Segment recommends you track for the Accelerate onboarding use case, which helps you optimize new user activation based on real-time behavior:
And this table shows the source and destination types that Segment recommends you set up for the Accelerate onboarding use case:
This table shows the events and properties Segment recommends you track for the Accelerate signup use case, which helps you encourage anonymous users to sign up with messaging:
And this table shows the source and destination types that Segment recommends you set up for the Accelerate signup use case:
This table shows the events and properties Segment recommends you track for the Acquire paid subscriptions use case, which helps you engage customers at the right time to drive conversions:
And this table shows the source and destination types that Segment recommends you set up for the Acquire paid subscriptions use case:
This table shows the events and properties Segment recommends you track for the Convert trials to paid subscriptions use case, which helps you get customers to upgrade through personalized messaging:
And this table shows the source and destination types that Segment recommends you set up for the Convert trials to paid subscriptions use case:
This table shows the events and properties Segment recommends you track for the Mitigate cart abandonment use case, which helps you win back users to drive purchases and understand funnel:
And this table shows the source and destination types that Segment recommends you set up for the Mitigate cart abandonment use case:
Click on each use case in this section to view Segment’s recommendations for the Boost retention, upsell, and cross-sell business goal, which helps you increase repeat visits or purchases.
This table shows the event and properties Segment recommends you track for the Build high value lookalikes use case, which helps you build from high-value purchasers through specific channels:
And this table shows the source and destination types that Segment recommends you set up for the Build high value lookalikes use case:
This table shows the events and properties Segment recommends you track for the Increase repeat purchases use case, which helps you convert single-purchase buyers with personalized communications:
And this table shows the source and destination types that Segment recommends you set up for the Increase repeat purchases use case:
This table shows the event and properties Segment recommends you track for the Mitigate high value churn use case, which helps you anticipate churn for your highest-value users and prevent them from churning:
And this table shows the source and destination types that Segment recommends you set up for the Mitigate high value churn use case:
This table shows the events and properties Segment recommends you track for the Nurture with content use case, which helps you use content personalized by interest to nurture leads or customers:
And this table shows the source and destination types that Segment recommends you set up for the Nurture with content use case:
This table shows the events and properties Segment recommends you track for the Personalize upsell content use case, which helps you personalize upsell and cross-sell messaging while understanding behavior:
And this table shows the source and destination types that Segment recommends you set up for the Personalize upsell content use case:
This table shows the events and properties Segment recommends you track for the Personalize winback use case, which helps you design personalized messaging based on user behavior:
And this table shows the source and destination types that Segment recommends you set up for the Personalize winback use case:
Click on each use case in this section to view Segment’s recommendations for the Personalize communications and product experiences business goal, which helps you engage your customers with relevant content.
This table shows the events and properties Segment recommends you track for the Accelerate onboarding use case, which helps you optimize new user activation based on real-time behavior:
And this table shows the source and destination types that Segment recommends you set up for the Accelerate onboarding use case:
This table shows the events and properties Segment recommends you track for the Increase repeat purchases use case, which helps you convert single-purchase buyers with personalized communications:
And this table shows the source and destination types that Segment recommends you set up for the Increase repeat purchases use case:
This table shows the event and properties Segment recommends you track for the Mitigate high value churn use case, which helps you anticipate churn for your highest-value users and prevent them from churning:
And this table shows the source and destination types that Segment recommends you set up for the Mitigate high value churn use case:
This table shows the events and properties Segment recommends you track for the Nurture with content use case, which helps you use content personalized by interest to nurture leads or customers:
And this table shows the source and destination types that Segment recommends you set up for the Nurture with content use case:
This table shows the events and properties Segment recommends you track for the Personalize upsell content use case, which helps you personalize upsell and cross-sell messaging while understanding behavior:
And this table shows the source and destination types that Segment recommends you set up for the Personalize upsell content use case:
This table shows the events and properties Segment recommends you track for the Personalize winback use case, which helps you design personalized messaging based on user behavior:
And this table shows the source and destination types that Segment recommends you set up for the Personalize winback use case:

Headings:
Use Cases Reference
Use Cases by business goal
Suggested events, sources, and destinations
Optimize advertising
Personalize first conversion
Boost retention, upsell, and cross-sell
Personalize communications and product experiences
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/
Paragraphs:
On this page
Welcome! This page is a high-level introduction to the Segment Platform, including what it does and how. (If you’re looking for detailed information about architecture, setup, or maintenance, you canskip ahead.)
Segment is a Customer Data Platform (CDP), which means that it provide a service that simplifies collecting and using data from the users of your digital properties (websites, apps, etc). With Segment, you can collect, transform, send, and archive yourfirst-party customer data. Segment simplifies the process of collecting data and hooking up new tools, allowing you to spend more time using your data, and less time trying to collect it.
You can also enrich the customer data you collect by connecting data from your other tools, and then aggregate it to monitor performance, inform decision-making processes, and create uniquely customized user experiences. You can also use Unify, Segment’s identity resolution tool, to unify data from individual users to gain a wholistic understanding of their actions.
Check out how to get started with Segment in Segment University! (Must be logged in to access.)
In its very simplest form, Segment generates messages about what’s happening in your site or app, then translates the content of those messages into different formats for use by other tools (called ‘Destinations’), and transmits messages to those tools. The Segment servers also archive a copy of the data, and cansend data to your storage systems(such as databases, warehouses, or bulk-storage buckets).
Segment’s libraries generate and send messages to the tracking API in JSON format. Segment provides a standard structure for the basic API calls, along with a recommended JSON structure (also known as the ‘Spec’, a type of schema) that helps keep the most important parts of your data consistent, while allowing great flexibility in what other information you collect and where.
When you implement Segment, you add the Segment code to your website, app, or server, which generates messages based on specific triggers you define. At its very simplest, this code can be a snippet that you copy and paste into the HTML of a website to track page views. It can also be as complex as Segment calls embedded in a React mobile app to send messages when the app is opened or closed, when the user performs different actions, or when time based conditions are met (for example “ticket reservation expired” or “cart abandoned after 2 hours”).
Segment hasSourcesandDestinations. Sources send messagesintoSegment (and other tools), while Destinations receive messagesfromSegment.
The most basic Segment message requires only auserIDoranonymousID; all other fields are optional to allow for maximum flexibility. However, a normal Segment message has three main parts: thecommon fields, the“context” object, and the properties (if it’s an event) or traits (if it’s an object).
The common fields include information specific to how the call was generated, like the timestamp and library name and version. The fields in the context object are usually generated by the library, and include information about the environment in which the call was generated: page path, user agent, OS, locale settings, etc. The properties and traits are optional and are where you customize the information you want to collect for your implementation.
Another common part of a Segment message istheintegrationsobject, which you can use to explicitly filter which destinations the call is forwarded to. However this object is optional, and is often omitted in favor of non-code based filtering options.
Segment provides several types of Sources which you can use to collect your data, and which you can choose among based on the needs of your app or site. For websites, you can embed a library which loads on the page to create the Segment messages. If you have a mobile app, you can embed one of Segment’s Mobile libraries, and if you’d like to create messages directly on a server (if you have, for example a dedicated .NET server that processes payments), there are several server-based libraries that you can embed directly into your backend code. (You can also usecloud-sourcesto import data about your app or site from other tools like Zendesk or Salesforce, to enrich the data sent through Segment.)
Once Segment generates the messages, it can send them directly to the Segment servers for translation and forwarding on to the Destinations you’re using, or it can make calls directly from the app or site to the APIs of your Destination tools. Which of these methods you choose depends on which Destinations you’re using and other factors. You can read more about these considerations in ourConnection Modes documentation
Messages sent to the Segment servers using the tracking API can then be translated and forwarded on to Destination tools, inspected to make sure that they’re in the correct format or schema, inspected to make sure they don’t contain any Personally Identifying Information (PII), aggregated to illustrate overall performance or metrics, and archived for later analysis and reuse.
In addition toConnections(our core message routing product) Segment offers additional features to help your organization do more with its data, and keep data clean, consistent, and respectful of end-user privacy. The following products are available:
I’m a Segment Developer
I’m a Segment Data user
I’m a Segment Workspace administrator
A workspace is a group of sources that can be administered and billed together. Workspaces help companies manage access for multiple users and data sources. Workspaces let you collaborate with team members, add permissions, and share sources across your whole team using a shared billing account.
When you first log in to your Segment account, you can create a new workspace, or choose to log into an existing workspace if your account is part of an existing organization.
In Segment, you create a source (or more than one!) for each website or app you want to track. Wehighly recommendcreating a Source for each unique source of data (each site, app, or server), though this isn’t required.
Sources belong to a workspace, and the URL for a source looks something like this:https://segment.com/<my-workspace>/sources/<my-source-name>/
You can create new sources using the button in the workspace view. Each source you create has a write key, which is used to send data to that source. For example, to loadanalytics.js, the Segment JavaScript libraryon your page, the snippet on theQuickstart Guideincludes:
Destinations are business tools or apps that you can connect to the data flowing through Segment. Some of Segment’s most popular destinations are Google Analytics, Mixpanel, Kissmetrics, Customer.io, Intercom, and KeenIO.
All of these tools run on the same data: who are your customers and what are they doing? But each tool requires that you send that data in a slightly different format, which means that you’d have to write code to track all of this information, again and again, for each tool, on each page of your app or website.
Enter Segment. Do it once.
Segment eliminates this process by introducing an abstraction layer. You send your data to Segment, and Segment understands how to translate it so we can send it along to any destination. You enable destinations from the catalog in the Segment App, and user data immediately starts flowing into those tools. No extra code required!
Segment supports many categories of destinations, from advertising to marketing, email to customer support, CRM to user testing, and even data warehouses. You can view a complete list of availabledestinationsor check out thedestination pagefor a searchable list broken down by category.
A warehouse is a central repository of data collected from one or more sources. This is what commonly comes to mind when you think about a relational database: structured data that fits neatly into rows and columns.
In Segment, a Warehouse is a special type of destination. Instead of streaming data to the destination all the time, we load data to them in bulk at regular intervals. When we load data, we insert and update events and objects, and automatically adjust their schema to fit the data you’ve sent to Segment.

Headings:
An introduction to Segment
What is Segment?
Segment University: How Segment Works
What does it do?
How does Segment work?
Segment Messages
Anatomy of a Segment message
Segment Sources
Destinations
What happens next?
What are the other parts of the Segment platform?
Where can I learn more?
What’s a Workspace?
What’s a Source?
What’s a Destination?
What’s a Warehouse?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/intro-impl/
Paragraphs:
On this page
This guide explains all you need to know to get started with your Segment implementation, and directs you to more resources depending on your specific needs.
If you haven’t already, you should read thedetailed explanation of Segmenton the previous page!
See a quick example of Segment working on an ecommerce website. (Must be logged in to access.)
Segment sends messages about activities in your mobile apps, websites or servers, receives those messages, and translates and forwards the message content to Destination tools. It also can send the contents of those messages to a bulk storage destination for archiving. In more complicated implementations, Segment can serve as a wrapper to trigger messages directly to other APIs, and can inspect, correct, classify and block the message contents.
Segment’s libraries generate and send messages to our tracking API in JSON format, and provide a standard structure for the basic API calls. We also provide recommended JSON structure (also known as a schema, or ‘Spec’) that helps keep the most important parts of your data consistent, while allowing great flexibility in what other information you collect and where.
There are six calls in the basic tracking API, which answer specific questions:
Among these calls, you can think of Identify, Group, and Alias as similar types of calls, all to do with updating our understanding of the user who is triggering Segment messages. You can think of these calls as adding information to, or updating an object record in a database.Objectsare described using “traits”, which you can collect as part of your calls.
The other three, Track, Page, and Screen, can be considered as increasingly specific types of events.Eventscan occur multiple times, but generate separate records which append to a list, instead of being updated over time.
A Track call is the most basic type of call, and can represent any type of event. Page and Screen are similar and are triggered by a user viewing a page or screen, however Page calls can come from both web and mobile-web views, while Screen callsonlyoccur on mobile devices. Because of the difference in platform, the context information collected is very different between the two types of calls.
Tip! Segment recommends that you always use the Page and Screen calls when recording a page-view, rather than creating a “Page Viewed” event, because the Page/Screen calls automatically collect much better context information.
The most basic Segment message requires only auserIDoranonymousID; all other fields are optional to allow for maximum flexibility. However, a normal Segment message has three main parts: thecommon fields, the“context” object, and the properties (if it’s an event) or traits (if it’s an object).
The common fields include information specific to how the call was generated, like the timestamp and library name and version. The fields in the context object are usually generated by the library, and include information about the environment in which the call was generated: page path, user agent, OS, locale settings, etc. The properties and traits are optional and are where you customize the information you want to collect for your implementation.
Another common part of a Segment message istheintegrationsobject, which you can use to explicitly filter which destinations the call is forwarded to. However this object is optional, and is often omitted in favor of non-code based filtering options.
The Segment “Specs” provide recommended message schemas - the information we recommend that you collect - for each type of call. These are recommendations not requirements, but if you follow these schema guidelines the Segment servers can more easily identify parts of your messages, and translate them to downstream tools.
In addition to the recommended message schemas, Segment also provides “blocks”: recommendations on what information to collect and how to format it, for different industries and use cases. These are recommendations only, but by collecting all of the information in these blocks, you can ensure that common tools used in that use-case have the information they need to function.
A third section of the Spec is the “industry specs” which provide recommendations that include an explicit translation or mapping in the Segment servers, to best power the downstream Destinations commonly used in these industries.
When you start out, you create a Workspace, which serves as a container for all of your Sources and Destinations.
Segment hasSourcesandDestinations. Sources send dataintoSegment, while Destinations receive datafromSegment.
Segment has five types of sources: Web (Analytics.js), Mobile, Server, and Cloud App, plus a fifth type: User-createdSource Functions. Web, Mobile, and Server sources send first-party data from your digital properties. Cloud-app sources send data about your users from your connected web apps, for example a ticketing system such asZendesk, a payments system such asStripe, or a marketing tool likeBraze.
Segment has several types of sources, and many destinations can accept data from all of them. However, some are only compatible with specific source types (for example, web only, or server only). To find out which source types a specific destination can accept data from, check the documentation for that destination for a “Supported Sources and Connection Modes” section.
Segment’s web source (Analytics.js), and native client-side libraries (iOS, Android, React-native) allow you to choose how you send data to Segment from your website or app. There are two ways to send data:
Cloud-mode: The sources send data directly to the Segment servers, which then translate it for each connected downstream destination, and send it on. Translation is done on the Segment servers, keeping your page size, method count, and load time small.
Healthcare and Life Sciences (HLS) customers can encrypt data flowing into their destinations
HLS customers with a HIPAA eligible workspace can encrypt data in fields marked as Yellow in the Privacy Portal before they flow into an event stream, cloud-mode destination.To learn more about data encryption, see theHIPAA Eligible Segment documentation
Device-mode: You include additional code on your website or mobile app which allows Segment to use the data you collect on the device to make calls directly to the destination tool’s API, without sending it to the Segment serversfirst. (You still send your data to the Segment servers, but this occurs asynchronously.) This is also calledwrappingorbundling, and it might be required when the source has to be loaded on the page to work, or loaded directly on the device to function correctly. When you use Analytics.js, you can change the device-mode destinations that a specific source sends from within the Segment web app, without touching any code.

If you use Server source libraries, they only send data directly to Segment in Cloud-mode. Server library implementations operate in the server backend, and can't load additional destination SDKs.
To learn more about connection modes and when you should use each, see thedetails in the Destinations docs.
The journey of a thousand miles begins, ideally, with a plan. Regardless of if you’re a new company just implementing analytics for the first time, or a multi–national corporation modernizing your analytics stack, it’s a great idea tostart with a Tracking Plan. For new implementations, this can be as simple as a document where you write down these four things for each item you track:
If you’re a large or long-established organization and you’re replacing existing tools, you’ll want to spend more time on this to maintain analytic parity and continuity of tooling. We highly recommendreading up on tracking plansandschemasforProtocols, our tool for managing and sharing tracking plans and enforcing schemas.
Regardless of your organization’s size or age, you’ll want to take an inventory of the destination tools you’ll be using with Segment, and make a list of the connection modes each one accepts. This makes it easier to check off when you’ve implemented each one, so you’re not missing anything.
There are several ways to check if your data is flowing. One is theDebugger tab in each Sourcein the Segment web app, where you can see data coming from a source into Segment. Another is theEvent Delivery toolwhich shows which data is arriving at specific destinations.
For monitoring purposes, you’ll also see alerts in theWorkspace Healthtool if your sources or destinations produce repeated errors.
There are several different ways to ensure that you can collect your data once, but filter it out of specific destinations. SeeFiltering Datafor a list of the available methods and descriptions.
If you’re seeing errors thrown by your destinations, you might have an implementation issue. See theIntegration Error Codes listorcontact our Success engineering teamfor help.
Have suggestions for things to add to this guide?Drop us a line.
Segment has aTerraformprovider, powered by the Public API, that you can use to manage Segment resources, automate cloud deployments, and change control. Take a look at theSegment provider documentationon Terraform to see what’s supported.

Headings:
Segment for Developers
Segment University: Segment in Action
What does Segment do?
Types of Segment messages
Anatomy of a Segment message
Message schemas, Blocks, and Specs
Sources and Destinations
Connection modes
Planning your Segment implementation
How do I test if it’s working?
How do I filter my data?
Troubleshooting
Segment Terraform Provider
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/intro-user/
Paragraphs:
On this page
If you aren’t involved in setting up your Segment implementation, or are just starting to set up Destinations for your organization’s workspace, this guide is for you.
If you read thedetailed explanation of Segmenton the previous page, you can skip ahead!
Segment is a system for sending messages from your websites, mobile apps, and servers. These messages contain data about events on, or users of those systems, and these messages can sent on to other tools, and gathered together in a warehouse for later analysis. Segment can also bring in information about your users from external systems, such as helpdesks or CRM systems, and collate that information to help you analyze your data, build audiences of users, and personalize your users’ experiences.
Once you (or your organizations’ developers) have your Segment Sources set up and sending data, you can log in to the Segment App and set up Destinations, which are how Segment sends that data to other tools (like Google Analytics, Mixpanel, and many others).
Depending on your organization’s configuration and access settings, you might be able to see one or multiple Environments (for example, “Production”, “Testing”, “Development”), or one or multipleLabels, which control access to different parts of your organization’s Segment system.  If you see several environments, contact your Segment administrator for more details so you can make sure you make your changes in the right place.
Data enters the Segment systems from Sources, but once data is in the system, your organization may have different tools configured to control and change it. This could change what data is available to you, or any destinations you set up.
For example, Protocols makes sure that data coming into Segment follows specific formats and patterns, and might block and discard malformed or unwanted data. The Privacy tool can be configured to remove Personally Identifiable Information (PII) from the data. And several different methods are available tofilter dataso that it doesn’t send certain types of events, or reach specific destinations or warehouses.
Depending on the access level you have in your organization’s Segment workspace, you might be able to create new Destinations, or you might only be able to edit existing ones.
To add a new Destination, you’ll usually need some information (such as a token or API key) from the destination tool to start. You’ll enter that into the Segment App so we can connect to and send data to that tool. You’ll also need to know which Source you’ll be sending data from.
To set up a destination:
Tip: Segment usually is able to translate data into a format that the destination expects, however some destinations (such as Adobe Analytics) may require manual mapping steps to configure properly. If you see additional fields for mapping configuration, read the documentation for that destination to learn more.
If you’re setting up a destination to usecloud-mode data(data that’s sent through Segment, rather than directly from a user’s device), you can use theEvent TesterandEvent Deliverytools to check that data is arriving, and being correctly delivered to the destination.
Have suggestions for things to add to this guide?Drop us a line!

Headings:
Segment for Data Users
What is Segment?
Environments and Labels
Data inside Segment
Set up a Destination
Troubleshooting
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/intro-admin/
Paragraphs:
On this page
If your job is to set up or maintain a Segment Workspace for your organization, or assist other people using the Segment Web App, this guide is for you. If you’re more interested in Segment implementation details, see thedeveloper intro guide.
If you’ve already readan Introduction to Segment, you can skip ahead.
Segment is a system for sending messages from your websites, mobile apps, and servers. These messages contain event and user data that you can send to other tools or collect in warehouses for further analysis. Segment also gathers information about your users from external systems, like help desk software or CRMs. You can use this collated information to analyze data, build user audiences, and personalize your users’ experiences.
A workspace is a group of sources that can be administered and billed together. Workspaces help companies manage access for multiple users and data sources. Workspaces let you collaborate with team members, add permissions, and share sources across your whole team using a shared billing account.
When you first log in to your Segment account, you can create a new workspace, or choose to log into an existing workspace if your account is part of an existing organization.
You don’t have to be a developer to be a Workspace administrator for an organization, and this guide only covers tasks specifically related to managing a Workspace in theSegment App.
However, many Workspace admins are also involved in the Segment implementation process as there are usually some tasks that must be performed in the Workspace to complete an implementation. If you think you might develop a Segment implementation or help out other developers, first readSegment for developers.
Note: Workspace roles are only available to Business Tier customers. If you’re on a Free or Team plan, all workspace members are granted workspace administrator access.
In addition, Workspace administrators set up and maintain the organization’sworkspace settings, which include:
Changing a workspace name and slug won’t impact configured sources or destinations, which connect using an internal ID andwriteKey.
Workspace administrators might also maintain:
As an administrator, you might be asked to help other members of your organization with tasks related to setting up and troubleshooting your Segment implementation.
Destinations are the endpoints to which Segment sends data flowing from your Sources. Destinations can be third-party external tools, like Google Analytics or Mixpanel, or bulk-storage resources, like warehouses.
You can set up a Destination from within the Segment App by navigating to theDestination Catalogand selecting the tool you want to set up. In most cases, you’ll need an existing API key or token so that Segment can send the data to the correct account. If you’re setting up a Warehouse or other storage destination, more steps might be required; see theWarehouses documentationfor more details.
Use these Segment features to keep tabs on your Workspace:
Still stumped?Contact supportfor more help troubleshooting.
Have suggestions for this guide?Reach out with your feedback.

Headings:
Segment for Workspace Administrators
What is Segment?
What’s a Workspace?
The Workspace Administrator’s Role
Tasks in Connections
Setting up destinations
Troubleshooting
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/filtering-data/
Paragraphs:
On this page
There are many ways you can use Segment to filter event and object based data to control which destinations it reaches. This document lists the most commonly used ways you can filter data in Segment, and explains when you’d use each.

The Integrations object is the only filtering method that cannot be edited using the Segment web app. As such, it is both the most reliable, and the most complicated filtering option to change. The integrations object is available to all customers regardless of Segment plan.
Use this option when you absolutely, for sure, 100% know that youalways, orneverwant this data in a specific destination or set of destinations. You can also build logic in your app or site to conditionally enable or disable destinations by rewriting this object, however this is not recommended as it is time consuming to change, especially for mobile apps.
The Integrations object filterstrack,page,group,identify, andscreenevents from both client and cloud based sources, and routes or prevents them from getting to the listed destinations.
You can use theintegrationsJSON object as part of your Segment payloads to control how Segment routes your data to specific destinations. An example payload is below:
Bydefault, theintegrationsobject is set to'All': true. You do not need to include this flag in the object to use this behavior, but if you’ll be using the integrations object frequently to control destination filtering, you might want to do this to make it explicit for later readers. Change this to'All': falseto prevent any downstream destinations from receiving data, not including data warehouses. If you set'Segment.io': falsein the integrations object, Analytics.js 2.0 drops the event before it reaches your Source Debugger. You can also add destinations to the object by key, and provide atrueorfalsevalue to allow or disallow data to flow to them on an individual basis. The Destination Info box at the top of each destination page lets you know how to refer to each destination in the Integrations object.
If you are usingmultiple instances of a destination, any settings you set in the integrations object are applied to all instances of the destination. You cannot specify an instance of a destination to apply Integrations object settings to.
Note that destination flags arecase sensitiveand match the destination’s name in the docs (for example, “AdLearn Open Platform”, “awe.sm”, or “MailChimp”).
The syntax to filter data to a data warehouse is different. Refer to theWarehouse FAQsfor more details.
Destination filtersallow you to control the data flowing into each specific destination, by examining event payloads, and conditionally preventing data from being sent to destinations. You can filter out entire events, or just specific fields in the properties, in the traits, or in the context of your events. Destination filters support cloud-based (server-side), actions-based, and mobile and web device-mode destinations.  Destination filters aren’t available for, and don’t prevent data from reaching your warehouse(s) or S3 destinations.
Destination filters are only available in workspaces that are on a Business Tier plan.
Keepthese limitationsin mind when using destination filters.

To set up destination filters from the Segment web app for the destination from which you want to exclude data:
You can set up destination filters using the options presented in the Segment web app, or using Segment’s Filter Query Logic (FQL). If you use FQL, your query syntax is limited to 5KB per query.
Integration filters allow you to quickly change which destinations receive specific Track, Identify, or Group events. Access this tool in any Source that is receiving data by navigating to the Schema tab. Schema integration filters are available to workspaces that are on a Business Tier plan only.
You can apply Integrations filters to specific events regardless of whether the source is connected to a Tracking Plan. To update which destination an event can be sent to, click theIntegrationsdropdown menu to see a list of the destinations each call is sent to. You can turn those destinations on or off from within the dropdown menu.

The events filtered out of individual destinations using this method still arrive in your data warehouse(s). Warehouses do not appear in the integration filters dropdown, and you cannot prevent data from flowing to Warehouses using this feature - to do that useWarehouse Selective Sync.
Integration filters are all-or-nothing for each event.If you require more detailed control over which events are sent to specific destinations, you can use Destination Filters to inspect the event payload, and conditionally drop the data or forward it to the destination.
Integration filters won’t override an existing value in the integrations object.If the integration object already has a value for the integration, the per source schema integration filters will not override this. For example, if you’re sending events to Appsflyer with theappsflyerIdpassed into the integration object:
For the same event you have Appsflyer turned off using the per source schema integrations filter, this filter won’t override the above object with a false value, and events still send downstream. In this scenario, you can usedestination filtersto drop the event before it sends downstream.
You can use Schema Event Filters to discard and permanently remove Page, Screen and Track events from event-based sources, preventing them from reaching any destinations or warehouses, as well as omit identify traits and group properties. Use this if you know that you’ll never want to access this data again. This functionality is similar to filtering with the Integrations object, however it can be changed from within the Segment app without touching any code.
When you enable these filters, Segment stops forwarding the data to all of your Cloud- and device-mode destinations, including warehouses, and your data is no longer stored in Segment’s warehouses for later replay.
Use this when you need to disable an event immediately, but may need more time to remove it from your code, or when you want to temporarily disable an event for testing. In addition to blocking track calls, you can block all page and screen calls, as well as omit identify traits and group properties.
If the Source is not connected to a tracking plan, you’ll find event filter toggles next to the Integration filters in the source’s schema tab. When an event is set to block, the entire event is blocked. This means no destinations receive it, including data warehouses.
When you block an event using Schema filters, it won’t be considered in the MTU count unless blocked event forwarding is enabled.

When an event is blocked, the name of the event or property appears on your Schema page with a counter which shows how many times it has been blocked. By default, data from blocked events and properties is not recoverable. You can always re-enable the event to continue sending it to downstream destinations.
In most cases, blocking an event immediately stops that event from sending to destinations. In rare cases, it can takeup to 6 hoursfor an event to completely stop arriving in all Destinations.
This feature is only available if the Source is not connected to a Tracking Plan, and is only available in workspaces that are on a Business Tier plan.
If you’re using Protocols, and you’re confident that your tracking plan includes exactly the events and properties you want to record, you can tell Segment toblock unplanned events or malformed JSON. When you do this, Segment discards any data coming from the Source that doesn’t conform to the tracking plan.
By default, the blocked events are permanently discarded: they do not flow to Destinations, and cannot be Replayed (similar to Schema Controls). However, you can opt to send data in violation of the tracking plan to a new Segment Source so you can monitor it. (This source can affect your MTU count.)
If you have Protocols in your workspace,andhave a tracking plan associated with the Source, you’ll see additional options in the Schema Configuration section of the Source’s Settings page. From this page you can choose how to handle data violations across different types of calls and properties, whether that be blocking events entirely or omitting violating properties.

A customizable way to filter or alter data going from a source to a cloud-mode destination is to useInsert Functions). This feature gives you the ability to receive data from your Segment source, write custom code to alter or block it, and then pass that altered payload to a downstream cloud-mode destination.
Warehouse Selective Sync allows you to stop sending specific data to specific warehouses. You can use this to stop syncing specific events or properties that aren’t relevant, and could be slowing down your warehouse syncs. See theWarehouse Selective Sync documentationto learn more.
This feature is only available to Business Tier customers, and you must be a Workspace Owner to change Selective Sync settings.
ThePrivacy Portalis available to all Segment customers, because Segment believes that data privacy is a right, and that anyone collecting data should have tools to help ensure their users’ privacy. More enhancements are available to BT customers who may need tools for managing complex implementations.
The Privacy Portal tools allow you to inspect your incoming calls and their payloads, detect potential Personally Identifiable Information (PII) in properties using matchers, classify the information by different categories of risk, and use those categories to determine which Destinations may or may not receive the data. Learn more about these features in thePrivacy Portal documentation

Headings:
Filtering your Segment Data
Filtering with the Integrations Object
Destination filters
Per-Source schema integrations filters
Schema event filters
Protocols Tracking Plan blocking and property omission
Destination Insert Function
Warehouse Selective Sync
Privacy Portal filtering
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/duplicate-data/
Paragraphs:
On this page
Segment guarantees that 99% of your data won’t have duplicates within an approximately 24 hour look-back window. Warehouses and Data Lakes also have their own secondary deduplication process to ensure you store clean data.
Segment has a special deduplication service that sits behind theapi.segment.comendpoint and attempts to drop 99% of duplicate data. Segment stores at least 24 hours’ worth of eventmessageIds, which allows Segment to deduplicate any data that appears with the samemessageIdwithin the stored values.
Segment deduplicates on the event’smessageId,noton the contents of the event payload. Segment doesn’t have a built-in way to deduplicate data for events that don’t generatemessageIds. The message de-duplication is not scoped to a specific source or a workspace, and applies to all events being received by Segment.
Keep in mind that Segment’s libraries all generatemessageIds for each event payload, with the exception of the Segment HTTP API, which assigns each event a uniquemessageIdwhen the message is ingested. You can override these default generated IDs and manually assign amessageIdif necessary. ThemessageIdfield is limited to 100 characters.
Duplicate events that are more than 24 hours apart from one another deduplicate in the Warehouse. Segment deduplicates messages going into a Warehouse (including Profiles Sync data) based on themessageId, which is theidcolumn in a Segment Warehouse.
To ensure clean data in your Data Lake, Segment removes duplicate events at the time your Data Lake ingests data. The Data Lake deduplication process dedupes the data the Data Lake syncs within the last 7 days with Segment deduping the data based on themessageId.

Headings:
Handling Duplicate Data
99% deduplication
Warehouse deduplication
Data Lake deduplication
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/ignore-bots/
Paragraphs:
On this page
If you stumbled onto this page by accident and don’t know what a bot is or are just curious to learn more, the following Wikipedia article provides an awesome summary:https://en.wikipedia.org/wiki/Internet_bot.
Surprisingly, more than half of all web traffic is made up of bots. While a fraction of them are good bots with a regulated pattern, and therefore beneficial to all online businesses, the majority of them have malicious intents and are mostly unregulated.
Segment doesn’t offer an out-of-the-box solution to filter or ignore bot traffic.
As such, you generally have two options:
Handle the filtering at a destination-level:Some of Segment’s destination partners,like Mixpanel, filter bots automatically. Whereas otherssuch as Hubspotallow you to set up bot filtering manually. The advantage of filtering bots at a destination level is that it allows you to implement a robust, easy-to-maintain solution. However, as it pertains to Segment, the downside is that bot traffic willstillmake it to Segment,affecting your MTU count.
Write custom logic that suppresses bot activity from being sent to Segment:if you want to prevent bot traffic from making it to Segment in the first place, another option is to write your own custom code. The logic, in pseudo-code, would look something like this if you know a particular characteristic of the bot traffic to filter out, such as the userAgent:
The benefit here is that you would be able to limit the impact that bots have on your MTU count. On the flip side, it’s much harder to implement and maintain a custom filter.
As a matter of policy, Segment doesn’t provide refunds for bot-related MTU spikes, as bot traffic is out of Segment’s control. However for extenuating circumstances,you can petition for a refund, assuming you’re able to provide proof of the bot’s effect.
Segment uses Amazon’s hosting services, which are based in Boardman, Oregon. Howevermany bots also originate from AWS in Boardman as well.
One way you can confirm whether or not traffic is coming from Segment vs. a bot is to check the userAgent of the inbound call. Segment’s is:

Headings:
Internet Bots
What’s a bot?
Is it possible to ignore bad bots?
If I see a massive MTU spike because of bots, can I apply for a refund?
I’m seeing a lot of browser traffic from Boardman; is that from Segment or a bot?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/segment-vs-tag-managers/
Paragraphs:
Tag managers, also known as Tag Management Systems (TMS), were a popular solution before the mainstream adoption of mobile apps. They primarily helped Digital Analytics and Online Marketers manage web tags or “beacons” on a website.
Built on an older technology, tag managers inject either a piece of JavaScript or an ad pixel into a website. They carry out rules that marketers create for each tag, like firing an ad channel pixel when that network refers a website visitor. Every tag requires users to create rules. No data is stored, and no code is eliminated.
In addition to ad networks, today’s data-driven businesses use a variety of tools to optimize their product and marketing spends. In order to a/b test copy, nurture sales leads, email customers, and provide fast support, businesses integrate variety of analytics and marketing tools. Segment makes it easy to install, try, and use them all. Tag managers primarily focus on ad networks, and can’t support modern tools without extensive customization.
Rather than “firing and forgetting,” Segment takes a data-centric, deliberate approach to destinations. You don’t need to set up special parameters for each tool – Segment does that for you. Segment structures your data so we can understand what it is, and can translate it correctly for each destination we send it to.  Segment works becauseall of these toolsoperate on the same customer data: who is on your app and what are they doing. Segment collects this data once, then translates and sends it to every tool you use. Because Segment also archives the data, Segment canreplay your historical datainto new tools, and send your raw data to adata storage solutionfor later analysis.
Every organization’s data stack and business requirements are unique. Segment also works well in tandem with a tag manager. For example, Segment sends data directly to theGoogle Tag Manager (GTM) destination.
While you can use Segment’s Analytics.js library through a tag manager, Segment doesn’t recommended this for a few reasons:
A hybrid approach makes it difficult to determine the root cause of technical problems, and complicates troubleshooting. Segment cannot guarantee destination compatibility in a “hybrid” Segment-tag-manager installation, and cannot guarantee support on these installations. All QA and regression testing assumes a native installation of Analytics.js on the page.
One of Segment’s main charters is to not lose data. Our system and cloud infrastructure is designed to ensure that data loss does not happen. If you implement the entry point of data capture (Segment’s libraries) using a Tag Manager, you introduce risk of data loss and make it difficult or impossible to troubleshoot.
This implementation behind a tag manager can introduce major delays and performance issues, which can cause delays with events that need to occur early in your funnel.
The biggest challenge is around triggering cascading events. Browsers are notorious for dropping calls. When you use a TMS to initiate Segment events you are introducing a second point of failure for those events
Headings:
Segment vs. Tag Managers
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/what-is-replay/
Paragraphs:
Replay is available to all Business plans.See theavailable plans, orcontact Support.
On this page
Replay takes an archived copy of your Segment data, and re-sends it to new or existing tools providing huge benefits to mature data systems. By archiving and replaying data, you can avoid vendor lock-in, and protect your system against data loss.
With Replays, you can send your existing data to new tools.
This means you can send a limited sample of your data to a new tool to test it out, and run similar tools in parallel to verify the data format or accuracy of the output. Finally, when you’re ready to switch to a new tool, you can replay a full set of your data to the new tool to backfill it with data that extends before you set up the tool - no warm-up time or operational gap to disrupt your work.
Note
Any destinations which accept cloud-mode data (meaning data from Segment, and not directly from users’ devices) can use replay, however they must also process timestamps on the data for replay to be useful.
With Replays, you’re protected from outages and errors. If a destination which you rely on experiences an outage, or is temporarily unable to accept incoming data, you can use Replays to re-send data to that tool once the service recovers. You can also use Replays to recover from errors caused by misconfigurations in your Segment systems. For example, if you send data in the wrong format, or want to applydestination filters. In this case, you can change your mapping using a destination filter, clear out the bad data, and replay it to that destination. You can also use this to update the schema in your data warehouse when it changes.
For more information,Contact usand our Success Engineers will walk you through the process.
Replays are currently only available for Business Tier customers, and due to their complex nature are not self-serve.Contact usto learn more, or to request a replay for your workspace. When requesting a replay, include the workspace, the source to replay from, the destination tool or tools, and the time period.
Replays can process unlimited data, but they’re rate limited to respect limitations in downstream partner tools. If you’re also sending data to the destination being replayed to in real time, then, when determining your replay’s limit, you’ll want to take into account the rate limit being used by real-time events. You should also account for a small margin of your rate limit to allow events to be retried.
Replay time depends both on the tool Segment replays to and the amount of data included in the replay.
Replays do not affect yourMTU count, unless you are using aRepeater destination. Notify your team before initiating a Replay if you’re using a Repeater destination.
Once a replay starts, you will not see replayed events in the Event Delivery tab.
You can initiate replays for some or all events, but you can’t apply conditional filters that exclude certain rows of data from being replayed. You can set updestination filtersto conditionally filter replayed events.
The destination is not required to be enabled in order for a replay to be successful, including Destination Functions.
Replays are available for any destinations which support cloud-mode data (meaning data routed through Segment) and which also process timestamps. Destinations that are only available in device-mode (meaning where data is sent directly from the users’ devices to the destination tool) cannot receive Replays.
Not all destinations support data deduplication, so you may need to delete, archive, or remove any older versions of the data before initiating a replay.contact Segment supportif you have questions or want help.
Replays are subject to theDestination Filtersyou’ve configured on that destination. For example, if you request that Identify calls be included in the replay, but your destination has a Destination Filter that blocks Identify events, the filter then blocks all Identify events from making it to the destination. In this case, Segment recommends that you avoid including Identify events in the replay if you know they’ll be blocked by the destination filter.
When you request a replay, Segment asks you to provide a list of the events (type and/or name) that you want included in the replay. If you specify a list of events, then Segment only includes those specified events in the replay. If you need to exclude events in your replay,contact Segment support. The Segment team can help you handle filtering you’re unable to do in the replay.
There are two types of replays with Engage.
Replay a Profile Source’s data into Engage Space, (sending a standard source’s data into an Engage Space), which can be configured to send over a specified timeframe as well as the ability to specify all or only a specific subset of events by type or name.
Replay from an Engage Space to its connected destination, (sending data from an Engage Output Source to its connected destination), which includes all the computational data (Audiences, Computed Traits, Journeys) that destination is currently configured to receive, which can be configured to send over a specified timeframe as well as the ability to specify all or only a specific subset of events by type or name.
1. Replay a Profile Source’s data into Engage Space
2. Replay from an Engage Space to its connected destination

Headings:
Replay
Replays for tooling changes
Replays for resilience
Replays considerations
Replay-eligible destinations
Replays & Destination Filters
Replays & Engage
Nuances to Consider for Engage Replays
Engage : Replay versus Resync
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/regional-segment/
Paragraphs:
Regional Segment is available to customers on the Business Tier plan.See theavailable plans, orcontact Support.
On this page
On July 10, 2023, the European Commission adopted the Adequacy Decision for the EU-US Data Privacy Framework (DPF). This concludes that EU personal data transferred to the United States under the DPF is adequately protected when compared to the protection in the EU. With this adequacy decision in place, personal data can safely flow from the EU to US companies participating in the DPF without additional safeguards in place.
Twilio is certified under the DPF and relies on the DPF as its primary personal data transfer mechanism for EU-US personal data transfer. Twilio will rely on the DPF for any Swiss-US personal data transfers as soon as a corresponding Swiss adequacy decision is made. Twilio understands that interpretations of data residency are multi-faceted and some customers might still want their data to reside in the EU. Twilio Segment therefore offers a data residency solution outside of the DPF.
Segment offers customers the option to lead on data residency by providing regional infrastructure in both Europe and the United States. The default region for all users is in Oregon, United States. You can configure workspaces to use the EU West Data Processing Region to ingest (for supported sources), process, filter, deduplicate, and archive data through Segment-managed archives hosted in AWS S3 buckets located in Dublin, Ireland. The regional infrastructure has the samerate limits and SLAas the default region.
To ensure a smooth transition from a US-based Segment workspace to an EU workspace, Segment will provide additional support and tooling to help with the transition later this year. Use the form link below to provide more information about your current setup and goals for transitioning.
The Segment UI doesn’t support moving workspaces between regions. To request help with this move,complete the Data Residency Workspace Provisioning Flow form.
Click to access the form
Regional Data Ingestion enables you to send data to Segment from both Device-mode and Cloud-mode sources through regionally hosted API ingest points. The regional infrastructure can fail-over across locations within a region, but never across regions.
The following cloud sources are supported in EU workspaces:
You can configure Segment’s client-side SDKs for JavaScript, iOS, Android, and React Native sources to send data to a regional host after you’ve updated the Data Ingestion Region in that source’s settings. Segment’s EU instance only supports data ingestion from Dublin, Ireland with theevents.eu1.segmentapis.com/endpoint. If you are using the Segment EU endpoint with an Analytics-C# source, you must manually appendv1to the URL. For instance,events.eu1.segmentapis.com/v1.
For workspaces that use the EU West Data Processing region, the Dublin Ingestion region is preselected for all sources.
To set your Data Ingestion Region:
All regions are configured on aper-sourcebasis. You’ll need to configure the region for each source separately if you don’t want to use the default region.
All Segment client-side SDKs read this setting and update themselves automatically to send data to new endpoints when the app reloads. You don’t need to change code when you switch regions.
When you send data from a server-side or project source, you can use thehostconfiguration parameter to send data to the desired region:
If you are using the Segment EU endpoint with an Analytics-C# source, you must manually appendv1to the URL. For instance,events.eu1.segmentapis.com/v1.
Here is an example of how to set the host:
Usethis formif you need to transition from your existing US-based workspace to an EU workspace.
To create a workspace with a different data processing region, reach out your Segment account executive, and they will assist you with enabling the feature. Once the feature has been enabled, you’ll be able to self-serve and create a new workspace in a different data processing region by following these steps:
Once you create a workspace with a specified data processing region, you can’t change the region. You must create a new workspace to change the region.
Regional Segment in the EU changes the way youconfigure the Segment Data Lakes (AWS) environment
Use Segment’s custom CIDR3.251.148.96/29while authorizing Segment to write in to your Redshift or Postgres port.BigQuerydoesn’t require you to allow a custom IP address.
Regional Segment is currently limited to the EU. Future expansion of Regional Segment beyond the EU is under evaluation by Segment Product and R&D.
Edge proxies are deprecated. Customers using Regional Endpoints may see US-based IP addresses in event payloads, Segment recommends using the US-based endpoint (api.segment.io) to preserve client IP addresses. For EU customers, Segment recommends using a Regionalized EU workspace.
Don't see a regional endpoint for a tool you're using?
As more of the partner tools you use (Sources, Destinations, and Warehouses) start to support a regional endpoint, Segment will update this list. Your contact for that tool should have a timeline for when they’re hoping to support regional data ingestion. You can also visit Segment’ssupport pagefor any Segment-related questions.
The following integrations marked with a(checkmark) support EU Regional endpoints.
Integrations available in EU workspaces do not guarantee data residency
Before you configure an integration, you should check directly with the integration partner to determine if they offer EU endpoints.

Don't see regional support for a source you're using?
As more of the partner Sources start to support posting data to our regional endpoint, Segment will update this list. Your contact for that tool should have a timeline for when they’re hoping to support regional data ingestion. You can also visit Segment’ssupport pagefor any Segment-related questions.
The following Sources marked with a(checkmark) are supported in EU workspaces.

Headings:
Regional Segment
Existing Workspaces
Regional Data Ingestion
Cloud-event sources
Client-side sources
Server-side and project sources
Create a new workspace with a different region
EU Storage Updates
Segment Data Lakes (AWS)
Warehouse Public IP Range
Known Limitations
Destination support and Regional endpoint availability
Source Regional support
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/audiences-and-journeys/
Paragraphs:
Engage Foundations requires a Business tier account and includes Unify.See theavailable plans, orcontact Support.
On this page
Audiences, Journeys, and Broadcasts are fundamental toTwilio Engageand let you segment your users, send them personalized content, and show them ads from platforms like Facebook or Google.
In this guide, you’ll learn how to choose between an Audience, a Journey, and a Broadcast for a number of marketing use cases across the customer lifecycle.
First, consider the following definitions for an Audience, Journey, and Broadcast.
In Engage, anAudienceis a group of users that share certain characteristics. When you create an Audience, you group users who meet certain conditions, like having performed an event or having aComputed Trait.
Once you’ve created an Audience, you can sync it tomarketing automation tools,ads platforms,analytics tools, ordata warehouses. Depending on the Audience’s conditions andconnected Destination(s), Segment syncs the Audience’s users in batches or in real time, as they meet the Audience’s conditions.
AJourneyis a logic-driven workflow that progresses users through steps based on conditions and time delays. You add users to a Journey with an entry condition, then users progress throughthe Journey’s stepsbased on conditions you define during Journey setup.
As with Audiences, Segment can sync users to Destinations at designated points in the Journey. Unlike an Audience, a Journey can send users to Twilio Engage’snative email and SMS channels.
ABroadcastis a one-time SMS or email campaign sent to a group of users. Whereas Segment continously updates Audience membership, Segment only calculates the users who will receive your Broadcast once. Marketers commonly use Broadcasts for newsletters, promotional campaign, and events.
The customer lifecycle provides a helpful framework for thinking about Audiences, Journeys, and Broadcasts.

Audiences and Broadcasts tend to be most effective at the top of the customer lifecycle funnel, where brand awareness and discovery occurs.
A Journey becomes a better option as customers progress down the funnel, where a more complex strategy involving messaging, social ads, and newsletters helps move customers closer to conversion.
With the customer lifecycle in mind, use the following table as a starting point for selecting an Audience or Journey for common marketing use cases:
While these suggestions will work for most use cases, you may need to consider other factors before you implement your own campaign. Asking the following questions will help you identify the right approach.
Audiences and Broadcasts work best for single, one-off messages or touchpoints. If you need a campaign with time delays and branching logic, opt for a Journey.
For example, an Audience works well if you want to show a single ad when a user abandons a cart. If, however, you want to show an ad, wait several days, then send the user an email if they’ve not completed their purchase, go with a Journey.
You can message users withEngage Premier Channels. If you’d like to send an SMS or email campaign to a customer, use a Journey.
Create a Journey if you want to incorporate branching logic into your campaign.
A number of Journeys step types, likerandomized splits, let you run experiments and test your campaigns. If you want to experiment with different groups, use a Journey.
With Journeys, you can allow customers tore-enter a Journey they’ve exitedor restrict them to a one-time Journey.
Audiences, on the other hand, admit users whenever they meet the Audience’s criteria. For example, you may want to retarget a user with an ad whenever they view a page on your website. In this case, an Audience works well since the user can re-enter the Audience regardless of how many times they’ve already done so.
With this guidance in mind, take your next steps with Engage by learninghow to build a Journey,work with Engage Audiences, andsend a Broadcast.

Headings:
Audiences, Journeys, and Broadcasts
Back to basics
Audience
Journey
Broadcast
Engage and the customer lifecycle
Choosing between Audiences, Journeys, and Broadcasts
Over the course of a campaign, how many touchpoints do I want to create?
Do I want to use Engage Premier Channels like SMS and email?
Do I need branching logic?
Do I want to conduct an A/B test or create a holdout group?
Do I want my customers to receive the same campaign more than once?
Putting it together
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/
Paragraphs:
On this page
Segment’s How-to Guides provide an in-depth walk through and examples of the many things you can do to implement, automate, engage with, and begin analyzing your data. We’ve also got a series ofQuickstart Guidesfor each of our Source libraries.

Headings:
How to Guides Index
Implementation
Engagement and Automation
Analytics
Quickstart Guides
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/automated-multichannel-reengagement/
Paragraphs:
On this page
Compelling and engaging brands delight their customers at every interaction. As customers move seamlessly across channels—such as email, push notifications, display ads—brands must similarly meet them with tailored and consistent messages.
With Segment, you can craft a tailored message while using a combination of AdRoll, Customer.IO, and other tools to dynamically switch between channels.
Talk to a product specialist todayabout using data to tailor your brand experience.
Retargeting withAdRoll:AdRoll is a retargeting and prospecting tool that allows you to show display ads to a behaviorally-defined cohort
Push notifications withBraze:Braze is a multi-channel marketing campaign focused on the mobile experience
Emails withCustomer.io:Customer.io is a flexible email provider that allows you to create cohorts based on customer actions. You can build complex onboarding emails, nurture email campaigns, as well as marketing automation workflows.
There are other email tools on Segment’s platform, such asBronto,SendGrid,andMailchimp.Check out thefull list of email tools.
It’s important to register for these tools and enable them on your Segment source project. When Segment collects tracking data, it’ll also route it to all of your enabled tools. Then your tools, especially ones like Customer.io, Braze, and AdRoll, where you can define cohorts of your users, will be working off a dynamic, yet consistent data set. This is paramount in getting the dynamic messaging to update accordingly.

When you send tracking data from your app or website to Segment, Segment will send the same data to all of your tools. Segment also collects key messaging events like Push Notification Opened and Email Opened from Braze and Customer.io, respectively, and sends that to other tools. By defining cohorts based on these events, you can create dynamic campaign audiences, to which customers can add and remove themselves.
In each of your destinations—Braze, Facebook, Customer.io, AdRoll—you can create custom campaigns to show display ads or send emails to a specific segment of users who have performed (or not performed) a given action, or “event.” In this cross-channel re-engagement example, we’ll start with push notifications.
In Braze, create a segment of customers who added a product to their cart, but did not check out. The segment definition, in this case, should be people who have performedProduct Added, but have not performedOrder Completed. Send a push notification to these customers with a message that the cart was abandoned and that they can complete the transaction with, for example, a 10% coupon.

Because Segment automatically collects second-party data from Braze, you now also have push notification event data, likePush Notification OpenedandPush Notification Receivedin Segment. You can use thepropertieson each of these events to define a property calledcampaign_nameso you can tie these activities to a given campaign.

This is helpful because now, you can define segments in Customer.io for customers who have triggeredPush Notification Received, but notPush Notification Opened. You’ve now automated the process of targeting customers who don’t open your push notifications. In Customer.io, you can create a campaign that sends an email to those people asking them to check their push notifications and offering them a coupon to complete their order.
Since Segment collects email event data, likeEmail Opened, from Customer.io, you can similarly create segments in Facebook Ads and AdRoll for when customers don’t open your email. Create a segment where users have anEmail Deliveredevent, but noEmail Openedevent. When users meet these criteria, they’ll get automatically added to your retargeting campaigns. You can then serve them custom creatives about them neglecting to open your emails and, again, perhaps offer them a coupon to complete the transaction.

When users do not open an activation email, add them to a specific retargeting campaign that contains messaging to remind them to activate.
With Segment, automate not just switching across channels, but also the messaging in each channel so that the entire experience is cohesive. The added benefit is that we can create specifically targeted retargeting campaigns for people who no longer open our emails or push notifications. Automating these processes with Segment makes channel-switching more seamless for your customers.
This is just a simple cart abandonment example that dynamically follows customers as they switch between channels. Because Segment collects and routes the second party data of emails and push notifications being opened, you can create specific campaigns with messaging that targets your customers as they interact with your brand.
With over 200+ different tools on Segment’s platform, you can take this idea and create other tailored shopping experiences to re-engage your customers.
Talk to a product specialist todayabout using data to tailor your brand experience.
This page was last modified: 06 Oct 2023
Questions? Problems? Need more info? Contact Segment Support for assistance!
Thanks for your feedback!
Can we improve this doc?Send us feedback!
On this page
Was this page helpful?
Thanks for your feedback!
Can we improvethis doc?Send us feedback!
Product
For Developers
Company
Support
© 2025 Segment.io, Inc.

Headings:
Automating Multi-Channel Re-Engagement Campaigns
Tools used
Set it up
1st line of defense: the push notification
2nd line of defense: the email reminder
3rd line of defense: paid advertising
Create an engaging and consistent brand experience
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/collect-on-client-or-server/
Paragraphs:
One of the most common questions Segment receives is: “Should I use one of your client-side libraries or one of your server-side libraries?”
This is such an important topic that you’ll find an in-depth article in Segment’s Analytics Academy:When to Track on the Client vs Server. It’s worth a read. Below, you can also read some quick logic around why you may want to choose either option.
Good things to send from the client-side are things that you wouldn’t usually store in your database. Things like page views, button clicks, page scroll length, mouse movements, social shares, and likes.
Things like UTM tags, operating system, device type, or cookied data like returning visitors are all easiest to track client-side. Of course, some things like mouse movements are only available on the client-side so you should definitely track that there.
Some destinations can only accept data when the event is sent from the browser. They require events on the client since they rely on cookies and most of those tools do not have an API that Segment can send server-side data to. More on this in Segment’sAnalytics.js docs.
Charging customers often happens when they aren’t online, and accuracy for payments is so important. Server-side tracking tends to be more accurate than user devices since it’s a more controlled environment.
In general client-side data is fine for watching general trending, but it’s never going to be perfect. Especially if your customers are likely to use things like adblock or old/non-standard browsers.
For example, if you’re sending triggered emails based on events, it’s probably a good idea to make sure your user profiles are sent through Segment’s servers so no one gets left out or mis-emailed.
Another good type of data to send server-side are things that need to be calculated from a database query. This might be something like “Friend Count” if your site or app is a social network.
Sensitive information is also best kept out of browsers. Any data you don’t want exposed to users should be sent server-side.
Each Segment library allows anintegrationsobject either as a top level object or nested in options object.
This flag may be especially useful in Legacy source types, where an event might be triggered on both the client and server for various reasons. The following will cause the payload to be sent to all enabled toolsexceptFacebook Pixel:

Headings:
Collecting Data on the Client or Server
Client-side
Not stored in your database
Easier to send client-side
Events needed for client-side only destinations
Server-side
Payment events
Accuracy
Calculated from your database
Sensitive information
Selecting Destinations
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/collect-pageviews-serverside/
Paragraphs:
Segment believes that client-side collection is appropriate for collection of basic pageviews.
If you’d like to trackpagecalls from your server to Segment, Segment recommends doing it in addition to any client side tracking you’re doing with analytics.js, and doing it in a separate “source” so that you can configure where to send the (probably redundant, albeit higher-fidelity) data.
With this approach, you might use a request “middleware” to log apageviewwith every page load from your server.
There are a few things to be mindful of if you want to make sure you can attribute these (anonymous) page views to the appropriate user in your client-side source (eg, for effectively joining these tables together to do down-funnel behavioral attribution). You’ll want to ensure they share ananonymousIdby respecting one if it’s already there, and setting it yourself if not. To do that, you can read and modify theajs_anonymous_idcookie value in the request.
Be sure to pass through as many fields as you can in Segment’sPageandCommonspec, so that you get full functionality in any downstream tools you choose to enable. Segment recommends specifically ensuring you pass theurl, path, host, title, search, and referrerin the messagepropertiesandip and user-agentin the 

Headings:
Collecting Pageviews on the Server Side
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/create-push-notification/
Paragraphs:
Like emails, push notifications are an extremely powerful way to re-engage customers on mobile apps. Push notifications are personal, so targeting them precisely using customer behavioral data (from Segment) is crucial.
For example,Waneloaccepts direct product feeds from retailers. For any of these retailers, when a product goes on sale, they can send a push notification to the people who have saved that product in their profile.
Push messaging focuses around three key features:
Content: Diversify your messaging just as you would with an investment portfolio. you want to target your consumers with right content and avoid opt out for push. For example, Netflix uses push notifications to let users know when their favorite shows are available. Rather than sending every user a notification every time any new show or season is released.
Frequency: Consider your App Store Category. News/Sports apps send push notifications daily or multiple times a day if it’s “game day”. So do Social Networking/Messaging apps. However, apps that are utilitarian, for example, food and drink, health and fitness, or productivity only message when necessary.
Timing: Always send push notifications to users in their local timezone. In general, mobile usage peaks between 6pm - 10pm.
Self evaluate when trying to choose a destination that suits your needs.
You will find many alternatives, but choosing the right one for your app is important!
Ask users to opt in to push notifications upon app install or after the first time they use an app, so it’s easier to be transparent about how users can opt out later.
Let your customers decide what notifications they want to receive. It may help to break up your notifications into categories so you can empower your customers with this decision.
Creating lists of your app users based on characteristics or events that align to specific campaigns will help you better target your mobile marketing efforts.
Make sure to use deep linking to guide users to the specific screen relevant to that offer.
Pay attention to user time zones and customize messages based on time of year (holidays) to make brand personable.
The ideal frequency depends on the type of app you have.
Test different action words, phrases, message lengths, and more.
To “auto-enroll” new users into existing campaigns.
Don’t silo the success of your campaign to just app opens.
Headings:
Creating a Push Notification
Choose a destination
Key metrics for a successful push
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/cross-channel-tracking/
Paragraphs:
On this page
The paths consumers take to your app or website are more complex than ever, often involving a variety of online communities and multiple devices. Your next repeat customer might stumble across your display ad on a newsletter you’ve never heard about, or receive a recommendation from a co-worker in a Slack channel.
But these off-domain and cross-device brand interactions are equally, if not more, important to track and understand. With this data, you can identify more sources of qualified traffic and determine the best shopping experiences for conversion.
In this guide, you’ll learn where and how to track these critical events so that you can understand your customer’s journey before they even get to your storefront, as well as their preferred shopping experiences.
If you’re interested in learning about what to track,check out Segment’s guide on creating an e-commerce tracking plan.
Talk to a product specialist todayabout building a clean, high-quality data spec so you can focus on brand engagement and sales growth.
Digital marketing consists of owned marketing, earned marketing, and paid marketing.
Ownedmarketing encompasses all activities you have full control over. It can be further split into first- and second-party data. First-party data is customer data generated on your site or in your app. Second-party data is customer data generated when your customers interact with your email or push notifications (for example, “Email Opened” or “Push Notification Received”).
Earnedmarketing is when publications, newsletters, or blogs organically create some content that refers to, or promotes you.
Paid acquisition, like display ads or embedded advertorials, don’t exist on your domain. To track the inbound traffic from both “earned” and paid acquisition sources, Segment uses UTM parameters (and deep links if you’re directing a customer to a specific screen in your mobile app that has the product to purchase).
Track engagement on your email channels
While these are still under “owned” marketing, they happen off your domain. An example is sending an engagement email to your customer base with a call-to-action to visit your store. If you’re using Segment and an email or push notification tool on Segment’s platform, you can easily collect second-party data such as “Email Sent” and “Push Notification Opened”.
Learn more about whichemailandpush notification toolsSegment supports.
Here are some of the most commonly used and popular events tracked through email and push notifications on Segment:
Email Delivered
Email Opened
Push Notification Received
Push Notification Opened
Deep Link Clicked
If your email tool is not supported on Segment, you can still track email opens with Segment’s tracking pixel. This pixel functions like an advertising pixel in that it embeds an image onto pages where JavaScript and POST requests are disabled.
View a list of tools Segment supports.
In your email template HTML, include an image tag where thesrcis a URL that is carefully constructed to hit Segment’s appropriate endpoint with a JSON payload that is base64 encoded.
An example of the payload that will be sent to Segment upon an email open is:
Then, you would base64 encode that and append it to the Segment endpoint:
Add the complete URL as thesrcin the image tag.
Learn more about Segment’s Pixel API.
Track earned traffic with UTM Parameters
UTM parameters are types of query strings added to the end of a URL. When clicked, they let the domain owners track where incoming traffic is coming from and understand what aspects of their marketing campaigns are driving traffic.

UTM parameters are only used when linking to your site from outside of your domain. When a visitor arrives to your site using a link containing UTM parameters, Segment’s client-side analytics.js library will automatically parse the URL’s query strings, and store them within thecontextobject as outlined in theSpec: Commondocs. These parameters do not persist to subsequent calls unless you pass them explicitly.
UTM parameters contain three essential components:
utm_campaign: This is the name of your campaign. All marketing activities that support this campaign, needs to have the same utm_campaign so that downstream analysis to measure performance for this specific campaign can be done off this primary key. (Example: “national-toastday”)
utm_medium: How the traffic is coming to your site. Is it through email, a display ad, or an online forum? This ensures Segment’s downstream analysis can easily see which channel performs the best. (Examples: “email”, “paid-display”, “paid-social”, “organic-social”)
utm_source: Where the traffic is specifically coming from. You can be specific here. This ensures Segment’s downstream analysis can measure which specific source brings the most conversions. (Examples: “twitter”, “customer.io” (email tool), “facebook”, “adroll”)
With these being optional:
utm_content: For multiple calls to action on a single page, utm_content indicates which one. For example, on a website, there may be three different display ads. While the link on each display ad will have the same utm_campaign, utm_medium, and utm_source, the utm_content will be different. (Examples: “banner”, “left-side”, “bottom-side”)
utm_term: This is the parameter suggested for paid search to identify keywords for your ad. If you’re using Google Adwords and have enabled “autotagging”, then you don’t need to worry about this. Otherwise, you can manually pass the keywords from your search terms through this parameter so that you can see which keywords convert the most. Note that this parameter is reserved explicitly for search. (Examples: “toast”, “butter”, “jam”)
If you’d like UTM parameters to persist in subsequent calls, you’ll need to manually add those fields in thecontext.campaignobject of your event call. For example:
You can also store the values in cookies and/or localStorage and useAnalytics.js Middlewareto enrich the payload for subsequent calls.
Learn more about the semantics with each UTM parameter.The key isn’t to stick with the definitions that closely, but to be consistent within your own analytics system.
Proper UTMs use
A marketing campaign is a single marketing message across several platforms, media, and channels, with a consistent and clear call-to-action.
Since the marketing campaign is from off-domain to your storefront (on your property or domain), then it’s critical to use the proper and consistent UTM params across all of your channels:
Emails
Paid acquisition
Guest blog post in partner’s newsletter
Article in the news
Offline events / in real life / meat space
Your UTM parameters would match a pattern such as:
Having the same utm_campaign across all channels
Different utm_source and utm_medium depending on the channel
If you were on paid acquisition, the placement of the display ad would determine what goes in utm_content
If you were using paid search, the term would be utm_term
An example would be a National Toast Day campaign. This campaign would include emails, paid acquisition (with AdRoll and Facebook Ads), organic social (Twitter), and promotional content on partners’ blogs.
Having the consistent UTM parameters naming convention simplifies the downstream analysis and the ease of querying across dimensions, such as within the campaign, which medium or source was the best. Or which placement of the display ad led to the most conversions.
Learn more about measuring ROI of marketing campaigns with SQL and UTM parameters.
It’s common for customers to discover you on their desktop before making the purchase much later on their phone. How do you tie all of these events back to the same customer so you can understand which marketing activities on what screens are responsible for conversions?
Track server-side when possible
Tracking with JavaScript in the browser has its benefits, such as using browser technologies to automatically track things like UTM parameters, referring domain, IP address, and user agent. But here are a few reasons why it might make sense for your store to track on the server side.
Are your customers technically savvy and use ad blockers? Ad blockers restrict requests from a list of blocklisted domains to your browser, which means that none of your event tracking will work properly. If you sell to a technical audience, it is possible that you may be underreporting your analytics by a material amount.
Do you have multiple devices? If you have multiple devices with the same customer check out flow, moving those events to the server-side will reduce your surface area of your code base. This means less maintenance and faster changes.
Learn more about client vs server tracking.
If you do move key checkout events to the server side, you will have to manually send the data automatically collected by Segment’s client-side JavaScript library to your server. These pieces of tracking data are still important for the following reasons:
UTM parameters: Collecting the UTM params will allow you to tie conversion events to your marketing campaign or activities. This is valuable in that you can immediately measure performance and calculate ROI on your campaigns.
IP address: The IP address can provide location intelligence for your customers. This means you can personalize your shopping experience or engagement emails with inventory that might be more relevant depending on your customers’ locations.
User Agent: The User Agent will inform you of your customers’ preferred device and shopping experience. Are they converting on a mobile web browser? Native app? Or on their laptop?
Learn how to usecontextto manually send this information on the server side.
Track the same user across devices
If your store allows user registration and users are logged in when they shop on your site or app, then you can track them across devices.
This works by using auserIdinstead of ananonymousIdto track key events and where they occur. ThisuserIdserves as the primary key in your downstream tools and data warehouse, allowing you to join all of a profile’s anonymous activities with logged in activities. You also can get a complete picture of a profiles location, and what device they are on while using your app or website.
Learn more about pulling the entire user journey for a single user given a userId.
Unfortunately, tracking the same user across devices only works if they log in to each device. Anonymous browsing in each distinct “experience” (for example, mobile safari, native iPhone, browser on laptop) generates its own uniqueanonymousId. EachanonymousIdis limited to the scope of that browser or app, only measuring activities in those sessions. It’s not until the user logs in when theuserIdis generated (if registering for a new account) or theuserIdis retrieved from your database, and then mapped to theanonymousIdof that session. Segment keeps a table ofanonymousIds mapped to a singleuserIdso you can analyze a user’s activity across multiple devices.
If a user logs in on multiple devices, then you would be able to analyze even the anonymous activity across those devices. Consequently, it’s important to encourage your users to log in so that you have this capability.
One of the biggest challenges for brick-and-mortar stores is to measure the impact of their online advertising campaigns on their in-store purchases. Attributing offline conversions has traditionally been difficult to achieve, due to the lack of offline data and robust infrastructure to route that data.
For Facebook advertisers,Facebook Offline Conversionsallow you to tie offline conversions to your campaigns. It’s important to note that the offline data is labeled to an event set that has been assigned to a Facebook campaign. Here are the two ways to attribute offline conversions to Facebook advertisements:
Uploading offline event data about actions that aren’t captured with Facebook Pixel or App Events to Facebook for them to match actions to your Facebook ads
Enable and configureSegment’s Facebook Offline Conversions destination, which automates attributing offline events to your Facebook ads in real-time
Learn more about the benefits of Segment’s Facebook Offline Conversions destination.
Most other advertising networks provide some functionality of manually uploading offline data to match with their online advertising data. Here is a short list of other services:
Attributing in-store purchases to an impression from a display ad online is critical to help marketers and advertisers understand which campaigns or creatives are driving sales. The more real-time the data and insights, the more nimble your business can be in altering course so that additional resources can be put towards the right marketing actions.
The internet has made it easy for customers to come from nearly anywhere to your digital storefront. But there are ways to track and collect data to better understand these complicated paths so you can be intentional with your marketing efforts to tap into these communities.
By tracking in these locations with the above mentioned techniques, your downstream analysis will also be simpler. With UTM params, you’ll be able to quickly measure the performance of a campaign or a particular channel. By properly tracking on multiple devices, you can understand which shopping experiences are most preferred. These tracking techniques are invaluable to understanding the source of your highest quality customers.
Talk to a product specialist todayabout building a clean, high-quality data spec so you can focus on brand engagement and sales growth.

Headings:
Tracking Customers Across Channels and Devices
Where are they coming from? Off-domain tracking
What device are they using? Cross-device tracking
Attribute offline conversions to online impressions
Learn about the funnel before your website or app
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/dynamic-coupon-program/
Paragraphs:
On this page
One component of building a successful and engaging e-commerce brand is rewarding your most loyal customers. With Segment Warehouses and SQL, you can retrieve a table of your most valuable customers, then reward them.
This guide will walk you through setting up a dynamic and automated coupon program based on conditions that define your most valuable customers, as well as how to measure the program’s performance.
Talk to a product specialist todayabout using data to tailor your brand experience.
Emails withCustomer.io: Customer.io is a flexible email provider that allows you to create cohorts based on customer actions. You can build complex onboarding emails, nurture email campaigns, as well as marketing automation workflows.
Retention Analytics withAmplitude: Amplitude is an analytics tool that focuses on understanding retention and funnel analysis.
It’s important to register for these tools and enable them on your Segment source project. When Segment collects tracking data, it routes it to all of your enabled tools, meaning that they get a single consistent data set. Most importantly, the data generated by users interacting with emails is sent through Segment so you can analyze email performance, and how it impacts conversion with Amplitude.
Not using Customer.io or Amplitude?Check out the other Segment SupportedEmail MarketingandAnalytics tools.
Say, as the marketing manager of our fictitious, on-demand artisanal toast company, Toastmates, you want to experiment with a coupon program to retain your best customers.
Through a combination of SQL and statistical analysis on a set of historical data, you’ve identified the conditions for our most valuable customers as:
Learn how to define these conditions inHow to Forecast LTV for e-commerce with Excel and SQL.
Will rewarding a $5 coupon to this cohort after they make the second purchase a month lead to higher engagement and LTV? Set up this program using Customer.io as the email provider and measure it’s performance on engagement and LTV with Amplitude.
Conduct a split test (half of the cohort will represent the control group and will not receive any emails; the other half will receive an email with the $5 coupon) for one month. After which, use Amplitude to see if there were any correlations between the coupon email and conversions.
First, register for an account with Customer.io and Amplitude. Then, enable Customer.io and enable Amplitude on your Segment project. Finally, go into your Customer.io account and enable “sending data to Segment”:

You can find those destination settings in Customer.io here.
When everything is enabled, customer event data such asOrder CompletedandProduct Added, as well as their properties, will all be sent to your configured destinations, including Customer.io and Amplitude. Then you can define cohorts based on these events in Customer.io to add to email campaigns or conduct funnel analytics in Amplitude.
Talk to a product specialist to learn what else you can accomplish with these tools.
Now define the specific cohort in Customer.io as per our conditions listed earlier: someone who spends over $20 per order and shops over twice a month. In Customer.io, go to “Segments” and “Create Segment”:

After this cohort is created, then when a customer makes the third purchase in a month and it’s over $20, they will be added to this segment.
Next, create a “segment trigger campaign”, where Customer.io will send a message the first time someone enters a segment. The segment in this case will be the one you just created: Coupon Loyalty Experiment.

Save the changes and enable the campaign. Then, make sure that your e-commerce backend is set up properly to handle the coupons. If it’s available in your system, create a coupon that only works for a specific set of customers.
After a month has passed for the split test, you can measure the performance of the email coupon program to see whether it’s making a material impact on conversions.
In Amplitude, create a funnel that compares the two cohorts—one who received this coupon email vs. the control group who did not—and see its impact on conversions and revenue generated.
First, define a behavioral cohort with the conditions of being loyal customers so you can use it when analyzing the conversion funnel:

You’ll also have to create a second identical cohort, except with the only difference that these customers did not receive the coupon email. You need this cohort to create the conversion funnel with the control group.

After you’ve created these two cohorts, create two funnel charts. The first funnel will look at the control group. The second funnel will look at the group that received the coupon email.

Resulting in:

The control group that did not receive the email for the coupon resulted in 233 people visiting the store, with 66 conversions.
The funnel for the group who did receive the emails can be created with these parameters:

Resulting in:

The email itself drove 168 customers to the store, which also saw higher conversions toProduct Addedand ultimatelyOrder Completed.
Note that this funnel is only looking customers who went through these events in this specific order. This analysis doesn’t consider customers who are part of the emailed cohort, yet didn’t open the email, but still visited the site and/or made a purchase.
At first glance, it appears that the group that was emailed did receive an absolute number of more conversions. However, these funnels are still inconclusive, given that you haven’t explored the impact on the top line revenue, as well as overall engagement with the brand. Fortunately, you can continue to use Amplitude to analyze impact on revenue itself.
Retaining and rewarding your customers is paramount to a strong and engaging brand. This example is just one of millions that you can employ to find new ways to delight and excite your customer base.
Other ideas can be to send messages to your customers with a referral code to invite their friends. Or set up a coupon for customers who are just shy of entering your most valuable customers cohort. Or, if you’re hosting a pop up shop event, sending a special and personalized invite to your strongest users first, as a way to thank them for their business.
The possibilities are endless when you use your customer data to drive sales.
Talk to a product specialist todayabout using data to tailor your brand experience.

Headings:
Setting Up a Dynamic Coupon Program to Reward Loyal Customers
Tools used
The Loyalty Program
Set it up
Define the cohort in Customer.io
Measure performance
Find new ways and channels to retain your most valuable customers
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/forecast-with-sql/
Paragraphs:
On this page
Customer Lifetime Value (“LTV”) is the amount of money that an individual customer will spend with a given business in the future. It’s often used to value cohorts in your customer base, determine how much to spend in acquiring or retaining new users in a given cohort, rank customers, and measure the success of marketing activities from a baseline LTV forecast.
The LTV calculation is not straightforward for e-commerce businesses, since future payments are not contractual: at any moment, a customer may never make a single purchase again. Additionally, forecasting future purchases requires statistical modeling that many current LTV formulas lack.
This guide shows how to calculate forward-looking LTV for non-contractual businesses using SQL and Excel. This analytical approach allows you to accurately rank your highest value customers, as well as predict their future purchase sizes to help focus your marketing efforts.
This guide assumes you’re using the tracking schema described inHow to implement an e-commerce tracking planand are storing data in aSegment Warehouse.
Talk to a product specialistto learn how companies like Warby Parker and Crate & Barrel use a data warehouse to increase engagement and sales.
In a non-contractual setting, you can’t use a simple retention rate to determine when customers terminate their relationship. This is because the retention rate is a linear model that doesn’t accurately predict whether a customer has ended her relationship with the company or is merely in the midst of a long hiatus between transactions.
The most accurate non-contractual LTV model, named “Buy Til You Die” (“BTYD”), focuses on calculating the discounted estimation of future purchases based on recency of last purchase, frequency of purchases, and average purchase value. This model uses non-linear modeling to predict whether or not a user is “alive” or “dead” given historic transactions to forecast future probability and size of purchases.
Since LTV is a critical metric for e-commerce companies, it’s important that this model, instead of simpler linear formula that is based on retention rates, is used for it’s calculation.
Use SQL to build the necessary table, which will be exported as a CSV and opened in Google Sheets. Then, use Solver to estimate the predictive model parameters, which ultimately calculates the future purchases of each customer. Finally, the LTV calculation is simply the net present value of each customer’s future purchases. Rank them by LTV, then find behavioral patterns across the top 10 or 50 customers to figure out how best to target or retain this cohort.
Recency, frequency, and average size
As a growth analyst at the fictitious on-demand artisanal toast company, Toastmates, it’s important to know which customers are worth more to the business than others. Most important, you should understand what similarities these customers all have to help guide the marketing team in their efforts.
The first step in creating the BTYD model is to get historic purchasing data of at least a month. In your analysis, you can use data from the past six months. The data must include the columnsuserId(email is fine too), number of purchases within the specified time window, days since last purchase, and days since first purchase.
Then, usethis Google Sheet, which provides all of the complex calculations for estimating the model parameters, as well as forecasting the future sales of each customer. This sheet is View Only, so be sure to copy it entirely so you can use it.
To retrieve a table with the right columns for analysis, use the follow SQL query:
This returns a table where each row is a unique user and the columns are email, number of purchases within the time window, number of discrete time units since last purchase, and average purchase order.

Here is a screenshot of the first twelve rows returned from the query in Mode Analytics.
Export this data to a CSV, then copy and paste it in the first sheet of the Google Sheet where the blue type is in the below screenshot:

Also be sure to add the total time in days in cell B6. This is important as the second sheet uses this time duration for calculating net present value of future payments.
After you paste in the CSV from the table into the first tab of the sheet, the next step is to estimate the model parameters (the variables on the top left of the sheet). In order to do this, we need to use a feature of Microsoft Excel called Solver.
You can export your Google Sheet as an Excel document. Then, use Excel Solver to minimize the log-likelihood number in cell B5, while keeping the parameters from B1:B4 greater than 0.0001.

After Solver runs, cells B1:B4 will be updated to represent the model’s estimates. Now, you can hard code those back into the sheet on Google Sheets. The next sheet relies on these model estimates to calculate the expected purchases per customer.
The model requires four pieces of information about each customer’s past purchasing history: her “recency” (how many “time units” her last transaction occurred), “frequency” (how many transactions she made over the specified time period), the length of time over which we have observed her purchasing behavior, and the average transaction size.
In the example, you have the purchasing behavior data over the course of six months with each unit of time being a single day.
You can apply a both a beta-geometric and a negative binomial distribution (“BG/NBD”) to these inputs and then use Excel to estimate the model parameters (an alternative would be the Pareto/NBD model). These probability distributions are used because they accurately reflect the underlying assumptions of the aggregation of realistic individual buying behavior. (Learn more about these models).
After estimating the model parameters, you can predict a particular customer’s conditional expected transactions by applying the same historic purchasing data to Bayes’ Theorem, which describes the probability of an event based on prior knowledge of conditions related to the event.
Estimating the model parameters
The top left part of the first sheet represent the parameters of the BG/NBD model that must be fitted to the historic data you paste in. These four parameters (r, alpha, a, and b) will have “starting values” of 1.0, since you’ll use Excel Solver to determine their actual values.
The values in columns F to J represent variables in the BG/NBD model. Column F, in particular, defines a single customer’s contribution to a the overarching function, on which we’ll use Solver to determine the parameters. In statistics, this function is called the likelihood function, which is a function of the parameters of a statistical model.
In this particular case, this function is the log-likelihood function, which is B5, as calculated as the sum of all cells in column F. Logarithmic functions are easier to work with, since they achieve its maximum value at the same points as the function itself. With Solver, find the maximum value of B5 given the parameters in B1:B4.
With the new parameter estimates, you can now predict a customer’s future purchases.
Predicting a customer’s future purchases
In the next sheet, you can apply Bayes’ Theorem to the historic purchasing information to forecast the quantity of transactions in the next period. Multiply the expected quantity with the average transaction size to calculate the expected revenue for that period, which you can extrapolate as an annuity, of which you can find the present discounted value (assuming discount rate is 10%).
Central to the Bayes’ Theorem formula is the Gaussian hypergeometric function, which is defined by “2F1” in column M. Evaluate the hypergeometric function as if it were a truncated series: by adding terms to the series until each term is small enough that it becomes trivial. In the spreadsheet, we sum the series to it’s 50th term.
The rest of the variables in Bayes’ Theorem is in columns I through L, which use the inputs from the customer’s historic purchasing information, as well as the model parameter estimates as determined from Solver (cells B1:B4).
The expected quantity of purchases in the next time period is calculated in column H.
Finally, multiply that with the average transaction size and you can get the expected revenue for the next time period.
This exercise allows you to rank your customers from most valuable to least by ordering column F in descending order. You can take theuserIds of the top several customers and look across their shopping experiences to identify any patterns that they share, to understand what behaviors are leading indicators to becoming high value customers.
Below is a simple query to get a table of a user’s actions in rows. Just replace theuser_idwith the user in question.
This above query for user whoseuser_idis"46X8VF96G6"returns the below table:

At Toastmates, most of the highest forward-looking expected LTV customers share one thing in common: averaging two orders per month with an average purchase size of $20.
With that in mind, you can define a behavioral cohort in our email tool, Customer.io, as well as create a trigger workflow so we can send an email offer to these customers.
Learn how to use email tools to target this cohort of high value customers.
This exercise is useful not only as a forward looking forecasting model for customer LTV, but also as a quality ranking system to see which customers are worth more to your business. Coupled with the ability to glance across the entire shopping experience of a given customer, you can identify broad patterns or specific actions that may be an early signal for a high value shopper. Recognizing these high value shoppers means being proactive in nurturing, rewarding, and retaining them.
And this is just the beginning. Having a rich set of raw customer data allows you to create accurate projection models for LTV so you know not only how much you can spend to acquire them, but also how to rank your customers by value. Ultimately, these insights lead to the right actions that can build an engaging shopping experience and drive sales.
Talk to a product specialistto learn how companies like Warby Parker and Crate & Barrel use a data warehouse to increase engagement and sales.
Headings:
Forecasting LTV with SQL and Excel for E-Commerce
Calculating LTV: Buy ‘Til You Die
How to use the Google Spreadsheet
Model and predict future customer purchases
Rank your customers
Reward your best customers
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/import-historical-data/
Paragraphs:
On this page
When transitioning over to Segment, customers commonly want to import historical data into tools they are migrating to or evaluating.
Note:Historical imports can only be done into destinations that can accept historical timestamped data. Most analytics tools like Mixpanel, Amplitude, or Kissmetrics can handle that type of data just fine. One common destination that doesn’t accept historical data is Google Analytics, since their API cannot accept historical data.
Use anyserver-side library, which sends requests in batches to improve performance. Once you have data to import, follow the steps below:
Export or collect the data to be imported.
Include timestamp data in your export if the data needs to appear in end tools in a historical reference. For instance, if you’re importing emails and it’s relevant to know when someone joined your email list, you may need to export the timestamp.If no timestamp is specified when importing, the data will show a timestamp from the time the data was received.
Decide which destinations need to receive the data.
By default, data coming into Segment will be forwarded to all destinations connected to a given source.To limit data to specific destinations, theintegrationsobject must be modified. With historical data, you often only want to send the data to a specific destination or into your data warehouse. For example, inNode.jsset theintegrationsobject as follows.
Once you’ve done that, you’ll need to write an application or worker to send the data to Segment.
You will need to cycle through each set of data and map it to a Segment server-side library method or build an array matching theHTTP Import API format.
Tip: Segment recommends using a Segment library for this process, as they set contextual message fields likemessage_id(used for deduping) andsent_at(used for correctly client clock skew) that Segment’s API uses to correct behavior upon ingestion.
Tip: The server-side libraries will automatically batch requests to optimize for performance and prevent linear request volume. This batching behavior is modifiable, and some of the underlying libraries implement a configurable max queue size that may discard messages if you enqueue requests much faster than the client can flush them. We recommend overriding the max queue size parameter for the library to a high value you’re comfortable you can remain under in your batch job.
The following projects are open-source and do not have official Segment support. If you encounter issues, the best way to get help is by opening an issue on the project’s GitHub page. 
Feel free to clone the repository and adjust the code to suit your unique needs.
One of Segment’s Success Engineers wrote an alpha prototype Node.js app for importing data utilizing the HTTP API, which we’ve included below:
Example Node.js import application
Additionally, one of Segment’s Software Engineers developed a React App with more out of the box functionality for importing events. The features include a modern UI, transformations, and event format checking prior to import:
Desktop React CSV uploader
MarketLyticshas documented their experience using the alpha prototype importer and offer somehelpful visuals and tips.
If a server-side library doesn’t meet your needs, you can use the Segmentbulk import HTTP APIdirectly.
Note:When you use the HTTP API to export historical data to upload to Segment, remove all the originalsent_at,message_id, andproject_idfields from the archived message before forwarding them back to Segment.
Please refer to theReverse ETL guidefor more details.


Headings:
Importing Historical Data
Method 1: Using a Custom Solution
General Instructions
Demo projects
Alternative solution
Method 2: Using Reverse ETL
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/join-user-profiles/
Paragraphs:
On this page
One of the first questions we get when our customers start querying all of their data is, how do I join all this data together? For example, let’s say you’d like to know if support interactions in Zendesk increase revenue in Stripe, or which percentage of users opened your email campaign and visited your website or mobile app? The key to answering these advanced questions is tying your data together across these sources. To do that, you need a common user identifier.
Each SaaS tool you use has its own way of identifying users with a unique primary key. And, you will find each of these different IDs across different collections of tables in your database. So, when you want to start matching Joe Smith who entered a ticket in Zendesk and also clicked through a campaign in Mailchimp, it starts to get tricky.

For example, Stripe keeps track of users with acustomer_id, Segment requires auser_id, and Marketo usesemailto uniquely identify each person.
To effectively join across these sources, you need to understand how each id maps to each other. The best way to do this is to create a common identifier across tools.
When you install a new tool (or useSegmentto install all of them at once), you need to choose what you will put in the ID field. There are lots of different options for this: emails, twitter handles, usernames, and more.
However, we suggest using the same ID you generate from your production database when you create a new user. Database IDs never change, so they are more reliable than emails and usernames that users can switch at their leisure. If you use this same database ID across as many tools as possible, it will be easier to join identities down the road. (In MongoDB, it would look something like this507f191e810c19729de860ea.)
Though we wish you could use a database ID for everything, some tools force you to identify users with an email. Therefore, you should make sure to send email along to all of your other tools, so you can join on that trait as a fallback.
Integrating as many tools as possible through Segment will make your joins down the road a little easier. When you use Segment toidentifyusers, we’ll send the same ID and traits out to all the destinations you turn on in our interface. (More aboutSegment destinations.
A few of our destination partners accept an external ID, where they will insert the same Segment user ID. Then you can join tables in one swoop. For example, Zendesk saves the Segment User ID asexternal_id, making a Segment-Zendesk join look like this:
Here’s a look at the Segment destinations that store the Segment User ID:
Whether you’re using Segment or not, we suggest creating a master user identities table that maps IDs for each of your sources.
This table will cut down on the number of joins you have to do because some IDs may only exist in one out of many tables related to a source.
Here’s sample query to create a master user identities table:
You’ll spit out a user table that looks something like this:
While creating this table in SQL is a good strategy, we’d be remiss not to point out a few drawbacks to this approach. First, you need to run this nightly or at some regular interval. And, if you have a large user base, it might take a while to run. That said, it’s probably still worth it.
How to run a query with your joined data
So what can you do once you have all of your ID’s mapped? Answer some pretty nifty questions that is. Here are just a few SQL examples addressing questions that incorporate more than one source of customer data.
Segment + Zendesk
Stripe + Zendesk
An alternative to the lookup user table in SQL would be writing a script to grab user IDs across your third-party tools and dump them into your database.
You’d have to ping the APIs of each tool with something like an email, and ask them to return the key or id for the corresponding user in their tool.
A sample script, to run on a nightly cron job, would look something like this:
Here is the documentation for Zendesk’s API for more information.

Headings:
Joining User Profiles
What is the user ID problem?
Use a common identifier when possible
For Segment Destination Users
How to merge identities
Advanced Tips
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/measure-advertising-funnel/
Paragraphs:
On this page
It’s surprisingly hard to answer questions about the ROI of your ad campaigns. What does a click actually result in? How much should I pay for it? We built our Sources for Facebook Ads and Google Adwords to help you understand the true performance and cost of your campaigns.
In this article, we dig into the nuances of data collection and potential gotchas around measuring clicks, pageviews, and ultimately, conversions.
Today, most marketing teams think about their paid acquisition funnel as three major steps…

This makes sense when looking at overall campaign performance, but hides several crucial funnel steps that can make the difference between increasing a campaign’s spend and shutting it off due to poor results.
Because page optimization and ad blockers can impact measurement of your funnel, it’s important to look at the four additional steps happening between the ad click and conversions.

Let’s go through each true funnel step in a little more detail.
Impressions & Clicks:When a user views an ad, the ad platform increments the count of impressions for that ad. When an ad is clicked, the ad platform logs a click. This is all handled by the ad platform’s servers. Facebook and Google work hard to filter invalid and fraudulent traffic, whether that’s a mistaken click, a bot, or a competitor looking to drain your advertising budget. Any bad traffic is removed from both your reporting and your monthly bill.
Page Request Initiated:After an ad is clicked, a user’s browser attempts to load your landing page. This request is the first contact your application has with the user, and the server responds with the content to render the landing page.
First JavaScript Loaded:The user’s browser starts to download the landing page content, which includes the HTML, JavaScript, and CSS. The browser parses and renders this content, loading the JavaScript sequentially as it parses the page. By default, analytics.js uses theasynctag, which means that the browser won’t block the page and will load analytics.js once everything else is ready. Analytics.js wants to get out of the way where possible so you can create the best experience for your customers.
Page Fully Rendered:The page is fully rendered once all the html, css and scripts have been loaded on the page. This time can vary a lot based on the speed of the internet connection (how fast all the assets download) and the device itself (how fast the local computer can run all of the scripts).
Third-Party Scripts Loaded:Finally, third-party scripts are asynchronously loaded onto the page. The speed at which these scripts are loaded depends on a variety of factors, like the page size, network speed, and the size and number of the third-party scripts. Once these scripts are loaded, analytics.js triggers apagecall to our API.
Conversion Event:From there, a user might fill out a form, signup, or buy your product!
There are three less-obvious contributors to fall-off across the paid acquisition funnel: slow loads, ad blockers, and bounces.
For the sake of illustration, this means that if you have 100 ad clicks, you will be able to count most but not all corresponding page views because some visitors may bounce (exit or hit the back button) before analytics.js is executed. Similarly, you may miss some attributable conversions due to slow load times (your page calls can’t fire in time) and ad blockers (which often block analytics not just ads).

Here’s how it works.
Slow Loads
Slow loads can impact your attribution modeling, making campaigns appear to have worse performance than reality. In the general case, when a user hits your landing page, your tracking code loads and triggers a pageview event that you can use to attribute that user to a campaign.
But if third-party scripts take on the order of seconds to load (for example, on 1x or 3G networks), users may click off the page before your tracking code executes. In this case, the pageview never gets recorded and your ability to attribute that click to a conversion is lost.
This is generally not an issue for most companies because they are focused more on people who spend a good deal of time on their pages. However, it is a potential source of opaqueness, particularly for users with slow or bad network connection.
Bounces
Bounces can occur at any stage of the funnel between an ad being clicked and third-party scripts loading on the page.
Some bounces are not tracked because the user doesn’t even last the few seconds to request your HTML, render it, and execute tracking. If they quickly hit back or close the browser window, your ad platform will report clicks that don’t show up in your analytics tracking.
Ad blockers
It is likely the case that some percentage of your users are using ad blockers. It’s estimated that22% of mobile smartphones worldwideand16% of US web trafficuse ad blockers. Segment customers have reported ad blockers for as little as a few percentage points of their visitors, to upwards of 70% of traffic for companies with very tech-forward audiences.
But just because a user is using ad blockers doesn’t mean that they aren’t seeing and clicking on ads. Facebook recently announced that they would besuppressing ad blockers, and Adblock Plus, the most popular ad blocking and anti-tracking software, categorizes Google Search ads asacceptable ads.
That said, many ad blockers do block analytics tools like Google Analytics, Mixpanel and Segment. This means that there exists some percentage of your conversions that actually came through your paid acquisition channels, but are unattributable due to ad blockers.
Segment offers two ways of joining your user clickstream data to your paid acquisition channels: standard client-side tracking or advanced server-side page calls.

Both options come with their own tradeoffs that are important to consider for your use case.
Client-side Tracking (Standard)
Analytics.js is loaded with the async tag by default, which means that the library and all it’s destinations are loaded near the end of the page rendering. The benefit is that analytics.js doesn’t slow down page loads, but it does mean that tracking is not executed immediately on page load.
When you use standard client-side tracking, you’ll lose pageview data for visitors who bounce or click off the page before analytics.js executes, and for visitors with ad blockers enabled.
Server-side Page Calls (Advanced)
If you want to capture adblock, bounce, and slow load traffic, we recommend adding an additionalpage()call to the server-side. This allows you avoid the browser altogether and see the total number of requests emanating from your paid acquisition channels. You’ll get visibility on an extra step in that funnel.
The general approach is to use an arbitraryanonymousId(e.g. a UUID) in the server-sidepage()call and then also set theanonymousIdas theajs_anonymous_idcookie in the browser. You can read more about how to implement that here. This approach is tricky to implement, so we recommend that this is undertaken only for use cases in which bounce and/or adblock data is critical.
If you want to get a quick estimate for the number of additional clicks you’d track using server-side tracking, you can use “redirect tracking” with a URL shortener to estimate the number of clicks coming from Google Adwords or Facebook Ads. This will give you an estimate for the number of times an ad is clicked (minus some bounce in the few hundred milliseconds of the redirect), which will closely match server-sidepage()tracking should you choose to implement it.

Here’s how it works…
Use a URL shortener like bit.ly to link to a landing page, with a custom parameter like?ttg=2.
Add the shortened link to your ad.
Measure total clicks from the bit.ly stats page.
In your warehouse, count the number of pages with that unique url parameter from step 1 (make sure you’re looking at the same timeframe).
We hope this overview helps explain the technical nuances of measuring what happens when a customer finds you using an ad! If you have any other questions, feel free to share them in the Segment Community for discussion.
Headings:
Measuring Your Advertising Funnel
Measuring Campaign Performance
How does this impact my ad reporting?
What if I need more precise tracking?
Estimating the Impact of Moving Server-side
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/measure-marketing-roi/
Paragraphs:
On this page
The purpose of marketing campaigns is to drive traffic (and sales). But how do you know which campaigns yield the most conversions or what channel across the campaigns was most effective?
This guide provides you with the tools to answer these questions with SQL so that your marketing team can reproduce the hit campaigns and consistently generate loyal customers.
Talk to a product specialistto learn how companies like Warby Parker and Crate & Barrel use a data warehouse to increase engagement and sales.
The goal of marketing campaigns is to drive engagement and conversions. Most commonly performed by attracting traffic to the site, these campaigns use UTM parameters for attribution. In our analysis, we’ll be heavily relying on UTM parameters to analyze not only campaign, but also channel performance.
Learn how to effectively use UTM parameters in your marketing campaign strategies.
For our analysis walkthrough, we’ll use fictitious e-commerce and marketing data from on-demand artisanal toast company, Toastmates.
Toastmates is currently running these two campaigns:
Each of these campaigns used a combination of channels. Here is a table with the channels and corresponding UTM parameters so when we build the SQL query, we can make sure all of the traffic sources are accounted for.

We’ll use SQL below to measure the performance of each campaign and what that means for future marketing activities.
The following query creates a table where each row is a customer and the columns are the date time when a key funnel event happens that have thecontext_campaign_nameto match that of theUTM_campaign. The key funnel events in this analysis areStore Visited(based on a page view to the store URL),Product Viewed, andOrder Completed. Given that each channel may have some key top of the funnel action that is unique to itself, let’s save that analysis for when we’re analyzing across channels.
Feel free to copy and paste the below query for your analysis so long as you replacenational-toast-daywith your own UTM campaign parameter.
Here are the first four rows of the resulting table:

Then, we can use tweak the query above into the one below to perform some simpleCOUNTandSUMon the previous table to get conversion metrics as well as total revenue derived from the campaign.
Here is the resulting table:

This analysis not only gives us a great snapshot of the conversion points along each campaign’s funnel, but also shows that we’ve generated $3,100.37 from the National Toast Day campaign and $3,824.68 from the Toast Your Friend campaign. Also we can see that the quality of the traffic from the National Toast Day is higher, but we’ve had more total traffic from Toast Your Friend, which makes sense since it’s an ongoing campaign.
But this is not yet ROI, since we haven’t incorporated the spend—the labor of your marketing team and the paid acquisition channels to source part of this traffic—that went into these channels.
Add campaign costs
The main costs that are incorporated in an ROI calculation are salaries (pro-rated by person-hour) and media spend. While we could conceivably create a custom, static table in SQL that contains the spend information over time, the faster and more practical way would be a back of the envelope calculation.
The costs associated with a given campaign consist of two major pieces: the person-hour cost and any associated media spend.
Calculating the pro-rated person-hour is an estimate of the number of hours and people used to set up and manage the campaign, then multiplied by the hourly rates based off their annual salaries.
The media spend is the advertising cost for distributing creatives to generate traffic to your store
Want to easily export advertising data fromGoogle AdwordsorFacebook Ads?Check outSegment Sources.
When we have the aggregate cost numbers, the formula for ROI is:
Here is a spreadsheet to illustrate the ROI calculation for both campaigns:

Though ROI numbers are one success metric, it’s an important benchmark for comparing performance when launching new campaigns or comparing against past campaigns.
But how can we go one step further and see what worked and what didn’t? One approach is to see which channels convert better, so you know how to adjust your marketing spend or media buys in your current campaigns or future ones.
A single campaign can include a wide variety of channels: email, display ads, push notifications, forums, etc. all of which yields different engagement and conversion rates. Effective marketers will keep a pulse on each channel throughout the duration of the campaign to understand whether a target audience is being saturated, a creative refresh is needed (for advertising), or how to efficiently allocate future spend towards a source that converts.
The analysis is similar to measuring the performance across a single campaign, with the only change being finding events where we focus oncontext_campaign_mediumorcontext_campaign_sourceinstead ofcontext_campaign_name. The SQL below measures the conversion rates at key funnel events fornational-toast-day, but broken down byutm_medium.
You can copy the below into your favorite editor, as long as you change out thecontext_campaign_nameandcontext_campaign_mediumparameters to ones that applies to your business.
The resulting table:

Since the National Toast Day campaign is relatively new, the majority of the traffic is from the email and an article (“news”). But we can see that the social channels have a lower conversion from store visits to product views. Email has the best overall conversion to revenue, which may be attributed to the recipients already familiar with the Toastmates brand or having previously had a stellar end-to-end shopping experience.
We can further breakdown this analysis by seeing which email, display ads, and social channels performed the best, by addingutm_sourceandutm_content,assuming that you’ve properly added them in your earned and paid media links. Also note that this preliminary analysis in SQL doesn’t account for double-counted users, who had impressions with our brand on multiple channels (e.g. someone seeing a display ad, yet converted on the email outreach). Fortunately, there are multi-touch attribution models that can be applied to better understand the weights of each activity towards conversion.
Learn more about multi-touch attribution models.
Measuring the ROI and performance of marketing campaigns and marketing channels tells a compelling story about what types of campaigns resonate with your audience. How does your audience like to be engaged? Text, push notifications, email? What campaign messaging hooks work the best in getting them back at your store?
You can apply this analytical approach and performance measurement techniques to a wide variety of marketing activities, such as offline marketing, billboards, or sponsoring events. These insights can empower your team to focus on what works and eliminate what doesn’t.
Talk to a product specialistto learn how companies like Warby Parker and Crate & Barrel use a data warehouse to increase engagement and sales.

Headings:
Measuring the ROI of Your Marketing Campaigns
Analyze campaign performance
Build the funnel
Analyze channel performance
Build repeatable hit marketing campaigns
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/migrate-from-other-tools/
Paragraphs:
On this page
Switching from your current client-side JavaScript event tracking to Segment is easy. Below you can find migration guides for the following tools:
If you’d like us to add more tools or mobile/server-side examples to this guidelet us know!
Google Analytics Custom Events are simple to record in Segment. You’ll record them with our track method and use the same properties you would when sending to Google Analytics directly.
The only mapping exception is the Event Action. That will automatically be populated by the Event Name you include in the track call.
Here’s an example:
Becomes:
Since Event Category is required we’ll populate it withAllif you don’t specify one. You can read more about this inour Google Analytics docs.
Segment has full support for the Google Analytics E-Commere API and theEnhanced E-Commerce APIas well. Make sure you followour e-commerce tracking planto make sure you’ll be able to use all e-commerce features in the tools we support.
For an e-commerce transaction to appear in Google Analytics you’ll need to enable e-commerce for your Google Analytics view and send an Order Completed event to Segment. This simplifies things a lot compared to the direct Google Analytics code.
Here’s an example:
Becomes:
At the very minimum you must include an orderId for each Order and for each product inside that order you must include an id and name. All other properties are optional.
Through Segment you can record user-scope custom dimensions using our identify, page, or track methods.
A full explanation can be found inour Google Analytics docspage, but here’s a quick example:
Becomes:
(This example assumes you have already mapped Gender to the correct dimension in your Segment source settings for Google Analytics.)
To see a full list of Google Analytics features and how they work through Segment readour Google Analytics docs page.
Event tracking is Mixpanel’s bread and butter. Below are all the relevant Mixpanel functions and how you can map them to Segment functions.
Switching your event tracking from Mixpanel to Segment couldn’t be easier. Our trackmethod maps directly to Mixpanel’s. The event name is the first argument and the event properties are the second argument.
Becomes:
The identify method in Mixpanel is used to merge together events from multiple environments so your unique events number is accurate and your funnels don’t break.
Sincemixpanel.identifyonly takes a single argument (a userID) it maps directly to our identify method:
Becomes:
Mixpanel has the idea of Super Properties, which are user traits that get attached to every event that the user does. In Segment you can set Mixpanel Super Properties using our identify method. Super properties are only supported in client-side librariesAnalytics.js,iOS,Android.
Here’s an example:
Becomes:
This also works when you include a userId argument in your identify call.
Alias is necessary in Mixpanel to tie together an anonymous visitor with an identified one. The Mixpanel and Segment alias methods both work the same.
In client-side javascript passing a single argument will alias the current anonymous or identified visitor distinct_id to the userId you pass into it:
Becomes:
If you are tracking links with Mixpanel’strack_linkshelper you can switch that code to the SegmenttrackLink helper functioninAnalytics.js.
And here’s an example:
Becomes:
If you are tracking forms withMixpanel’s track_forms helperyou can switch that code tothe Segment trackForm helper functionin Analytics.js.
And here’s an example:
Becomes:
Mixpanel people tracking is a separate database from the event tracking outlined above. For that reason there are separate API methods to record data to Mixpanel People.
This method sets people properties in Mixpanel People. In Segment you will use ouridentify method to accomplish this.
Here’s an example:
Becomes:
This also works when you include a userId argument in your identify call.
As you can see Segment also recognizes special traits like email and name and translates them to the keys that Mixpanel expects (we automatically add the dollar sign).
For more information check outour Mixpanel docs.
To use Mixpanel increment through Segment you won’t event need anything in your code! All you have to do is list the events you’d like to increment automatically in your Mixpanel destination settings.
Read more inour Mixpanel Increment Docs.
Mixpanel’s Revenue report requires the use of a special function calledtrack_charge. In Segment that special function becomes a simple track call. By using the event nameOrder Completedwe’ll also use that event for any tools you use that recognize ourecommerce spec.

Headings:
Migrating Code From Other Analytics Tools
Google Analytics
Custom Events
Ecommerce
Custom Dimensions
Everything Else
Mixpanel
Event Tracking
Alias
Track Links
Track Forms
People Tracking
Increment
Revenue
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/segment-and-attribution/
Paragraphs:
On this page
At a higher level, attribution tools allow you to connect a specific campaign to user acquisition, giving you more visibility into campaign performance.  Seethe destination catalogfor a list of attribution tools that Segment supports.
There are three stages of mobile attribution as it relates to Segment.
Customer installs your app
The install is attributed by an attribution provider (Adjust, AppsFlyer, etc)
Attribution information is sent back to Segment
Here is a bit more information on what is happening at each of those stages.
Whenlifecycle eventsare enabled, theApplication InstalledandApplication Openedevents are triggered on the first app open after the app is installed.  Note, if the app is deleted and then later reinstalled on the device, these events will be triggered again on first app open.
Situations where install counts look lower in Segment than in other tools.
Some tools, like iTunes or Google Play, count install on download rather than on app open like Segment.  iTunes and Google Play is able to easily collect data on download but not as easily able to collect first-party data on app open. Whereas other tools, such as Segment, need their SDK to be loaded in app and initialized on app open before they are able to collect the install information. For example, if a user downloads your app but does not open it, the install will be counted in iTunes/Google Play but not counted in Segment or other tools.
Situations where install counts look higher in Segment than in other tools
Many tools deduplicate install data. Some tools only allow one install event per lifetime of deviceId. Others deduplicate by deviceId accepting only one install per UTC day.  Each and every tool is different.
Segment, on the other hand, does not deduplicate.  We don’t believe our role in your data pipeline should be deduping particular events.  In fact, there may be situations where you may want to account for multipleApplication Installedevents such as: user sells their phone, user uninstalls and later decides to reinstall, etc. It is better to think about theApplication Installeddata in your Segment warehouse as the raw source of data, giving you flexibility to query
For more information on how installs are counted in different tools, here are a few resources from our partners:
Adjust - Discrepancies and Why Data Does not Always Match Up
When you enable an attribution destination in device-mode, our integration code will also load that tool’s SDK. Upon app launch, the destination’s SDK will send install information which is then use to attribute that install to a campaign on their backend.  Segment loads the destination’s SDK, but attribution happens outside of Segment.
Destination receives theApplication Installedevent and attributes the installation on their backend.
For tools that support this, if you have enabled “Track Attribution Data” in your Segment dashboard, our integration listens to the attribution tool’s SDK for a change in attribution state.Note: Not all device-mode attribution tools offer “Track Attribution Data” functionality.  See the settings section for a particular tool in your Segment dashboard for confirmation.
When there is a change in attribution state, the integration code triggers anInstall Attributedcall to be sent back to your Segment source (and on to all other enabled destinations - in device and cloud-mode).
Here is an example of how that call is triggered in theAppsFlyer integration code. This is the similar for other attribution providers such asAdjust.
For tools that support server-side postback, after install is attributed, anInstall Attributedevent is triggered and sent server-side to your Segment source and forwarded on to all enabled cloud-mode destinations.
ExampleInstall Attributedevent:
For more detailed information on a particular attribution destination and functionality, see ourDestinations docs.

Headings:
Segment's Role in Attribution
Customer installs your app
The install is attributed by an attribution provider
Device-Mode Connection
Cloud-Mode Connection
Attribution information is sent back to Segment
Device-Mode Connection
Cloud-Mode Connection
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/how-to-guides/set-up-notifications-alerts/
Paragraphs:
On this page
Below you’ll find a bunch of ways to set up notifications for yourself based on the data you’re sending through Segment.
Connections Alerting allows Segment users to receive in-app, email, and Slack notifications related to the performance and throughput of an event-streaming connection.
Connections Alerting allows you to create two different alerts:
For more information about Connections Alerting, see theConnections Alertingdocumentation.
You can use Google Analytics Custom Alerts to send yourself emails whenever a specific traffic segment drops below (or above) a threshold you set.
Learn how to set up email alerts inGoogle’s documentation.
With tools like Amplitude, Kissmetrics, and Mixpanel, you can set up email reports delivered to you on a daily basis. They are completely customizable, so you can keep an eye on as many events or other metrics you’d like.
Chartbeat and GoSquared both offer awesome real-time dashboards to see what’s happening right now on your site. They both include the option to get notified when your traffic hits a certain threshold. For example, if your on-site visitors is less than 100 people, or more than 1,000.
GoSquared also offers in-depth historical and user analysis. Chartbeat sticks to realtime anonymous traffic, but offers some sweet features for publishers.
The last option Segment recommends is to use a monitoring tool likePagerDutyorDatadogand point Segment’swebhooksdestination at them. That way you can set up custom alerts in their system.
The last option for alerting based off of Segment events is to use one of the email tools available on the Segment platform that offers event-triggered emails. Your options there are Customer.io, Vero, Autopilot, Outbound, Klaviyo, or Threads.

Headings:
How do we set up event-triggered notifications or alerts?
Connections Alerting
Google Analytics custom alerts
Analytics email summaries
Realtime traffic monitoring
Webhook-based alerts
Event-triggered emails
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/usage-and-billing/account-management/
Paragraphs:
On this page
An account is associated to a single user and is attached to the email address you sign up with. A workspace houses all of your sources, and can have one or several user accounts as owners and/or read-only members.
You don’t need to do anything if you change your domain name. If the new domain name will serve as the same Segment source, make sure you use the same Segment write key that you used with the old domain.
You may claim ownership of your domain for the purposes of single sign-on login association, but it currently has no bearing on data collection.
Some of Segment’s previous plans, including the legacy API plan, limited integration usage. If you want to add an integration that’s not available on your current plan, move to a new Team plan. Team plans include all integrations, along with other additional features.
No. Deleting your account only stops you from accessing workspaces through your login. The workspace is where the subscription is managed, and it will not be deleted. Data will still flow into Segment and your Destinations, and you will still be charged if you delete your account but don’t delete your workspace.
To delete your account, go to theUser Settingsmenu, and clickDelete Accountat the bottom of the page.
Once the account is deleted you will not have access to workspaces associated with your account that are attached to the email address you signed up with.
To delete your workspace, go to yourWorkspace Settings, click theGeneraltab, then clickDelete Workspace.
You should also change your write keys for each source and remove all Segment snippets from your codebase.
To update the email address associated with your Segment account:
You’ll need to authenticate and verify your new email address for the change to take effect. Note thatworkspace ownerscan’t make this change for other users.
Changing your workspace name or slug won’t impact any sources or destinations you’ve already configured. If you’re usingSegment’s Public API, you’ll need to change the slug in your request URLs.
We were unable to save your changes, please try again
If you see this error message when trying to change a workspace slug, it often means the slug is already taken.
No. Deleted sources and workspaces cannot be recovered.
Though workspaces can’t be merged, you can move an existing source to a single workspace to the same effect. For example, you might move existing sources to one workspace so that you can unify all of your data across teams and gain a broader view of your customer data tracking.
To move a source between workspaces, navigate to the source’sSettingstab, then clickTransfer to Workspace. Choose the workspace you’re moving the source to, then clickTransfer Source.
When you transfer a source from one workspace to another, Segment migrates all connected non-storage destinations.
The person who transfers the source must be aworkspace ownerfor both the origin and recipient workspaces, otherwise the recipient workspace won’t appear in the dropdown list.

Tracking Plans do not transfer
Segment recommends that you disconnect Tracking Plans from Sources before you initiate a workspace transfer. Once the transfer is complete, add and reconnect your Tracking Plans in the new workspace.
Sources can't be transferred to EU workspaces
Though transferring sources to the EU workspace is not blocked in the UI, the transfer will not work as expected. This feature is not supported for cross region migration. Segment recommends that you re-create the source in the new workspace.

Headings:
Account Management
What is the difference between an account and a workspace?
What if I change my domain name?
I’m on a legacy API plan. Why can’t I add the integration I want?
Will deleting my account cancel my subscription?
How do I delete my account?
How do I delete my workspace entirely?
How do I change my account email address?
What happens if I change my workspace name or slug?
Can I recover a source or workspace after I delete it?
Can I move a source from one workspace to another?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/usage-and-billing/billing/
Paragraphs:
On this page
On the Segment monthly Team plan, your billing cycle starts the day after your 14-day trial ends. You’re billed on this day for each month while you’re on this plan.
On the Segment annual Team plan, you’re billed at the end of your 14-day trial for the amount of an entire year of service including a specific number ofMTUs. Annual plan subscribers are billed for MTU overages at the end of each monthly cycle.
If you already have a Segment workspace, you can change which plan your workspace is on by navigating toSettings > Usage & Billing > Plans.
If you cancel or downgrade your plan during the 2-week trial period, you don’t incur any charges.
If you cancel your plan or downgrade to a free account before the end of your official billing period on the monthly Team plan, you’ll receive a final bill for the prorated amount for the $120 base + a charge for any MTUs you’ve used over the allotted 10,000 at the rates posted on thepricing page.
Segment doesn’t issue refunds for the pre-paid portion of your annual bill after your trial ends.
Be aware that if you notify Segment of wanting to cancel your annual plan, but continue to send data to Segment’s servers, you may incur overage charges in any given month. You should fully delete your workspace or cycle your write keys to stop all data flow into Segment to avoid future charges.
All Segment customers with a US business address may be subject to state and local sales taxes. The applicable tax law applies based on your business location address, which may be different from your billing address. Customers who purchase a taxable product or service, and are located in a jurisdiction where Segment currently charges sales tax, will see the calculated sales tax on their invoice.
Segment collects Value Added Tax (VAT) and Goods and Services Tax (GST) on the services sold to its international customers located in certain foreign jurisdictions.
For more information about sales tax, VAT, and GST, see theSegment VAT/GST FAQs.
If you believe your organization qualifies for a sales tax exemption (for example, because of a nonprofit or government status), you can contacttax@segment.comwith the appropriate form.
Tax might still be charged on your bill if either:
In most cases Segment doesn’t offer refunds, as noted in theTerms of Service.Contact supportif you feel that you’re in a unique situation.
Segment offers a2-week trial on the Team planto let you try the plan before you purchase it.
Segment also offers the Free plan, which includes up to 1,000 MTUs, at no cost to you.
Find out more about thedifferent plansand which one suits your needs best.
The Free plan includes up to 1,000 MTUs at no cost. If you exceed the 1,000 MTU limit once in a 6-month period, Segment locks your account but data is still able to flow through Segment. To unlock your account, you can choose from these options:
If you exceed the 1,000 MTU limit twice in a 6-month period, Segment locks your account and also stops sending and receiving data. You can unlock your account by following option 2 above to upgrade to theTeam plan2-week free trial.
What is the Team trial?
The Team trial is a 14-day free trial of Segment’sTeam plan, and it includes all the features associated with a Team plan, including unlimited sources, two warehouse syncs per day, 10 seats, and 10,000 MTUs (with the ability to track more MTUs as needed).
How do I get a two-week Team trial?
You automatically receive a 2-week trial when you sign up for a Team plan.
Do I have to be a “new” customer to receive the free Team trial?
The free trial is available to all customers who have never had a Team plan. This includes new customers as well as customers who have previously been on the Free plan.
Do you have to include your payment information when signing up for a Team trial?
If you’re upgrading from a Free Plan to a Team Plan, you’re required to add your payment information.
If you’re signing up for a new Team plan, you don’t have to add your payment information during sign up. If you would like to continue to use the Team plan after the 14-day trial, add your credit card information on the “Payment Information” page in your workspace before the trial ends.
What happens when the two-week trial ends?
If you added your payment information, your subscription automatically continues at the regular rate after the trial period expires. You candelete your workspaceordowngrade to a Free planany time during the trial to avoid charges.
To activate the free trial, add your payment information.

Headings:
Billing and Account FAQs
What is a billing cycle?
How do I change my plan?
What if I cancel my paid plan before the end of the month?
Cancellation on the monthly Team plan
Cancellation on the annual Team plan
Will Segment charge sales tax on my invoice?
Do I qualify for a tax exemption?
I submitted a form for tax exemption, why am I still charged sales tax?
Do you offer refunds?
Is there a free trial for paid plans?
What happens when I exceed the Free plan limit?
Team Trial FAQ
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/usage-and-billing/mtus-and-throughput/
Paragraphs:
On this page

The graphic illustrates an example billing model with data flowing through Segment within a monthly period. Each event on the different touch points (for example, Sign-ups or Product Added) is calculated as one API call.
Segment detects that the user across two of the touch points is the same user based on their userID (userID 123) and deduplicates them, counting for oneMTU.
With Engage, this user falls into one audience, has one computed trait, and falls into one Journeys step, accounting for three compute credits total. Compute credits are not tied to an individual user, so multiple people could fall into these buckets, still accounting for a single compute credit for each trait/audience/journey step.
Finally, the example sends some user events to a destination function, which is charged according to function execution time.
MTU stands for “monthly tracked user”. (Keep reading to learnhow Segment counts MTUs.)
When you use Segment to collect your data, you use the Segment tracking methods (Track, Page, Screen, Identify, Group, and Alias) which collect the datain a structured way, and then send it toapi.segment.io. If you are using the Segment HTTP API, or sending batched data using a cloud-source, that data also goes through this Segment API endpoint.
Each data blob (with its properties or traits) goes through this endpoint, and is considered one “API call”.
Depending on your Segment account type, your plan might include a throughput limit. The throughput limit tells you how many API calls and objects Segment allows you per MTU.
For example, if your workspace’s throughput limit is set to 250, this means that you can send a combined total of 250 API calls and objects to Segment each month per MTU you’ve paid for in your plan. If you have a 10,000 MTU plan, this means you can send up to a total of 2.5 million API calls and objects each month.
These objects and API calls are not tied to a specific user, but are an aggregate number applied to your workspace. Most customers never hit this limit, and Business tier plans often have custom limits.
You can sometimes “batch” API calls to reduce send times, however batching doesn’t reduce your throughput usage. Batched calls are unpacked as they are received, and the objects and calls the batch contains are counted individually. While batching does not reduce your throughput, it does reduce the possibility of rate limit errors.
Segment counts the number ofuniqueuserIds, and then adds the number ofuniqueanonymousIds that were not associated with auserIdduring the billing period. Segment counts these IDs over all calls made from all sources in your workspace, over a billing month. Segment only counts each user once per month, even if they perform more than one action or are active across more than one source.
Imagine that you have both a website and a mobile app. Both the website and mobile app have pages that you can use without being logged in, and both send Identify calls when a userdoeslog in.
As a simple example, imagine that a user is already logged in on both the website and the mobile app. When the user’s activity generates events on the website, these events are sent using Analytics.js, and include the user’suserId. When they do things on the mobile app, these events are sent from a mobile source, and also include theuserId. When Segment counts the MTUs, all the events from the sameuserIdonly generate one MTU, regardless of the source it came from.
Now imagine a new user, who has never logged in. At first, they have twoanonymousIds, one for the mobile app and one for the website. However, if they log in during the course of the month, you now know who they are, and can attach theiranonymousIdto auserId.
If the user logs in onjustthe app, you would still see two MTUs: oneanonymousIdfor the website source, and oneanonymousIdwith an attacheduserIdfrom the mobile app source.
If the user logs in onboththe app and website, they would count as one MTU: two differentanonymousIds attached to oneuserId.
If you have questions about your data usage or how it relates to your bill, log into your Segment workspace, clickSettings > Usage and Billing > Usage.
The Usage page shows what plan the workspace is on, what data volume that plan includes, and how much data you have already used in the current billing period. If you have used more data volume than your plan includes, the page shows information about how much data is in overage.
Click the billing period dropdown at the top of the page to see a cumulative daily report of data volumes (by source) for the current billing period. The last five billing periods are also available, along with an overview of the last twelve months of data volumes.
Understanding the difference between events and objects helps you understand how MTUs are calculated.
An event is a data collection triggered in response to a user action: aTrack call(or aPage/Screencall if the action was to navigate to a new page). Events take place in a single moment in time, and include a name, timestamp, andproperties. When an event happens more than once, it creates a new Event record (with a new timestamp) rather than updating an existing one. For example, a user browsing a product catalog might generate several “Product Viewed” events, which might include the product name, price, and category.
This is in contrast to “Objects” which represent a single thing that persists over time and can be updated. Objects have “traits” (instead of properties) which record information about that object, and which can change over time. For example a “user” object could have a trait of “email” which doesn’t change often, but could also have acomputed traitlikelogged_in_last_7_daysthat changes betweentrueandfalsebased on how much they use your site.
Object Cloud Sourcesretrieve records from integration partners on a scheduled basis. Segment processes these records before writing them out to connectedStorage Destinations. Segment counts one object for each record retrieved from a Cloud Source. The number of objects ingested during a billing period has a direct impact onthroughput, which is calculated as(objects ingested + API calls received) / MTU allowance.
Depending on the capabilities of the partner’s API, Segment may need to retrieve all available records and then deduplicate them prior to writing them out to a connected storage destination. In such cases, all retrieved records are still counted as ingested objects, even if the same records are retrieved multiple times in a given billing period. If you experience overages due to high object throughput, contactfriends@segment.comto request a less frequent sync cadence.
If you useCloud sourcesto pull in data from your third party services (in addition to tracking your users with Segment library sources), the data from these cloud appscanincrease your MTU counts and object counts.
There are two types of cloud sources:object sources, andevent sources. Object sources bring in information about entities, such as a person or company, which can change and have their properties updated over time. Events happen once in time, so while their properties don’t change, they can also happen more than once over time. (Seeabovefor more on objects vs events.)
Object sourcesdo notincrease your MTU countbecause the data included doesn’t usually contain an ID. Object sources can only send to Warehouses, anddoaffect the total object count which is used to calculate yourthroughput. Some examples of object-sources areSalesforce,Zendesk, andStripe.
Event sourcescancreate new MTUsbecause each event coming from this source includes either auserIdor ananonymousIdassociated with the event. Some examples of event sources areVero,Drip, andYoubora.
Tip!You can check theCollectionssection of a cloud-source’s Segment documentation to see what type of data it sends. The Collections table lists each data type sent from the cloud source, and tells you if that data is an Object or an Event.
Protocols is a Business Tier feature. If you are on a Free or Team plan, this section does not apply to you.
Segment’s Protocols product allows you to selectivelyfilter and block your incoming datato prevent malformed data from reaching destinations including your data warehouses and other storage solutions.
Tracking plan blocking: Blocked events are blocked from sending to all Segment Destinations, including warehouses and streaming Destinations. They’re blocked from reaching the entire Segment data pipeline. When you block an Event using a Tracking Plan, it does not count towards your MTU limit.
Blocked events (sometimes called “violations”) only count toward your MTU limit if you enableblocked event forwardingin your Source settings. You might do this to monitor issues with your incoming data as you continue to develop your tracking.
If you enable violation forwarding, it generates one (1) additional MTU in your workspace, total. If you are on an API billing plan, you are charged for the increased API volume generated by the forwarded violations. Forwarded violations might also generate costs in downstream destinations and data warehouses connected to the violations source.
Engageis a Business Tier addon feature. If you are on a Free or Team plan this section does not apply to you (because you do not have this feature).
All Engage data are omitted from billing MTU and API throughput calculations, includingcomputed traits,SQL traits, andaudiences.
Replayis a Business Tier feature. If you are on a Free or Team plan, this section does not apply to you.
Replays only affect your MTU count if you are using aRepeaterdestination, which might send data that hasn’t yet been seen this month back through a source.
See theReverse ETL usage limitsto see how MTUs affect your Reverse ETL usage limits.
Different tools count users under different conditions, so comparing numbers between any two tools, or between Segment and a tool, rarely produces the same number. Each tool accepts slightly different incoming data, and they often reject or process the incoming data differently. Included are some example explanations of why you might see differing numbers below.
ContactSegment Product Supportif for more information about a specific tool, or if you’re concerned that differing numbers might be due an implementation error.
Google Analytics requires that you include aurlin any Page calls from a Segment server library. If you don’t include aurl, Google Analytics silently rejects the call, which can reduce the number of users you see in GA.
Segment does not pass data fromIdentify callsto Google because it is against Google’s terms of service to pass Personally Identifiable Information (PII) to the Google Analytics reporting interface. If you need to pass data from an Identify call, you can set up aCustom Dimension mappingto override this.
To pass theuserIdfrom yourIdentify callsto Google Analytics, go to the Google Analytics destination settings in the Segment web app, locate theAdvanced Google Analytics settings, and enableSend User-ID to GA.
By default, Segment doesn’t send standardPage callsorScreen callsto Amplitude, which might reduce the number of unique users Amplitude sees.
To send Page and Screen calls to Amplitude, go to the Amplitude destination settings in the Segment web app, and locate theAdvanced Optionstab.
Amplitude can only automatically link an anonymous user to their logged-inuserIdif the events or traits come from a device-mode source (such as Analytics.js or a mobile library). If you use a server library or the Segment HTTP API, Amplitude can’tautomaticallyconnect the anonymous user to their logged-in identity. To work around this so Amplitude can connect the anonymous and identified user, make your Identify call when the user logs in, and include both theanonymousIdfrom before the user logged inandtheuserIdthe user provided at log-in.
For Amplitude to associate both client-side and server-side activity with the same user, you must pass the samedeviceIdto Amplitude. Otherwise, Amplitude creates two users - one associated with the user’sdeviceIdand another user associated with the user’s SegmentanonymousId.
There are several reasons why you might see a sudden increase in MTUs. Most of them are due to traffic fluctuations, however, some changes you make in code might also increase your MTU count, usually because you are (unexpectedly) generating a newanonymousIdoruserIdfor a single user.
If you think an implementation problem is causing an increase in your MTU count,contact Segment Product Supportas soon as possible for help troubleshooting and resolving the issue.
MTU counts usually increase when the number users or visitors to parts of your site or application that use Segment tracking increase. Sometimes you’ll see a spike when you post a big press release, or marketing campaign that leads to an influx of visitors. Another potential cause of big increases is adding tracking to parts of your site or app that didn’t have tracking before.
Another possibility is an increase in the number of interactions with your users outside your app (emails, help desk, push notifications, etc) that you are importing using cloud sources. Tracking users you weren’t tracking before increases your MTU count unless you are able to pass auserIdso they can be resolved with existing users. If you’re already tracking those users elsewhere with Segment, they are not counted a second time.
Users who are very privacy-conscious might cause your tracking to generate more MTUs; however in most cases these users are a fraction of a percentage of total traffic.
Check to see if you changed how you callanalytics.reset(). This utility method clears the old user identity information, and generates a newanonymousIdeach time you call it. This creates a user that Segment cannot resolve with an existing user until they are further identified.
Segment’s analytics libraries include methods that allow you to overwrite both theuserId(usingidentify(xxx)) andanonymousId(usinganalytics.user().anonymousId(xxx)). Using these methods on a user whose tracking information already includes an ID can cause the user to be counted more than once.
If you find you need to use one of these overwrite methods, you should check to make sure that the field you are changing isnullfirst. If the field isnotnull, you probably don’t want to overwrite it and lose the user’s original tracked identity.
If the pages you track are on more than one domain (for example,mydomain.comandmydomain.net), the user generates a newanonymousIdfor each domain. However, if the domain is a subdomain (for examplemydomain.comandapp.mydomain.com), they can share a user cookie and so share identity data and count as only one MTU.
If the user goes from one page to another and the second page loads in an iFrame, the page in the iFrame generates its ownanonymousId.
Segment does not bill for SMS and Email sends from Engage Channels. For actual billed usage, refer to the Twilio and SendGrid accounts that you’ve linked to Engage.

Headings:
MTUs, Throughput and Billing
What is an MTU?
What is an API call?
What is throughput?
Batching and throughput limits
How does Segment calculate MTUs?
Example MTU counts
Deduplication across sources
Deduplication after log-in
How do I see my usage data?
What is the difference between an event and an object?
How is object throughput calculated?
MTUs, object throughput, and Cloud sources
MTUs and Protocols
MTUs and Engage
MTUs and Replays
MTUs and Reverse ETL
Why is my MTU count different from what I see in my destinations and other tools?
Google Analytics
Amplitude
What might cause a spike in my MTU count?
Changes in traffic
Changes to imported sources
User behavior
Calling reset
Overwriting an existing identity
Cross-domain issues
Where can I find information about Twilio Engage Channels billing?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/usage-and-billing/discounts-for-startups-npos/
Paragraphs:
On this page
Segment currently offers coupons on an ongoing basis for:
Early-stage startupsSegment offers aStartup Programto enable early startups to track data correctly and easily test the marketing and analytics tools necessary to grow their business. Participating startups receive $25,000 in annual credit toward our monthlyTeam planfor as long as they meet our eligibility requirements (up to 2 years).
Learn more about the Segment Startup Program and eligibility requirements here.
Participants and Alumni of Accelerator PartnersWe currently partner with various accelerator programs around the globe to offer promotions for both current and alumni participants. Contact your accelerator administrator to see if they partner with Segment and for more information on how to redeem the coupon.
If your accelerator does not participate in our program, have themapply hereorcontact usto us with the details of your program and the best point of contact for consideration.
Non-profitsWe offer non-profit customers a $120 per month discount on our monthlyTeam plan, which typically covers 10,000 MTUs per month.Contact usto our support team with proof of your non-profit status for more details.
Special PromotionsWe occasionally offer special promotions. Customers will be notified directly if they are eligible for a special promotion.
How do coupons work?Coupons are applied to your monthly (or annual) bill, which reduces the corresponding charge to your credit card. Coupons can either take the format of a percent-off or a dollar value-off your bill. If your coupon is a percentage-off your bill, the dollar value of the coupon may change as your bill may fluctuate month-to-month.
How do I redeem a coupon?Eligible startups canapply directlyfor the Segment Startup Program. Other coupons can be redeemed by reaching out to Segment’ssupportteam, who will apply the promotion to your account.
Where can I view which coupons are applied to my account?The Startup Program credits are reflected in the Workspace usage and billing page. Other coupons applied to your workspace are not currently reflected in the Segment application. If you are curious about a promotion you are currently on, or if you workspace has a coupon applied,contact the Segment support team.
Do I have to be a “new” customer to receive a coupon?The Segment Startup Program is only for customers that have not previously received any other coupon. Both the non-profit and accelerator promotion can be redeemed regardless if you’re a new customer or have been with us for years. A user/workspace can only receive any coupon once.
What happens when my coupon expires?When your promotion expires, your bill returns to the normal, non-discounted rate. Certain promotions may include a follow-up discount immediately after the promotion expires.

Headings:
Discounts or Coupons
Coupon FAQ
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/guides/usage-and-billing/startup-program/
Paragraphs:
On this page
Segment offers aStartup Programto enable early startups to track data and test the marketing and analytics tools necessary to grow their business. The program is open to any early-stage startup that meets the following eligibility requirements:
The Segment Startup Program includes three components:
Interested companies can apply on theStartup Programsite.
Application deadline
Effective January 6, 2025, Segment will no longer accept applications for the Segment Startup Program. Applications submitted before 11:59 PM PT on December 5, 2024 will be reviewed and honored. Any applications received after this deadline won’t be accepted. There will be no exceptions.
*Can vary based on affiliated accelerator and VC partners.
How are the Segment credits applied?Credits are applied to your monthly bill, covering up to $25,000* in total usage per year. Any additional usage costs are not covered by the program.
How do I redeem the Segment credits?Eligible startups canapply directlyfor the Segment Startup Program.
How do I find out if I’ve been accepted to the Segment Startup Program?If you’ve been accepted to the program, you’ll receive an email with a welcome message and next steps. If you haven’t received an email, you can also check in your Segment workspace and look for a Startup Program icon in the top right corner.
Where can I view the credits applied to my Segment account?The Startup Program credits are reflected in the Workspace usage and billing page.
Do I have to be a “new” customer to receive a coupon?New and current Segment users who have not previously received any other coupon are eligible to apply.
What happens if I go over my total credit applied?If you go over the total credit applied, you will be charged for the additional usage for that month.
What happens when my credits expire?Once you’ve used your total credits, you might be eligible to renew for another year at a discounted rate. Otherwise, we can talk about options for upgrading your plan.
How do I get the startup partner deals?Once you’ve been accepted to the Segment Startup Program, you can apply for the partner deals usingthis Airtable form. (You can view a list of the available dealsin a section of the Airtable form.)
How do I know if my accelerator/incubator/VC firm has a relationship with Segment?Ask your program manager to see if they participate in the Segment Startup Program. If they do not, you can request that theyapply to become a partner.

Headings:
Segment Startup Program
Frequently Asked Questions
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/
Paragraphs:
On this page
Connections is Segment’s core product offering: you can collect event data from your mobile apps, websites, and servers with one API, then pull in contextual data from cloud apps like your CRM, payment systems, and internal databases to build a unified picture of your customers.
In Segment, you create a source (or more than one!) for each website or app you want to track. Wehighly recommendcreating a Source for each unique source of data (each site, app, or server), though this isn’t required.
Sources belong to a workspace, and the URL for a source looks something like this:https://segment.com/<my-workspace>/sources/<my-source-name>/
You can create new sources using the button in the workspace view. Each source you create has a write key, which is used to send data to that source. For example, to loadanalytics.js, the Segment JavaScript libraryon your page, the snippet on theQuickstart Guideincludes:
Learn more about sources from thesources overview page.
Destinations are business tools or apps that you can connect to the data flowing through Segment. Some of Segment’s most popular destinations are Google Analytics, Mixpanel, Kissmetrics, Customer.io, Intercom, and KeenIO.
All of these tools run on the same data: who are your customers and what are they doing? But each tool requires that you send that data in a slightly different format, which means that you’d have to write code to track all of this information, again and again, for each tool, on each page of your app or website.
Enter Segment. Do it once.
Segment eliminates this process by introducing an abstraction layer. You send your data to Segment, and Segment understands how to translate it so we can send it along to any destination. You enable destinations from the catalog in the Segment App, and user data immediately starts flowing into those tools. No extra code required!
Segment supports many categories of destinations, from advertising to marketing, email to customer support, CRM to user testing, and even data warehouses. You can view a complete list of availabledestinationsor check out thedestination pagefor a searchable list broken down by category.
A warehouse is a central repository of data collected from one or more sources. This is what commonly comes to mind when you think about a relational database: structured data that fits neatly into rows and columns.
In Segment, a Warehouse is a special type of destination. Instead of streaming data to the destination all the time, we load data to them in bulk at regular intervals. When we load data, we insert and update events and objects, and automatically adjust their schema to fit the data you’ve sent to Segment.
WithReverse ETL, your data warehouse acts as your source, enabling you to send data from your warehouse to your destinations.
The Sources and Destinations pages allow each user to decide what information appears in their personal view for each page.
On both pages, you can click the stack icon in the upper right-hand corner of the table to see and select Source properties to show. You can select up to five columns of properties.
The following information is available for Sources:
On the Destinations page, you can choose among the following properties:
You can then sort or filter each column to just the values you care about, by clicking on the arrow next to each displayed column.
Sources without any enabled destinations are auto-disabled after 14 days. However, the workspace owner is notified by email before Segment disables the source. Data that flows into Segment but does not flow to any downstream tools is not valuable to you and unnecessarily takes up space.
Segment understands there may be cases to keep a source active. If you’d like to add your sources to an exception list, you can do so by filling out thisAirtable form.
Yes, you are able to submit an integration request here https://segment.com/requests/integrations/.

Headings:
Connections Overview
Sources
Destinations
Warehouses
Reverse ETL
Information on sources and destinations pages
FAQs
My source was disabled and it wasn’t done by anyone in my workspace
Can I request Segment add an integration tool?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/
Paragraphs:
The Segment Spec provides guidance on meaningful data to capture, and the best format for it, across all of Segment’s libraries and APIs. If you implement Segment using these formats, it’s simple to translate your data to downstream tools.
Check out our high-level overview of these APIs in Segment University. (Must be logged in to access.)
Event and Product Limits
Events ingested by Segment are subject to definedProduct Limits.
The Segment Spec has three components.
First, itoutlines the semantic definition of the customer data Segment captures across all libraries and APIs.  There are six API calls in the Spec. They each represent a distinct type of semantic information about a customer. Every call shares the samecommon fields.
Second, itdetails the event data Segment captures across some cloud sources and destinations.
Third, itshares the events Segment recommends you track for a particular industry based on experience working with thousands of customers. When you respect these specs, Segment maps these events to particular features within end destinations like Google Analytics and Facebook Ads.

Headings:
Spec Overview
Segment University: The Segment Methods
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/page/
Paragraphs:
On this page
The Page call lets you record whenever a user sees a page of your website, along with any optional properties about the page. Calling Page orScreenin a Segmentsourceis one of the first steps to getting started with Segment.
Check out our high-level overview of the Page method in Segment University. (Must be logged in to access.)
Note: Inanalytics.jsa Page call is included in the snippet by defaultjust afteranalytics.load. Many destinations require this page event to be fired at least once per page load for proper initialization. You may add an optionalnameorpropertiesto the default call, or call it multiple times per page load if you have a single-page application.
Here’s the payload of a typical Page call with mostcommon fieldsremoved:
And here’s the corresponding JavaScript event that would generate the above payload. If you’re using Segment’s JavaScript library, the page name and URL are automatically gathered and passed as properties into the event payload:
Based on the library you use, the syntax in the examples might be different. You can find library-specific documentation on theSources Overviewpage.
Beyond the common fields, the Page call takes the following fields:
Here’s a complete example of a Page call:
Use the following interactive code pen to see what your Page calls would look like with user-provided information:
The User ID is a unique identifier for the user performing the actions. Check out theUser ID docsfor more detail.
The Anonymous ID can be any pseudo-unique identifier, for cases where you don’t know who the user is, but you still want to tie them to an event. Check out theAnonymous ID docsfor more detail.
Note: In our browser and mobile libraries a User ID is automatically addedfrom the state stored by a previousidentifycall, so you do not need to add it yourself. They will also automatically handle Anonymous IDs under the covers.
Properties are extra pieces of information that describe the page. They can be anything you want.
Segment handles properties with semantic meanings in unique ways. For example, Segment always expectspathto be a page’s URL path, andreferrerto be the previous page’s URL.
You shouldonly use reserved properties for their intended meaning.
Reserved properties Segment has standardized:
Note:Inanalytics.js, Segment automatically sends the following properties:title,path,url,referrer, andsearch.

Headings:
Spec: Page
Segment University: The Page Method
Example
Create your own Page call
Make a Page Call
Sample Page Call
Identities
Properties
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/screen/
Paragraphs:
On this page
The Screen call lets you record whenever a user sees a screen, the mobile equivalent of Page, in your mobile app, along with any properties about the screen. Calling Page orScreenin one of Segment’ssourcesis one of the first steps to getting started with Segment.
Check out our high-level overview of the Screen method in Segment University. (Must be logged in to access.)
Here’s the payload of a typical Screen call, with mostcommon fieldsremoved:
And here’s the corresponding Objective-C event that would generate the above payload:
Based on the library you use, the syntax in the examples might be different. You can find library-specific documentation on theSources Overviewpage.
Beyond the common fields, the Screen call takes the following fields:
Here’s a complete example of a Screen call:
Use the following interactive code pen to see what your Screen calls would look like with user-provided information:
The User ID is a unique identifier for the user performing the actions. Check out theUser ID docsfor more detail.
The Anonymous ID can be any pseudo-unique identifier, for cases where you don’t know who the user is, but you still want to tie them to an event. Check out theAnonymous ID docsfor more detail.
Note: In our browser and mobile libraries a User ID is automatically addedfrom the state stored by a previousidentifycall, so you do not need to add it yourself. They will also automatically handle Anonymous IDs under the covers.
Each screen can be tagged with aname. For example, many apps have a “Signup” screen that can be useful to tag so that you can see users as they move through your funnel.
Properties are extra pieces of information that describe the screen. They can be anything you want.
Segment has reserved some properties with semantic meanings and handles them in special ways. You shouldonly use reserved properties for their intended meaning.
Reserved properties that Segment has standardized:

Headings:
Spec: Screen
Segment University: The Screen Method
Example
Create your own Screen call
Sample Screen
Sample Screen Call
Identities
Name
Properties
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/track/
Paragraphs:
On this page
The Track API call is how you record any actions your users perform, along with any properties that describe the action.
Check out our high-level overview of the Track method in Segment University. (Must be logged in to access.)
Each action is known as an event. Each event has a name, likeUser Registered, and properties. For example, aUser Registeredevent might have properties likeplanoraccountType. Calling Track in one of oursourcesis one of the first steps to getting started with Segment.
Here’s the payload of a typical Track call with mostcommon fieldsremoved:
And here’s the corresponding JavaScript event that would generate the above payload:
Based on the library you use, the syntax in the examples might be different. You can find library-specific documentation on theSources Overviewpage.
Beyond the common fields, the Track call has the following fields:
Here’s a complete example of a Track call:
Use the following interactive code pen to see what your Track calls look like with user-provided information:
The User ID is a unique identifier for the user performing the actions. Check out theUser ID docsfor more detail.
The Anonymous ID can be any pseudo-unique identifier, for cases where you don’t know who the user is, but you still want to tie them to an event. Check out theAnonymous ID docsfor more detail.
Note: In our browser and mobile libraries a User ID is automatically addedfrom the state stored by a previousidentifycall, so you do not need to add it yourself. They will also automatically handle Anonymous IDs under the covers.
Every Track call records a single user action. Segment calls these “events”, and recommend that you make your event names human-readable, so that everyone on your team (even you, after all that caffeine) can know what they mean instantly.
Don’t use nondescript names likeEvent 12orTMDropd. Instead, use unique but recognizable names likeVideo RecordedandOrder Completed.
Segment recommends event names built from a noun and past-tense verb.For more information about best practices in event naming, check out Segment’sAnalytics Academy lesson on best practices for naming conventions for clean data.
Segment has standardized a series of reserved event names that have special semantic meaning. We map these events to tools that support them whenever possible. See theSemantic Events docsfor more detail.
Properties are extra pieces of information you can tie to events you track. They can be anything that will be useful while analyzing the events later. Segment recommends sending properties whenever possible because they give you a more complete picture of what your users are doing.
Segment has reserved some properties that have semantic meanings, and handle them in special ways. For example, we always expectrevenueto be a dollar amount that we send to tools that handle revenue tracking.
You shouldonly use reserved properties for their intended meaning.
The following are all of the reserved properties Segment has standardized that apply to all events. Check out theSemantic Events docsfor properties specific to individual reserved events.
Note:You might be used to some destinations recognizing special properties differently. For example, Mixpanel has a specialtrack_chargesmethod for accepting revenue. Luckily, you don’t have to worry about those inconsistencies. Just pass alongrevenue.Segment will handle all of the destination-specific conversions for you automatically.Same goes for the rest of the reserved properties.
All events have the ability to include additional event data in thecontextobject. There may be instances when your team may want to include user traits or group traits in a Track event, such as having a single event trigger multiple events in an Actions destination. Since user Traits are not standard fields for a Track event, in order to do this, you’ll need to explicitely pass the user’s traits into the event payload’scontext.traitsobject.For instructions on how to pass fields to the context object for a specific library, please see the related library’s Source documentation.
Segment’s Actions destinations allows your team to build individual actions that are triggered based on a set of configured conditions. By adding the user’s latest traits to the Track event’scontext.traitsobject, its possible to build two separate Actions to be triggered by this single event. For example, if your team would like to send an Identify event anytime the specific Track event “Button Clicked” is triggered, simply add the available traits into the Track event’s payload, then build a destination Actions for the Track event :Event Name is Button Clicked, and a destination Action for the Identify event :All of the following conditions are true: Event Name is Button Clicked, Event Context traits exists, and then both Actions will have access to reference thecontext.traitsfields within its mappings.
For more information on the context object, please see theSpec: Common Fieldsdocumentation.
If theExample Payloadshared above is modified as the eventButton Clickedwith"username": "testing-123"in thecontext.traitsobject, then the event’s payload would be :
Here’s what that Identify Action would look like :
Context is a dictionary of extra information that provides useful context about a datapoint, for example the user’sipaddress orlocale. You shouldonly useContext fields for their intended meaning.

Headings:
Spec: Track
Segment University: The Track Method
Example
Create your own Track call
Sample Track call
Sample Track Call
Identities
Event
Properties
Sending Traits in a Track Call - Destination Actions
Context
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/group/
Paragraphs:
On this page
The Group API call is how you associate an individual user with a group, such as a company, organization, account, project, or team.
The Group call enables you to identify what account or organization your users are part of. There are two IDs that are relevant in a Group call: theuserId, which belongs and refers to the user, and thegroupId, which belongs and refers to the specific group. A user can be in more than one group which would mean differentgroupIds, but the user will only have oneuserIdthat is associated to each of the different groups. Keep in mind that not all platforms support multiple groups for a single user.
Check out our high-level overview of these APIs in Segment University. (Must be logged in to access.)
In addition to thegroupId, which is how you’d identify the specific group or company, the group method receives traits that are specific to the group, like industry or number of employees for example, that belong to that specific account. Like the traits of an identify call, you can update these when you call the same trait with a different value.
When using the Group call, it’s helpful if you have accounts with multiple users.
Segment doesn't have an ungroup call
If you’re using a device-mode destination that has a method for ungrouping users, you can invoke it directly on the client sideusing Segment’s ready() method.
For cloud-mode destinations, you cancreate a Destination Functionto ungroup users.
Here’s the payload of a typical Group call, with mostcommon fieldsremoved:
And here’s the corresponding JavaScript event that would generate the above payload:
Based on the library you use, the syntax in the examples might be different. You can find library-specific documentation on theSources Overviewpage.
Beyond the common fields, the Group call takes the following fields:
Here’s a complete example of a Group call:
Use the following interactive code pen to see what your Group calls would look like with user-provided information:
The User ID is a unique identifier for the user performing the actions. Check out theUser ID docsfor more detail.
The Anonymous ID can be any pseudo-unique identifier, for cases where you don’t know who the user is, but you still want to tie them to an event. Check out theAnonymous ID docsfor more detail.
Note: In our browser and mobile libraries a User ID is automatically addedfrom the state stored by a previousidentifycall, so you do not need to add it yourself. They will also automatically handle Anonymous IDs under the covers.
A Group ID is the unique identifier which you recognize a group by in your own database. For example, if you’re using MongoDB it might look something like507f191e810c19729de860ea.
Traits are pieces of information you know about a group that are passed along with the Group call, likeemployeesorwebsite.
Segment has reserved some traits that have semantic meanings for groups, and handles them in special ways. You shouldonly use reserved traits for their intended meaning.
The following are the reserved traits Segment has standardized:
Note:You might be used to some destinations recognizing special properties differently. For example, Mixpanel has a specialtrack_chargesmethod for accepting revenue. Luckily, you don’t have to worry about those inconsistencies. Just pass alongrevenue.Segment handles all of the destination-specific conversions for you automatically.Same goes for the rest of the reserved properties.
If you pass these values,on nullwill throw aNullPointerException.
You may continue to set values inside the trait.  If you do so, this would work the same as the rules do with NoSQL data. If you had set a value previously for a user and on the next request you sent the same value of that property ason null, it will be replaced bynull, but if you do not send that property, the original value is persisted.
Traits are case-insensitive, so in JavaScript you can match the rest of your camel-case code by sendingcreatedAt, and in Ruby you can match your snake-case code by sendingcreated_at. That way the API never seems alien to your code base.

Headings:
Spec: Group
Segment University: The Segment Methods
Example
Create your own Group call
Sample Group call
Sample Group Call
Identities
Group ID
Traits
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/identify/
Paragraphs:
On this page
The Segment Identify call lets you tie a user to their actions and record traits about them.  It includes a unique User ID and any optional traits you know about the user, like their email, name, and more.
Check out our high-level overview of the Identify method in Segment University. (Must be logged in to access.)
Segment recommends that you make an Identify call:
The first three examples are pretty self-explanatory, but many might ask: why you would call Identify on every page load if you’re storing theuserIdin the cookie/local storage?
Calling Identify in one of Segment’slibrariesis one of the first steps to getting started with Segment. Refer to library-specific documentation for more details.
Here’s the payload of a typical Identify call with mostcommon fieldsremoved:
And here’s the corresponding JavaScript event that would generate the above payload:
Based on the library you use, the syntax in the examples might be different. You can find library-specific documentation on theSources Overviewpage.
Beyond the common fields, an Identify call has the following fields:
Note that these traits coming in from your source events are calledcustom traits.
Here’s a complete example of an Identify call:
Use the following interactive code pen to see what your Identify calls would look like with user-provided information:
The Identify call specifies a customer identity that you can reference across the customer’s whole lifetime.Every Identify call must have aUser IDor anAnonymous ID, depending on how much you know about the user in question.
There are certain cases where you don’t actually know who the user is according to your database, but you still want to be able to tie them to traits, events, or page views. For example, you may not know who a user is when tracking newsletter signups or anonymous page views.
In these cases, you should use an Anonymous ID.
The Anonymous ID can be any pseudo-unique identifier. For example, on your servers you can use a session id. If you don’t have any readily available identifier, you can always generate a new random one — Segment recommendsUUIDv4 format.
Segment’sbrowser and mobile librariesautomatically use Anonymous IDs to keep track of users as they navigate around your website or app, so you don’t need to worry about them when using those libraries.
Here’s an example of a JavaScript event for an anonymous user:
User IDs are a more permanent and robust identifier, like a database ID. Since these IDs are consistent across a customer’s lifetime, Identify calls should include a User ID as often as possible.
A User ID is usually the unique identifier that you recognize a user by in your own database. For example, if you’re using MongoDB, User IDs might look something like this:507f191e810c19729de860ea.
Segment recommends using database IDs,inuuidv4format, instead of email addresses or usernames because database IDsneverchange. That guarantees that even if the user changes their email address, you can still recognize them as the same person in all of your analytics tools, and you’ll be able to correlate analytics data with your own internal database.
Instead of using an email address or a username as a User ID, send them along ascustom traits.
Custom traitsare pieces of information you know about a user that are included in an Identify call. These could be demographics likeageorgender, account-specific likeplan, or even things like whether a user has seen a particular A/B test variation.
Segment has reserved some custom traits that have semantic meanings for users, and will handle them in special ways. For example, Segment always expectsemailto be a string of the user’s email address. Segment sends this on to destinations likeMailchimpthat require an email address for their tracking.
Only use reserved traits for their intended meaning.
Reserved custom traits Segment has standardized:
You might be used to some destinations recognizing special traits by slightly different names. For example, Mixpanel recognizes a$createdtrait when the user’s account was first created, while Intercom recognizes the same trait ascreated_atinstead. Segment attempts to handle all the destination-specific conversions for you automatically. If you need help understanding if a specific field will be converted to a destination, take a look at Segment’sopen source integration code, view the destination’s documentation, orcontact Segment support.
You can pass these reserved traits using camelCase or snake_case, so in JavaScript you can match the rest of your camelCase code by sendingfirstName, while in Ruby you can match your snake-case code by sendingfirst_name. That way the API never seems alien to your code base. Keep in mind that not all destinations support these reserved traits, so sending these traits in camelCase and snake_case can result in two sets of traits in other destinations.

Headings:
Spec: Identify
Segment University: The Identify Method
Example
Create your own Identify call
Sample Identify
Sample Identify Call
Identities
Anonymous ID
User ID
Custom traits
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/alias/
Paragraphs:
On this page
The Alias method is an advanced method used to merge 2 unassociated user identities, effectively connecting 2 sets of user data in one profile.
Alias and Unify
Alias calls can’t be used to merge profiles inUnify. For more information on how Unify merges user profiles, view theIdentity Resolution documentation.
Alias is an advanced method
The Alias method allows you to explicitly change the ID of a tracked user. This should only be done when it’s required for downstream destination compatibility. See theBest Practices for Identifying Usersdocs for more information.
The Alias call has the following fields:
The Alias method follows the format below:
Here’s the payload of a basic Alias call that will associate this user’s existingid(email address) with a new one (a database ID), with mostcommon fieldsremoved:
Here’s the corresponding JavaScript event that would generate the above payload. If you’re using Segment’s JavaScript library, Segment automatically passes in the user’sanonymousIdaspreviousIdfor you:
If you’re instrumenting a website, the Anonymous ID is generated in the browser so you must call Alias from the client-side. If you’re using a server-side session ID as the Anonymous ID, then you must call Alias from the server-side.
Based on the library you use, the syntax in the examples might be different. You can find library-specific documentation on theSources Overviewpage.
Here’s a complete example of an Alias call:

Headings:
Spec: Alias
Syntax
Examples
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/copilot/
Paragraphs:
On this page
This page is a guide for developers who want to track interactions with AI copilots using Segment. It explains what data to send to Segment, letting you understand customer interactions with AI copilots.
AI copilots are like virtual assistants that help customers in conversations.
Each conversation starts when a customer sends their first message or question. Throughout the conversation, Segment can track various events that capture key moments, like messages sent and received, tools invoked, and media generated.
While some copilot conversations have clear ending points, which occur when the customer explicitly indicates that the conversation is over, the tracked events provide valuable insights into the entire conversation flow.
In this section, you’ll find the tracked semantic events that serve as a starting point for AI copilot events. You can extend them based on your own requirements.
This table lists the events that you can track from any conversation:
Segment can also track the following live chat events:
This section contains the structure and properties of each AI copilot tracked event.
The Conversation Started event should be sent when a customer sends their first message.
This event supports the following semantic properties:
Here’s an example of a Conversation Started call:
The Message Sent event should be sent when a user adds a new message to a thread. The default forroleis"customer".
This event supports the following semantic properties:
Here’s an example of a Message Sent call:
The Message Received event should be sent when the copilot gives a non-custom response (either text or voice) to something the user asked.
The default forroleis"agent". You can extendroleto different agent type, likeai_agent,human_agent,task_automation_agent, and so on.
This event supports the following semantic properties:
The Conversation Ended event should be sent when a customer or agent explicitly indicates that the conversation has ended or deletes the chat.
This event supports the following semantic property:
Here’s an example of a Conversation Ended call:
The Action nvoked event should be sent when the copilot or user uses a custom capability or tool, like making a call to an external API.
This event supports the following semantic properties:
Here’s an example of an Action Invoked call:
This event should be sent when an image, video, or custom audio is generated by the model.
This event supports the following semantic properties:
Here’s an example of a Media Generated call:
This event should be sent when a new, custom component is shown to the user that isn’t text or voice.
This event supports the following semantic properties:
Here’s an example of a Component Loaded call:
This event should be sent when a user rates a conversation or message.
This event supports the following semantic properties:
Here’s an example of a Feedback Submitted call:
This event should be sent when a new user is identified, either anonymously or as a known user.
This event supports the following semantic properties:
Here’s an example of an Identify call:
When sending events to Segment based on user actions, like items purchased or support requested, make sure to include relevant identifiers for accurate tracking and analysis.
These identifiers includeconversationIdandmessageId, among others, depending on the specific tracked action:
For example, to track an event where a user makes a purchase, the standard Track call could look like this:

Headings:
Spec: AI Copilot
Overview
Tracked events
Live chat events
Event details
Conversation Started
Message Sent
Message Received
Conversation Ended
Action Invoked
Media Generated
Component Loaded
Feedback Submitted
Identify
Standard Track calls
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/common/
Paragraphs:
On this page
In the SegmentSpecall theAPI callshave a common structure, and a few common fields.
However, not all destinations accept all fields included in the Spec. Not sure which fields a destination accepts? Refer to the destination’s documentation page, or check out theopen-source destination code on GitHub.
Check out our high-level overview of these APIs in Segment University. (Must be logged in to access.)
Every API call has the same core structure and fields. These fields describe user identity, timestamping, and mechanical aides like API version.
Here’s an example of these common fields in raw JSON:
In more detail these common fields for every API call are:
Beyond this common structure, each API call adds a few specialized top-level fields.
Context is a dictionary of extra information that provides useful context about a datapoint, for example the user’sipaddress orlocale. You shouldonly useContext fields for their intended meaning.
Below is a chart that shows you which context variables are populated automatically by the iOS, Android, and analytics.js libraries.
Other libraries only collectcontext.library, any other context variables must be sent manually.
IPv6
Segment doesn’t support automatically collecting IPv6 addresses.
The Android library collectsscreen.densitywiththis method.
userAgentData is only collected if theClient Hints APIis available on the browser.
Segment doesn’t collect or append to the context of subsequent calls in the new mobile libraries (Swift, Kotlin, and React Native).
To pass the context variables which are not automatically collected by Segment’s libraries, you must manually include them in the event payload. The following code shows how to passgroupIdas the context field of Analytics.js’s.track()event:
To add fields to the context object in the new mobile libraries, you must utilize a custom plugin. Documentation for creating plugins for each library can be found here:
A dictionary of destination names that the message should be sent to.'All'is a special key that applies when no key for a specific destination is found.
Integrations defaults to the following:
This is becauseSalesforcehas strict limits on API calls.
Sending data to the rest of Segment’s destinations is opt-out so if you don’t specify the destination as false in this object, it will be sent to rest of the destinations that can accept it.
Every API call has four timestamps,originalTimestamp,timestamp,sentAt, andreceivedAt.They’re used for very different purposes.
All timestamps areISO-8601date strings, and are in the UTC timezone.To see the user’s timezone information, check thetimezonefield that’s automatically collected byclient-side libraries.
You must use ISO-8601 date strings that include timezones when you use timestamps withEngage. If you send custom traits without a timezone, Segment doesn’t save the timestamp value.
TheoriginalTimestamptells you when call was invoked on the client device or the value oftimestampthat you manually passed in.
Note:TheoriginalTimestamptimestamp is not useful for any analysis since it’s not always trustworthy as it can be easily adjusted and affected by clock skew.
ThesentAttimestamp specifies the clock time for the client’s device when the network request was made to the Segment API. For libraries and systems that send batched requests, there can be a long gap between a datapoint’stimestampandsentAt. Combined withreceivedAt, Segment usessentAtto correct the originaltimestampin situations where a user’s device clock cannot be trusted (mobile phones and browsers). ThesentAtandreceivedAttimestamps are assumed to occur at the same time (maximum a few hundred milliseconds), and therefore the difference is the user’s device clock skew, which can be applied back to correct thetimestamp.
Note:ThesentAttimestamp is not useful for any analysis since it’s tainted by user’s clock skew.
Segment now adds `sentAt` to a payload when the batch is complete and initially tried to the Segment API for the Swift, Kotlin, and C# mobile libraries
This update changes the value of the Segment-calculatedtimestampto align closer with thereceivedAtvalue rather than theoriginalTimestampvalue. For most users who are online when events are sent, this does not significantly impact their data. However, if your application utilizes an offline mode where events are queued up for any period of time, thetimestampvalue for those users now more closely reflects when Segment received the events rather than the time they occurred on the users’ devices.
ThereceivedAttimestamp is added to incoming messages as soon as they hit the API. It’s used in combination withsentAtto correct clock skew, and also to aid with debugging libraries and systems that deliver events in batches.
ThereceivedAttimestamp is most important as the sort key in Segment’s Warehouses product. Use this for max query speed when retrieving data from your Warehouse.
Note:Chronological order of events is not ensured withreceivedAt.
Thetimestamptimestamp specifies when the data point occurred, corrected for client-device clock skew. This is the timestamp that is passed to downstream destinations and used for historical replays. It is important to use this timestamp for importing historical data to the API.
If you are using the Segment server Source libraries, or passing calls directly to the HTTP API endpoint, you can manually set thetimestampfield. This change updates theoriginalTimestampfield of the Segment event. If you use a Segment Source in device mode, the library generatestimestampand you cannot manually set one directly in the call payload.
Segment calculatestimestampastimestamp = receivedAt - (sentAt - originalTimeStamp).
For client-side tracking it’s possible for the client to spoof theoriginalTimeStamp, which may result in a calculatedtimestampvalue set in the future.
If you’re using one of Segment’s client-side libraries, please note that several factors can cause timestamp discrepancies in your event data.

Headings:
Spec: Common Fields
Segment University: The Segment Methods
Structure
Context
Context fields automatically collected
Integrations
Timestamps
Timestamp overview
originalTimestamp
sentAt
receivedAt
timestamp
FAQ
Why Are Events Received with Timestamps Set in the Past or Future?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/mobile/
Paragraphs:
On this page
One of the core components of the SegmentSpecis theTrackmethod. It records any arbitrary event that the user has triggered. For Mobile tracking, in addition to Screen calls, you’ll want to sendspecific event namesthat Segment recognizes semantically. That way, Segment can transform them correctly before sending them off to downstream destinations.
By standardizing the events that comprise the coremobile application lifecycleand associatedmobile campaign and referral events, Segment and its partners can, wherever possible, forward these events on your behalf and build downstream destinations that take full advantage of the semantic meaning associated with these events and their properties.
If you’re already collecting similar events, Segment recommends migrating to these event names so that you can take advantage of available features in Segment destinations that depend on the spec as they become available.
These events pair nicely with Segment’secommerce specfor mobile marketplaces to take full advantage of features like dynamic ads in Facebook and the ability to take full advantage of server-side destinations with Mobile Attribution Platforms likeTuneandKochava.
Per thePrivacy Policyand applicable terms, don’t send Segment sensitive personal information about your users. Certain features from Segment and its partners allow you to opt-in to automatically track data (for example: Application Installed or Deep Link Clicked). When working with these features and Segment in general, be cognizant of the data that is being tracked to ensure its matching both your obligations under your agreement with Segment and the privacy expectations of your users.
The Segment Native Mobile Spec includes the following semantic events:
Application Lifecycle Events
Campaign Events
Segment recommends using the above event names if you’re going to be integrating the events yourself. This will ensure that they can be mapped effectively in downstream tools.
Mobile applications live within a fairly bounded lifecycle. To understand and communicate effectively with your users, it’s crucial to instrument the core flows associated with installing and opening your app. The following events allow you to get a picture of top-line metrics such as DAUs, MAUs, and Screen Views per session. Automatic lifecycle event tracking is optional - you can learn how to enable and disable them in Segment’s docs for each library below:
The following events will be tracked automatically when lifecycle events are enabled in all mobile libraries:
In Kotlin, Swift, and React Native, the following additional events are tracked:
In Swift, the following event is also tracked:
This event fires when a userfirstopens your mobile application. Note, if the user never opens your app after installing, Segment will not collect this event. This event doesn’t wait for attribution or campaign information to be received, and is collected automatically by Segment’s SDKs. Advertising providers like Facebook and Google require discrete install events to correctly attribute installs to ads served through their platform.
This event fires when a user launches or foregrounds your mobile application after the first open. It will fire after theApplication Installedevent and again after the app is re-opened after being closed. This event does not wait for attribution information to be received but may include information about referring applications or deep link URLs if available to the application upon open.
This event should be sent when a user backgrounds the application uponapplicationDidEnterBackground.
This event is fired when a user opens the app or brings it back into the foreground of their device. This is only collected by the Swift library.
This event fires when a user updates the application. Segment’s SDK will automatically collect this event instead of an “Application Opened” event when we determine that the Open is first since an update.
Fire this event when a user uninstalls the application. Some destination partners will detect this for you using Silent Push Notifications through their SDK. You might be able to send these events to Segment using a callback. Visit the partner docs to see if this is available.
You can send this event when you receive a crash notification from your app, but it is not meant to supplant traditional crash reporting tools. By tracking crashes as an analytics event with device and user information, you can analyze the which types of users are impacted by crashes and how those crashes, in turn, affect their engagement. You may also want to target those customers with tailored communications in other channels if they’ve encountered several crashes. Segment does not collect this event. To capture the event, use a destination that collects this data and route that event back to Segment through a webhook or some other callback.
As the walls between apps become increasingly lowered, capturing information about the content and campaigns that drive users to engage with your app is critical to building more targeted, relevant, personalized experiences for your users.
Segment does not collect any campaign events automatically unless configured to do so.
When Segment or an integrated partner can discern the source of an install, we’ll collect anInstall Attributedevent. This event may be sent to Segment using server-to-server connection from your attribution provider, or directly on the device using packaged destinations. In either case, this will happenafterinstall, and does not apply to all installs, which is why it is a discrete event.
This event can be sent when a push notification is received in the app. It can be automatically enabled oniOS.
This event can be sent when a user taps on a push notification associated with your app. It can be automatically enabled oniOS.
This event fires when a push notification from a provider bounces. If your push notification provider forwards push lifecycle events to Segment, they should include this event in their suite.
When your application is opened using a referring link, Segment or your packaged deep link partner can fire this event on your behalf. If the deep link has additional data associated with it, either passed through the third party service or asannotationsinlaunchOption, you may want to include those values as properties here as well.
This event is firedin additionto the associatedApplication Openedevent.
This event may be provided by deep link providers postback mechanisms or an internal redirect service if you use one in order to provide a waypoint funnel step between your content or advertisement and the resulting app open.

Headings:
Native Mobile Spec
Overview of events
Lifecycle events
Application Installed
Application Opened
Application Backgrounded
Application Foregrounded
Application Updated
Application Uninstalled
Application Crashed
Campaign events
Install Attributed
Push Notification Received
Push Notification Tapped
Push Notification Bounced
Deep Link Opened
Deep Link Clicked
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/native-mobile-spec/
Paragraphs:
TheNative Mobile Specis a common blueprint for the mobile user lifecycle. The Spec outlines the most important events for mobile apps to be tracking and automatically collects many of these events with the Segment Android and iOS SDKs.
This article outlines common questions about our Native Mobile Spec. To learn what the benefits are of the feature, check out ourblog. For technical set up and documentation, see ourspec docs.
Smaller SDK: Move more destinations to the server-side, including the Facebook App Events destination.
Less engineering time: Automatically collect key user events instead of coding them in yourself.
Faster time to value: Set up your destinations with key metrics like Daily Active Users, sessions, and in-app purchases right away!
Measure ROI of campaigns: Analyze campaign performance with spec’d events like “campaign hit”, “install attributed” and “push notification opened” in your favorite analytics or BI tool.
OurFacebook App Eventscloud-mode destination currently takes advantage of the “Application Installed” event to power new features like custom audience creation, dynamic ads and conversion tracking, without needing to sit on the device. Soon, more destinations like Google Adwords and Salesforce Marketing Cloud and attribution providers will offer similar functionality.
When an engineer installs the SDK, the SDK will automatically register on iOS and Android operation system handlers.
When the application is foregrounded on the phone, our SDK will be called and emit the Application Opened event. Similarly, when the user updates the app, on the next app open, the iOS and Android operation system will tell us and we’ll emit a track event called Application Updated event. In-app purchases will trigger Order Completed, etc.
This feature is opted out by default. You have to opt in to collect these events as mentioned in our Quick Start guides (iOS,Android). You’ll be doing this in code by altering the configuration you pass into the SDK initialization methods (telling the SDK to collect these events automatically).
Yes, they will be double counted, but that’s only if you opt into this feature. You can either remove your own tracking code for these events or not opt into auto collection at all.
Yes. If you follow the Spec when you write your own custom events, you will be able to take advantage of certain features in downstream destinations on the server-side, like with ourFacebook App Events destination.
We recommend migrating to these event names if you’re tracking similar events so that you can take advantage of available features in our integrations which will depend on the spec as they become available.
Not currently.
Not currently.Contact usfor alternative options.
You can, but the sooner you switch to the spec’d events, the further back you’ll be able to look in your reporting with the same event name!
In the coming months, we’ll be updating our mobile marketing destinations to automatically capture campaign events around attribution, deep linking, and push notifications. These events will go todestinations, includingwarehouses.
Android applications can’t receive Push Notifications when the process is not running, and when apps are put into background they are eligible to have their Process killed when there is memory pressure. For more more on Android processes, view Android’sProcesses and app lifecycle documentation.
Segment tracks messages delivered to the application. So if the process has been killed for any reason, messages won’t be delivered.
Firebase Cloud Messaging (FCM) has its own servers. When an FCM message is created and sent to a device, that message travels through FCM servers and is delivered to the local FCM client device that is part of Android OS. This FCM client is almost always running, even when the app is backgrounded. From there, the FCM message is intended to be delivered to a local application. If the app process is running, the message gets delivered. Otherwise, the user must tap a notification that starts the app and delivers the FCM message.

Headings:
What is the native mobile spec?
How does the Native Mobile Spec help me?
Which destinations currently take advantage of the mobile spec?
How does all of this work?
How do I opt-in to the new feature?
What happens if I’m already tracking these events? Will they be double counted?
Do I still benefit from this new SDK if I opt out of automatic tracking?
Will I need to change the names of the events I am currently tracking?
Can I send custom properties inside of automatic events?
Is there a way to link the old event name with the new event name?
Can I do this later?
How will I be able to take advantage of new campaign events?
Why don’t Push Notification events reach Segment when my Android App is backgrounded?
Why do Push Notifications work with Firebase Cloud Messaging when the app is backgrounded?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/mobile-packaging-sdks/
Paragraphs:
When it comes to Mobile SDKs, we know that minimizing size and complexity is a priority for our customers. That’s why our core Mobile SDKs are small and offload as much work as possible in handling destinations to our servers. When you install our light-weight SDK, you have access to our entire suite of server-side destinations.
We bundle certain SDKs, instead of just proxying your data to them through our servers, so that you have access to their deeper features that requires direct client manipulation (A/B testing, user surveys, touch heatmapping, etc) or access to rich data such as CPU usage, network data, or raised exceptions. For those types of features, we still need to bundle their native SDK for you so you can make the most of them.
We’ve worked hard to make our mobile SDKs as modular as possible so that you only need to include the SDKs for tools you plan to use.
Custom builds allow us to offer the native functionality of all of our destinations without having to include hefty third-party SDKs by default. This gives you control over size and method bloat. Check out how to use custom builds for bothAndroidandiOS.
To check if a destination is bundled or not, take a look at ourdocumentationfor that specific destination.

Headings:
Packaging SDKs for Mobile Destinations
Why do some destinations require bundling their SDKs?
Which SDKs are bundled?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/semantic/
Paragraphs:
One of the core components of the SegmentSpecis theTrackcall. It describes any arbitrary event that the user has triggered. For some industry verticals and applications, Segment has standardized event names. For Ecommerce tracking, for example, there arespecific event names and propertiesthat we recognize semantically. This semantic meaning allows Segment to specially recognize and transform key events before sending them off to each different tool.
There are a few places where Segment has standardized event names and properties already:
In the future Segment plans to standardize event names from other data sources as well.

Headings:
Spec: Semantic Events
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/b2b-saas/
Paragraphs:
On this page
This guide explains how B2B SaaS companies should send core user and account lifecycle data to Segment.
Most B2B SaaS companies have a few common, core lifecycle events for users and accounts. We understand that account hierarchies can be unique and complex, but by following this spec you can take advantage of account-based tools on Segment platform, and B2B SaaS data products by Segment.
The B2B SaaS category has the following semantic events:
This event should be sent when a new account is created.
This event supports the following semantic properties:
This event should be sent when an account is deleted.
This event supports the following semantic properties:
This event should be sent when a user signs up for your service.
Good to know: Segment’s best practice is to use an “Object-Action” naming convention, which in this case would be “User Signed Up”. However, because in the B2B case this may not be a specific user, we omit that noun in our example. You may include or omit it as needed for your implementation.
This event supports the following semantic properties:
This event should be sent when a user signs in to your service.
Good to know: Segment’s best practice is to use an “Object-Action” naming convention, which in this case would be “User Signed In”. However, because in the B2B case this may not be a specific user, we omit that noun in our example. You may include or omit it as needed for your implementation.
This event supports the following semantic properties:
This event should be sent when a user signs out for your service. You should also callanalytics.reset()to refresh the cookie when a Signed Out event occurs.
Good to know: Segment’s best practice is to use an “Object-Action” naming convention, which in this case would be “User Signed Out”. However, because in the B2B case this may not be a specific user, we omit that noun in our example. You may include or omit it as needed for your implementation.
This event supports the following semantic properties:
This event should be sent when a user invites another user.
This event supports the following semantic properties:
This event should be sent when a user is added to a group.
This event supports the following semantic properties:
This event should be sent when a user is removed from a group or account.
This event supports the following semantic properties:
This event should be sent when a trial is started.
This event supports the following semantic properties:
This event should be sent when a trial ends.
This event supports the following semantic properties:
This page was last modified: 19 Jul 2022
Questions? Problems? Need more info? Contact Segment Support for assistance!

Example
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/ecommerce/v2/
Paragraphs:
On this page
Segment’s e-commerce spec helps define the journey for a customer as they browse your store, click on promotions, view products, add those products to a cart, and complete a purchase.
Note
Not all destinations support every event listed here and accept arrays as properties. Refer to individual destination documentation for more information on supported events and properties.
Here is a list of supported events for our various categories within the customer journey.
The following sections list more detail for each lifecycle event as well as an example API call.
Browsing lifecycle events represent key events that a customer might have while browsing your apps.
Fire this event when a visitor searches for products.
This event supports the following semantic properties:
Example:
Fire this event when a visitor views a product list or category.
Note
Not all destinations accept arrays as properties. Refer to individual destination documentation for more information on supported events and properties.
This event supports the following semantic properties:
Example:
Note
TheProduct List Viewedevent is aliased to theViewed Product Categoryevent (from e-commerce v1 spec).
Send this event when a visitor filters a product list or category.
Note
Not all destinations accept arrays as properties. Refer to individual destination docs for more information on supported events and properties.
This event supports the following semantic properties:
Example:
Promotion view and click events help you gather analytics on internal offers within your web or mobile app. For example, when a banner advertisement is shown in your web or app’s home page, you can fire aViewed Promotionevent. If the user proceeds to click the advertisement, fire theClicked Promotionevent.
Fire this event when a user views a promotion.
This event supports the following semantic properties:
Example:
Note
ThePromotion Viewedevent is aliased to theViewed Promotionevent.
Fire this event when a visitor clicks an internal offer promotion.
This event supports the following semantic properties:
Example:
Note
ThePromotion Clickedevent is aliased to theClicked Promotionevent.
These events represent the customer journey in regards to product ordering.
Fire this event when a visitor clicks a product.
This event supports the following semantic properties:
Example:
Note
Fire this event when a visitor views a product. That view might happen on a page, screen, or preview modal.
This event supports the following semantic properties:
Example:
Note
Fire this event when a visitor adds a product to their shopping cart.
This event supports the following semantic properties:
Example:
Note
Fire this event when a visitor removes a product from their shopping cart.
This event supports the following semantic properties:
Example:
Note
Fire this event when a visitor views a shopping cart.
Note
Not all destinations accept arrays as properties. Refer to individual destination documentation for more information on supported events and properties.
This event supports the following semantic properties:
Example:
Fire this event whenever an order/transaction was started. Fire on the page that the customer lands on after they press the checkout button.
Note
Not all destinations accept arrays as properties. Refer to individual destination documentation for more information on supported events and properties.
Be sure toinclude all items in the cart as event properties, with the same properties from the previous calls, like so:
This event supports the following semantic properties:
Example:
Note
Fire this event whenever a checkout step is viewed.
This event supports the following semantic properties:
Example:
Note
shipping_methodandpayment_methodare semantic properties. If you want to send that information, do so in this exact spelling.
You can have as many or as few steps in the checkout funnel as you’d like. Note that you’ll still need to track theOrder Completedevent per Segment’s standarde-commerce tracking APIafter you’ve tracked the checkout steps.
Note
TheCheckout Step Viewedevent is aliased to theViewed Checkout Stepevent fromSegment’s GA Enhanced E-Commerce destinations.
Fire this event whenever a checkout step is completed.
This event supports the following semantic properties:
Example:
Note
shipping_methodandpayment_methodare semantic properties. If you want to send that information, do so in this exact spelling.
You can have as many or as few steps in the checkout funnel as you’d like. Note that you’ll still need to track theOrder Completedevent per Segment’s standarde-commerce tracking APIafter you’ve tracked the checkout steps.
Note
TheCheckout Step Completedevent is aliased to theCompleted Checkout Stepevent fromSegment’s GA Enhanced E-Commerce destinations.
Fire this event whenever payment information has been successfully entered.
This event supports the following semantic properties:
Example:
Note
shipping_methodandpayment_methodare semantic properties. If you want to send that information, do so in this exact spelling.
You can have as many or as few steps in the checkout funnel as you’d like. Note that you’ll still need to track theOrder Completedevent per Segment’s standarde-commerce tracking APIafter you’ve tracked the checkout steps.
Fire this event whenever an order/transaction was updated.
Note
Not all destinations accept arrays as properties. Refer to individual destination documentation for more information on supported events and properties.
Be sure toinclude all items in the cart as event properties, with the same properties from the previous calls, like so:
This event supports the following semantic properties:
Example:
Note
Fire this event whenever an order/transaction was successfully completed by the customer.
Note
Not all destinations accept arrays as properties. Refer to individual destination documentation for more information on supported events and properties.
Be sure toinclude all items in the cart as event properties, with the same properties from the previous calls, like so:
This event supports the following semantic properties:
Example:
Note
Fire this event whenever an order/transaction was refunded.
Be sure toinclude all items in the cart as event properties, with the same properties from the previous “Order Completed” call.
This event supports the following semantic properties:
Example:
Note
Theskuandproduct_iddon’t have to be different. If they are different, typically theproduct_idis a database identifier, like9714107479and theskuis a public-facing identifier likeSEG-02.
Fire this event whenever an order/transaction was cancelled.
Note
Not all destinations accept arrays as properties. Refer to individual destination documentation for more information on supported events and properties.
Be sure toinclude all items in the cart as event properties, with the same properties from the previous calls.
This event supports the following semantic properties:
Example:
Note
Theskuandproduct_iddon’t have to be different. If they are different, typically theproduct_idis a database identifier, like9714107479and theskuis a public-facing identifier likeSEG-02.
These are events that might occur when dealing with coupons in your ecommerce.
Fire this event whenever a coupon is entered either on a cart or on an order/transaction.
This event supports the following semantic properties:
Example:
Note
This has no effect in GA enhanced e-commerce, as that destination pulls from thecouponfield on the order events. Refer to Segment’sGoogle Analytic documentationfor more information.
Fire this event whenever a coupon is successfully applied to either a cart or an order/transaction.
This event supports the following semantic properties:
Example:
Note
This has no effect in GA enhanced e-commerce, as that destination pulls from thecouponfield on the order events. Refer to Segment’sGoogle Analytic documentationfor more information.
Fire this event whenever a coupon is denied from either a cart or an order/transaction.
This event supports the following semantic properties:
Example:
Note
This has no effect in GA enhanced e-commerce, as that destination pulls from thecouponfield on the order events. Refer to Segment’sGoogle Analytic documentationfor more information.
Fire this event whenever a coupon is removed from either a cart or an order/transaction.
This event supports the following semantic properties:
Example:
Note
This has no effect in GA enhanced e-commerce, as that destination pulls from thecouponfield on the order events. Refer to Segment’sGoogle Analytic documentationfor more information.
These events may occur if your ecommerce supports wishlist features.
Fire this event when a customer adds a product to their wish list.
This event supports the following semantic properties:
Example:
Note
Theskuandproduct_iddo not have to be different. If they are different, typically theproduct_idis a database identifier, like9714107479and theskuis a public-facing identifier likeSEG-02.
Fire this event when a customer removes a product from their wish list.
This event supports the following semantic properties:
Example:
Note
Theskuandproduct_iddon’t have to be different. If they are different, typically theproduct_idis a database identifier, like9714107479and theskuis a public-facing identifier likeSEG-02.
Fire this event when a customer moves a product from their wish list to their cart.
This event supports the following semantic properties:
Example:
Note
Theskuandproduct_iddon’t have to be different. If they are different, typically theproduct_idis a database identifier, like9714107479and theskuis a public-facing identifier likeSEG-02.
With many ecommerce stores integrating with social apps or other sharing capabilities, these events might be useful if you are tracking customers sharing product information.
Fire this event when a customer shares a product.
This event supports the following semantic properties:
Example:
Note
Theskuandproduct_iddon’t have to be different. If they are different, typically theproduct_idis a database identifier, like9714107479and theskuis a public-facing identifier likeSEG-02.
Fire this event when a customer shares a shopping cart.
Note
Not all destinations accept arrays as properties. Refer to individual destination docs for more information on supported events and properties.
This event supports the following semantic properties:
Example:
These events can be useful for tracking product related reviews.
Fire this event when a customer reviews a product.
This event supports the following semantic properties:
Example:

Headings:
Spec: V2 Ecommerce Events
Event lifecycles
Browsing overview
Promotions overview
Core ordering overview
Coupons overview
Wishlisting overview
Sharing overview
Reviewing overview
Browsing
Products Searched
Product List Viewed
Product List Filtered
Promotions
Promotion Viewed
Promotion Clicked
Core Ordering
Product Clicked
Product Viewed
Product Added
Product Removed
Cart Viewed
Checkout Started
Checkout Step Viewed
Checkout Step Completed
Payment Info Entered
Order Updated
Order Completed
Order Refunded
Order Cancelled
Coupons
Coupon Entered
Coupon Applied
Coupon Denied
Coupon Removed
Wishlisting
Product Added to Wishlist
Product Removed from Wishlist
Wishlist Product Added to Cart
Sharing
Product Shared
Cart Shared
Reviewing
Product Reviewed
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/ecommerce-tracking-plan/
Paragraphs:
On this page
When tracking your data, it’s important to set yourself up for success. E-commerce and retail companies want to use their data to understand why some customers fall out of their funnels or why customers become repeat buyers. They want to understand the important lifecycle events that lead up to the sale of a physical item, so they can, for example, test whether personalized shopping experiences yield higher conversions, or build a multi-channel cart abandonment campaign. But first, they need to make sure those lifecycle events are being captured in their datasets.
That’s where a tracking plan comes in. A tracking plan is a living document that can be used across your organization to record what events and properties to track, where you’ll be tracking them in your code base, and why you’re tracking them.
Learn more about the value and function of a tracking plan.
In this guide, you’ll learn the core events most relevant to e-commerce companies that can get you started immediately in understanding your customers and driving sales.
Talk to a product specialist todayabout building a clean, high-quality data spec so you can focus on brand engagement and sales growth.
Before diving into specific event tracking, you’ll want to make sure you track who your users are with the the.identify()call. You should call.identify()whenever a visitor provides you with a piece of information, at which point they become “known users.” The.identify()call creates or updates a record of your customer with a set of traits in your tools and warehouse. But how do you choose which traits about your user to include?
Traits are pieces of data that you track about a specific user. Read the guide about selecting traits to learn more.
Here are the most common user traits e-commerce companies include in their tracking:
Here are a few examples of other helpful user traits:
Here is a sample.identify()call for Segment:
In analytics.js:
In analytics-ios:
In analytics-android:
The main benefits of using the traits listed above are:
You can use the traits to personalize content in your email or push notification tools by inserting their information. For example:
You can create cohorts based on the traits in any of your tools. For example, you could useorder_countto determine how many of your users are first or repeat, orexperimentsto determine how many have seen this particular experiment variant
Given the power you have in your downstream tools to create cohorts based on these dimensions, you may be tempted to throw more contextual data into thetraits, such as UTM params, IP addresses, and userAgents. But if you’re using Segment’s client-side analytics.js library, then all of these contextual pieces of data are automatically collected.
Now that you are tracking who your users are, you can work on what they’re doing on your website or in your app with a.track()call. Tracking customer events lets you learn about your customers, measure the impact of your marketing efforts and product decisions, and proactively engage your customers in a meaningful way that drives sales.
Read the event tracking guide to learn more about tracking the right events.
E-commerce businesses, unlike SaaS or consumer apps that optimize for product engagement, focus on directing users down their funnels to a conversion goal, like purchasing a product. To best understand why customers convert, it’s important to track and measure all key funnel events.
There are also auxiliary actions to track to measure your customer’s engagement with your site. These actions are good to track so you can better understand their intent on your website.
Lastly, Segment has a set of semantic campaign events that are automatically collected so you can understand the conversions in these specific channels:
Check out the full list of e-commerce events you should track.
You may notice a pattern in the event names. Segment selected the “Object Action” naming convention to ensure that all event data is clean and easily analyzable, while choosing “snake_case” for the traits and properties. It doesn’t matter what you choose, so long as it’s consistent. Without a uniform and enforced naming framework to guide developers that add tracking code later, your data could get marred with conflicting naming structures. Learn more about the importance of naming conventions.
Segment recommends tracking core checkout activity on the server-side. Learn more abouttracking on the client vs. server.
Properties are similar to traits, but they’re associated with specific actions, rather than with an individual user. Each.track()call can accept an optional dictionary ofproperties, which can contain any key-value pair you want. Thesepropertiesact as dimensions that allow your end tool to group, filter, and analyze the events. They give you additional detail on broader events.
Learn more about properties and what they mean for your downstream analysis.
For e-commerce, since most events are customers choosing, browsing, and checking out products, all of the traits must contain key information about the products themselves:
These traits must be included because many tools rely on them for analysis. If there was one of them missing, the call would be ignored.
Using a specific tool and want to see how Segment handles sending calls to it?Check out the documentation.
Here is an example.track()call:
In analytics-node:
In analytics-ios
In analytics-android:
It’s important that these events contain particular properties, such assku, otherwise the downstream tools won’t be able to create out-of-the-box revenue and sales reports. Learn more about semantic properties in the e-commerce spec.
The most successful e-commerce businesses not only efficiently move their customers through the funnel towards conversion, but also have the infrastructure to collect and use customer data. Having a tracking plan focused on key funnel events can help e-commerce businesses get a sense of the health of their funnel.
Aside from funnel health, having these key pieces of customer data gives companies the ability to tailor and personalize each interaction, as well as build marketing campaigns around actions taken or omitted.
Without taking this critical step of mapping out key customer events, businesses often spend too much time revisiting their data model or analyzing impartial data sets. Instead they could spend that time understanding and addressing customers’ needs.
Talk to a product specialist todayabout building a clean, high-quality data spec so you can focus on brand engagement and sales growth.

Headings:
Ecommerce Tracking Plans
Identifying your customers
Selecting key e-commerce and marketing events
Selecting your properties
Using data to understand why your customers don’t convert
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/video/
Paragraphs:
On this page
Segment’s video spec helps you define how customers engage with your video and ad content. This document covers the naming syntax and conventions for how you should send events when tracking video analytics.
Note:not all destinations support video tracking, and you should always check with the individual destination documentation to confirm.
Before you start implementing the Segment video spec, you should understand the overall structure and classification of events. The video spec will be organized intothreedistinct event categories:
You can think of playback events being related to the actualplaybackof the video content. This means that these events are meant to track information about the video player (such as pause, resume, or play). Thus, you can think of playback events to be at the session level. For example, when a customer presses play on your video, you would start by sending aVideo Playback Startedevent with a uniquesession_id. In particular, this event should fire after the last user action required for playback to begin.
Then, for the duration of that user’s session with that specific video player, all
subsequent events generated from this session/playback should be tied with the same aforementionedsession_id. So if you had a web page that had two video players, you would have two separate sessions andsession_idswhile contrastingly if you only had one video player on the page but the playback played two video contents in a row, you would only have one session but two contents tied to it.
All playback events share the same event properties that describe information about the current state of the player. Below is a table of the supported properties of this object.
Below is the full list of Video Playback Events.
When a user presses Play; after the last user action required for playback to begin (for example, after user login/authentication).
When a user presses Pause.
When the playback stops unintentionally (such as from network loss, browser close/redirect, or app crash). With this event you can passmethodas a property to denote the cause of the interruption.
When playback starts buffering content or an ad.
When playback finishes buffering content or an ad.
When a user manually seeks a certain position of the content or ad in the playback. Pass in theseek_positionto denote where the user is seeking to, and pass in thepositionproperty to denote where the user is seeking from.
After a user manually seeks to a certain position of the content or ad in the playback. Pass in thepositionproperty to denote where the user desires to begin the playback from.
When playback is resumed, by the user, after being paused.
When playback is complete and only when the session is finished.
When user navigates away from a playback/stream.
Underneath the playback level, we now have thepodlevel. A pod can be seen as a “group” or “segment” of either the content or advertisement.
Consider, for example, a playback session that might have some content and one mid-roll advertisement. This would mean that you would have twocontentpods (since the mid-roll ad split the content playback into two sections) while you might have one ad pod for the mid-roll ad. In this instance, you’d start and complete the first pod of content; you’d start and complete the ad; you’d start and complete the second pod of content. All of this would happen within one playback start.
All content events share the same event properties that describe information about the current video content the user is interacting with. Below is a table of the supported properties of this object.
Below is the full list of Video Content Events.
When a video content segment starts playing within a playback.
Heartbeats that you can fire every n seconds to track how far into the content the user is currently viewing as indicated by theposition.
When a video content segment completes playing within a playback. That is,positionandtotal_lengthare equal.
Just like Content events, Ad Events also live underneath the playback level and at the pod level. A given ad pod can have multiple ad assets (or just one) and a playback session might have multiple ad pods. For example, if your video playback has two pre-roll, one mid-roll, and one post-roll ads, you would have three ad pods:
All ad events share the same event properties that describe information about the current ad content the user is interacting with. Below is a table of the supported properties of this object.
Since some video destinations require sending Content metadata along with Ad metadata, you may need to send your content properties also in all your ad events underproperties.contentdepending on the video destination you’re using.
When you fire aVideo Playback Resumedevent, youshouldimmediately call a Segment heartbeat event (Video Content PlayingorVideo Ad Playingdepending on what the playback resumed to). This should effectively mean that you are also resuming your 10 second heartbeats (since they should’ve been paused after sending Video Playback Paused event).
It’s important to analyze the performance of your video content. To keep track of quality changes, you can track aVideo Quality Updatedevent when there is a change in video quality with the following properties:
Below is an example of how one might implement the video spec:
1) User presses play on a video:
2) Playback starts to play content:
3) User views content for 20 seconds and we have 10 second heartbeats:
4) Playback is paused and resumed:
5) Mid-roll ad starts playing:
6) User watches the full 21 second ad and we have 10 second heartbeats:
7) Content resumes, user finishes the full content:
(Video Content Playinghearbeats every 10 seconds)
8) 11 second post-roll ad plays after content finishes:
9) Playback finishes:
Below is an example of how a playback that has three mid-roll ads interspersed within the content:

Headings:
Video Spec
Getting started
Playback
Playback event object
Playback events
Video playback started
Video playback paused
Video playback interrupted
Video playback buffer started
Video playback buffer completed
Video playback seek started
Video playback seek completed
Video playback resumed
Video playback completed
Video playback exited
Content
Content event object
Content events
Video content started
Video content playing
Video content completed
Ads
Ad event object
Ad events
Video ad started
Video ad playing
Video ad completed
Resuming playback
Video quality event
Example event lifecycle
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/best-practices-identify/
Paragraphs:
On this page
The most important calls you make with Segment are theidentifyandtrackcalls. When you use these calls together, you can attribute actions on your site or app to individuals, and gain a better understanding of their activities, identity, and use patterns over time. Tracking users with the identify and track calls reduces the number ofMonthly Tracked Usersyou are billed for.
The Identify call specifies a customer identity that you can reference across the customer’s lifetime. There are instances where you want to record information about a user that isn’t already known to you. An example of this might be, a user that visits your site and doesn’t register, but they do give you their email address through a newsletter email sign-up form. In this instance, you would record that email address as a trait, and for the identifier (ID), you would use anonymous ID.
When you make anidentifycall using Segment’s Analytics.js library, Segment saves theuserIdto the browser cookie, and writes all the user traits inlocalStorage. If you’re using one of the Segment mobile libraries, theuserIdand traits are stored in the device’s memory. This makes it possible to append the user’s data to all subsequentpage callsortrack callsfor the user, so you can properly attribute those actions.
If a user returns to your site after thecookie expires, Analytics.js looks for an old ID in the user’slocalStorage, and if one is found, sets it as the user’s ID again in a new cookie. If the user clears their cookiesandlocalStorage, all of the IDs are removed and the user gets a completely newanonymousIdwhen they next visit the page.
Whenever possible, follow the Identify call with a Track event that records what caused the user to be identified.
If you’re using Segment’s browser or mobile libraries, the Segment SDK generates and sets a UUID asanonymousIDat the user’s first visit to your site. ThatanonymousIdis saved in the user’s cookie, as well as localStorage, and will stick with that user until the cache is cleared or aresetcall is triggered.
You can use theanonymousIdto link events performed by the user as they navigate around your website. When you track theanonymousId, you can attribute activities over multiple days to the same user by collecting all of the activities with that ID. If a user chooses to register for your site, or log in to your app, you can Identify them, and still include theiranonymousIdin the event payload along with the newuserId.
If you use Segment’s server libraries, you must generate ananonymousIdmanually. It can be any pseudo-unique identifier, for example, you might use asessionIdfrom a backend server.
Segment recommends that you use a unique user identifier (UUID) that won’t change for youruserId. AuserIdshould be a robust, static, unique identifier that you recognize a user by in your own database systems. Because these IDs are consistent across a customer’s lifetime, you should include auserIdin Identify calls as often as you can. If you don’t have a userId, you need to include an anonymousId in your Identify call in order to record identifying information about your user.
Ideally, theuserIdcould be a database ID. For example, if you’re using MongoDB it might be a row identifier and look something like507f191e810c19729de860ea. These can also beUUIDs that you generate somewhere in your application. You can also use identifiers that you get from other tools - such as Shopify or Braze - however this approach can lead to extra complexity in your systems.
Segment doesnotrecommend using simple email addresses or usernames as a User ID, as these can change over time. Segment recommends that you use static IDs instead, so the IDsneverchange. When you use a static ID, you can still recognize the user in your analytics tools, even if the user changes their email address. And even better, you can link your analytics data with your own internal database.
Tip!Even though Segment doesn’t recommend using an email address or a username as a User ID, you can still send that identifying information in your Identify call astraits.
You should make an Identify call in the following situations:
An anonymous user visits the site for the very first time. The home page has the analytics.js tracking snippet loaded in its header. When the page loads, this sets off the default Page call to Segment. The Segment SDK generates and setsanonymousId.
You can see in this full page event, theanonymousIdis populated, and theuserIdis null.
The user signs up for an email newsletter and fills out the form giving you their first and last name, as well as their email address. At this point, you will fire off an Identify call. You won’t yet assign them a user ID in this example, but you can still grab these traits about them.
You’ll notice the Identify call contains nouserId. These traits will be associated to theanonymousIdthat is available in the user’s cookie andlocalStorage.
An anonymous visitor registers for an account and becomes a known user. The account creation process allows you to assign auserIdfrom your production database and capture additional traits. For this example, theuserIdthat is assigned is “123abc”. This is when you’ll want to fire an Identify call with this user’s newly assigneduserIdand additional traits.
After you fire the Identify call with theuserId, you’ll notice that the payload now has both auserIdandananonymousIdattributed to the user.
The illustration below shows a timeline with a user’s interactions on a website, including sample API calls above that show Segment calls, and the user’sanonymousIdanduserId.

When the user first visits a page, Analytics.js automatically assigns the user ananonymousIdand saves it to the user’slocalStorage. As the user interacts with the site, for example clicking around to different pages, Analytics.js includes thisanonymousIdand somecontextual informationwith each Page and Track call. The contextual information might be the user’sIP address, browser, and more.
When a user signs up to create an account on the website, the.identify("userId")and.track(“Signed Up”)events fire, in that order. You pull theuserIdunique to the user from your systems, and send it to the Segment library so you can label that user’s later events with their ID. The later Track call (“Signed Up”) contains both theuserIdandthe automatically-collectedanonymousIdfor the user, and any other information you capture about them -  such as their first name, last name, and email address.
The example below shows an Identify call including user traits. It uses a database ID (97980cfea0067) as theuserId.
For a Track call, information about this event is stored either in thecontextfield or in the eventproperties. The example below shows a Track call including properties that tell you about the user.
Additionally, Analytics.js adds amessage_idandfour timestampsto the call.
Now, as the user interacts with your site and different buttons or links that you track using Segment, theiruserIdandanonymousIdare sent with each subsequent tracking API call.
Let’s go through some more scenarios to explain how ananonymousIdis assigned and how it might be merged with auserId.
If a user clicks on an ad and is directed to a webpage, they are assigned ananonymousId. While this user is anonymous, they navigate to different pages and click around on the website. Say they come back two days later from the same device, sign up, and are assigned auserIdfrom your database.

For simplicity, we’re assuming that the user hasnotcleared their cookies orlocalStorage, where the originalanonymousIdis stored. If they had, they’d be assigned a newanonymousIdwhen they visited the website, and theuserIdthey got when they register on the website wouldnotbe attached to the activities tracked with the oldanonymousId.
In this scenario, the person uses both a web browser, and a mobile application to interact with your site. In each case, they are assigned a differentanonymousId. In this scenario, the user signs up on the web browser, so Segment assigns theirwebsession auserId. However, because they do not log in on the mobile application, Segment cannot tie the mobile activity to this specific user. Their mobile application activity remains anonymous unless they log in on the mobile application.

Similar to the previous scenario, the user accessed both your website and mobile application, and also logged in on both. In this case, both sessions on the web and mobile app receive the user’suserId, so Segment can tie the anonymous activity on both web and mobile to this user.

Your data warehouse has a schema for each of your Segment sources. User information is stored in two tables in your source schemas - theidentifiesanduserstable.
Theidentifiestable contains all of your identify events, and the timestamps for these events. Every time you make an Identify call, Segment adds theuserId,anonymousId, any updated or added user traits from the call, as well as the timestamp of when the call was made. Youridentifiestable is your first stop when you have questions about users and their traits.
Theuserstable contains only unique Identify method calls, and is a collation of theidentifiestable. Theuserstable is the single source of truth for a user’s most up-to-date traits.
These tables only contain information about a useronce they have been identified.However, you can still find information about ananonymoususer on thepages,screens, andtrackstables, as well as the individual track event tables.
The Segment ID cookie is set with a one year expiration. However, there are some ways an ID can be reset or overwritten:
Remember, if a user has multiple devices, they can have differentanonymousIds on each different device.
If you’re tracking on the client and on the server, theanonymousIdcan be retrieved fromlocalStorageon the client and passed to the server. You can access a user’s anonymousId using the following call:
If you’re identifying on the server, then you will want to pass the user ID from the server to the client using an Identify call with theanonymousId. That will allow theuserIdto be aliased with the existinganonymousIdand stored in the cookie in localStorage. With that, all previous anonymous activity and all subsequent activity is associated to the newly generateduserId, as well as existinganonymousIds.
There are some advantages to sending details about your users directly from your server once the user registers. Server libraryIdentify callsare invisible to the end user, making them more secure, and much more reliable. Or, if you want to send user data that is sensitive or which you don’t want to expose to the client, then you can make an Identify call from the server with all the traits you know about the user. More aboutcollecting data on the client or serverin Segment’s documentation.
If you plan to track anonymous visitors from the browser and only makeIdentify callsfrom your server libraries, Kissmetrics and Mixpanel might require that you make anAlias callto link the records. The Alias call links client-side anonymous visitors with server-identified users. This isn’t recommended, but if you do this, read theKissmetricsandMixpanelspecificaliasdocs.
There are a few things that might cause your numbers to be off.
The most common problem people run into when tracking new user signups client-side is that only a portion of their new users are showing up in reports.
This is usually caused by the page redirecting or reloading before the tracking calls get a chance to run. Segment recommends that you make those calls from a welcome page after the user registers, rather than trying to squeeze in the tracking calls on the sign-up page itself.
This is usually only an issue inMixpanel, since it’s the only destination that requires a call toaliasin the browser to link anonymous browsing history to a new identified user.
Remember that for destinations that require aliasing, you must make theAlias callbefore you make theIdentify callfor that user. Even if you make anIdentify callfrom a server library, it can’t happen before the client-sidealias.
Unfortunately, there is no way to change an existinguserIdwithin Segment. Historical data with an existinguserIdremains the same, and a newuserIdwill not replace the existinguserIdin Segment event call logs. For downstream destinations, consult the corresponding docs about user profile behaviors when using a newuserId.
Changing auserIdis incredibly hard to do, as that is a fundamental part of analytics. While some downstream analytics tools let you change auserIdonce set, others don’t and the process will be different for each tool.

Headings:
Best Practices for Identifying Users
Identifying users
AnonymousId generation
Best options for userIds
When to call Identify
Soft User Registration
Full User Registration
Merging Identified and Anonymous user profiles
UserId merge examples
Scenario #1 - Multi-day, single device
Scenario #2 - Multi-day, multi-device, single login
Scenario #3 - Multi-day, multi-device, multiple logins
User profiles in warehouses
ID expiration and overwriting
Linking server and client generated Ids
Aliasing from a server library
Common questions
Missing sign-ups
Anonymous history is lost
Can you update a userId?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/spec/best-practices-event/
Paragraphs:
On this page
How do you to determine which type of call you should use? When should you make a Page call instead of a just using a Track call? In theory, youcouldput together a full implementation using only track events, but this is a bad idea - this page explains some of the things you should consider when deciding which call to use.
Segmentstronglyencourages you to followthe Specfor clarity and simplicity’s sake, however we also give you the flexibility to make only the calls that fit your needs. In the end, it is up to you.
Segment recommends that you followthe Spec, which gives general guidance about which methods to use when. You might read about “semantic spec”, which simply means Page calls should be about the page you’re viewing, and Track calls should be about events or activities you want to track.
The Spec outlines the specific data you should collect with each type of call. Each call type represents and is intended to collect specific information about a user or their activities. This means that your choice of method can imply things about the data you intend to collect.
For example, the properties forpage()andscreen()calls are intended to describe the page, not the user or their actions. Similarly, the data automatically included in apage()in particularly is important for UTM campaign capture.
As we mentioned above, youcouldbuild a full Segment implementation using only Track events, and this is probably a bad idea. To do this, you would need to include page-related data in every Track call, which means adding all of the information that Page calls automatically include, except now manually as event properties. As you might imagine, this gets unwieldy fast!
It’s better to pair a Page and a Track call together (making one of each call), especially if you have a complex tracking implementation. When you use the semantic methods you reduce the amount of information and other properties required in a single call.
Thetrack()call, andpage()orscreen()calls are handled very differently by your downstream tools, and how you can use that data is different. When you use the Spec, Segment uses the call type to help translate the data into destination’s tracking format. This ensures the highest level of compatibility with the end tools.
Some destinations were built around a specific call type and Segment maps to those specific methods. Some downstream tools do not acceptpage()andscreen()calls at all. Many of the destinations thatdoaccept these calls, also expect alimitedrange of data in apage()call, and may not properly receive or handle data that would be expected intrack()calls.
To help you with this, the Segment documentation includesa list of all of the supported destinations and the calls they accept.
Finally, when you use the different methods correctly, it can help you separate out “types” of information in your downstream tools and warehouses, so you can use them for different purposes.

Headings:
Best Practices for Event Calls
What is the Spec?
Simplifying implementation
Ensuring destination compatibility
Filtering data by purpose
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/sources/
Paragraphs:
On this page
Related content
A source is a website, server library, mobile SDK, or cloud application which can send data into Segment. It’s where your data originates. Add a source to collect data to understand who your customers are and how they’re using your product. Create a source for each website or app you want to track. While it’s not required that you have a single source for each server, site, or app, you should create a source for each unique source of data.
Each source you create has a write key, which is used to send data to that source. For example, to loadanalytics.js, the Segment JavaScript libraryon your page, the snippet on theQuickstart Guideincludes:
If you don't see the source you're looking for in our catalog
If a tool is not listed as a supported source in Segment’scatalog, then it is not possible to incorporate the integration out-of-the-box within a Segment workspace. However, as an alternative, you can use theHTTP APIsource to collect data from the tool’s API. You can also useFunctionsto send or receive data from other tools.
Segment has three types of sources:
Event streams sources collect data from your website or app to monitor user actions. These sources includewebsite libraries,mobile, andserver sources.
The Source Overview page for an event stream source shows you apipeline viewof all events Segment receives from your source, events that failed on ingest, events that are filtered at the source level, and “eligible events”, which are the events that will flow into your destinations. If you select one of the steps in the pipeline view, you can see a line chart that reflects the fluctuations in volume alongside abreakdown tablethat has more details about the events impacted by the selected step.
The pipeline view shows each of the four steps Segment encounters when processing data from your source:
You can use the time picker located on the Source Overview page to specify a time period (last 10 minutes, 1 hour, 24 hours, 7 days, 2 weeks, or a custom date range over the last two weeks) for which you’d like to see data. Segment sets the time picker to show data for the last 24 hours by default.

The breakdown table displays three tabs,Event type,Event name, andApp version.
Each of these tabs displays an event count, which is the total number of events that Segment received in a particular step.
The Unnamed or batched events under theEvent Nametab is a collection of all identify and page/screen calls in the source.
Analytics.js, the JavaScript library, is the most powerful way to track customer data from your website. If you’re just starting out, Segment recommends it over server-side libraries as the simplest installation for any website.
Analytics and data collection is a very broad topic and it can be quite overwhelming. How do you get started?
Segment’s Mobile SDKs are the best way to simplify your iOS, Android, and Xamarin app tracking. Try them over server-side sources as the default installation for any mobile app.
Analytics-Flutter library
The Analytics-Flutter library is currently only available in pilot phase and is governed by Segment’sFirst Access and Beta Preview Terms. If you’d like to try out this library, access theAnalytics-Flutter GitHub repository.
Segment’s server-side sources let you send analytics data directly from your servers. Segment recommends tracking from your servers when device-mode tracking (tracking on the client) doesn’t work. Check out theguide on server-side trackingif you’re not sure whether it makes sense for your use case.
Cloud-mode tracking
Server-side data management is when tag sends data to the Segment servers, which then passes that data to the destination system.
Cloud app sources empower you to pull together data from all of your different third-party tools into a Segment warehouse or to your other enabled integrated tools. They send data about your users from your connected web apps. There are two types of Cloud Apps:Object cloud sourcesandEvent cloud sources.
Wondering which cloud-apps send which types of data? Check out the Cloud Sources comparison.
These Cloud App Sources can export data from its third party tool and import it directly into your Segment warehouse. Make sure you have a Segment warehouse enabled before you enable any of the following sources:
Facebook Ads
Google Ads
HubSpot
Intercom
Mailchimp
Mandrill
Marketo
Salesforce
Salesforce Marketing Cloud
SendGrid
Stripe
Twilio
Zendesk
These Cloud App Sources can not only export data into your Segment warehouse, but they canalsofederate the exported data into your other enabled Segment integrations:
ActiveCampaign
Aircall
Airship
Alloy Flow
Amazon S3
Amplitude Cohorts
Antavo
Authvia
AutopilotHQ
Beamer
Blip
Bluedot
Blueshift
Braze
Candu
Chatlio

If Segment doesn’t have a library for your environment, you can send your data directly to theHTTP Tracking API. All of Segment’s other sources and platforms use the HTTP API to work their magic behind the scenes.
Segment’sPixel Tracking APIlets you track events from environments where you can’t execute code, like tracking email opens.
Reverse ETL sources are data warehouses that enable you to useReverse ETLto send data from your warehouse source to your destinations.
Reverse ETL supports these sources:
Segment is actively working on adding more sources. If you’d like to request Segment to add a particular source, please note it on thefeedback form.
To create a source:
Once you’ve created a source, the source is automatically enabled and can immediately receive events. You can review your new events in that source’sDebuggertab.
Sources not connected to an enabled destination are disabled after 14 days
If your source is not connected to any destinations or is only connected to disabled destinations, Segment automatically disables this source after 14 days, even if the source is receiving events. Disabled sources will no longer receive data. 
You can view when Segment disables your destination in your workspace’sAudit TrailasEvent : Source DisabledwithActor : Segment.
Workspace members receive an email notification before Segment disables your source so that your team has time to take action.
If you would like to prevent this behavior in your workspace, fill outthis Airtable form.
One source or multiple sources?
Segment suggests that you create one source for each type of data you want to collect. For example, you might have one source for all of your website tracking and a different source for any mobile tracking. Creating one source per data type provides the following benefits:
Segment has defined three tiers for libraries: Flagship, Maintenance, and Community. These tiers indicate the level of support, enhancements, and maintenance each library receives from Segment.
The criteria for assigning a library to a tier include its overall usage by customers and the availability of newer versions. Here’s how Segment defines each tier:
If a library falls into one of these tiers, you’ll see the tier label at the beginning of the library’s page.

Headings:
Sources Overview
What is a source?
Types of sources
Event streams sources
Source Overview
Pipeline view
Breakdown table
Website libraries
The Analytics Quickstart Guide
Mobile
Server
Cloud app sources
Comparing Cloud Sources
Object Cloud Sources
Event Cloud Sources
HTTP
Pixel
Reverse ETL sources
Create a source
Library tiers
Further reading
Sources Catalog
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/sources/catalog/
Paragraphs:
Below is a list of the available sources on the Segment platform.
UserGuiding
Virtual Assistant
IBM Watson Assistant
Crawling: https://segment.com/docs/connections/sources/about-cloud-sources/
Paragraphs:
On this page
Cloud-App Sources (often shortened to Cloud Sources) allow you to pull in data from third-party tools so you can use it in Segment. There are two types of Cloud Apps:ObjectandEventsources.
As in the basic tracking API,objectsusually contain information about a person or group which is updated over time, whileeventdata happens once, and is appended to a list.
Event Cloud Sources can export their data both into Segment warehouses, and into other enabled Segment integrations that work with event data.
Object Cloud App Sources can export data and import it directly into a Segment warehouse. Youmusthave a Segment warehouse enabled before you enable these. From the warehouse, you can analyze your data with SQL, useReverse ETLto extract data, or use Engage SQL Traits to build audiences. Some examples of Object Cloud sources are Salesforce (account information), Zendesk (support cases), and Stripe (payments information).
In the app, data from website, mobile, and server sources can go to a warehouseorto destinations. Object Cloud-App Source data canonlygo to Warehouses.
Sources are functionally comprised of either one or both of the following components: a “sync” component and a “streaming” component. They work together to populate logical collections of data based on upstream resource availability and following data normalization best practices. These collections may be either events (append only data streams, akin to “facts” in data warehousing parlance) or objects (dimensional values that may be updated based on changes in state upstream).
You enable a cloud source from the Segment web app, and grant Segment access by pasting an API key or authenticating with OAuth. Segment then starts a scheduled job on your behalf which makes requests to the downstream tool, normalizes and transforms the data, and forwards that data to the Segment API.
Cloud sources attempt to use as few API calls as possible, and (where possible) only fetch data that changed since the last sync. The syncs might take a long time (especially on the first sync), so the cloud source syncs have robust retry and rate limiting logic.
Contact Segment Product Supportif you’d like to change the cadence of your source’s sync frequency.
We make an effort to be respectful of your API call allotments and limits. For example, in the case of Salesforce, we issue only one query per collection per run, using the absolute minimum number of API calls possible (typically about 350/day).
Moreover, we’re deliberate about which collections we pull, striking a balance between allowing you to get a full picture of your users and reducing extraneous data (like administrative and metadata tables).
Soon, we’ll allow you to specify which collections you care about during the source set up phase, so if you need to cut down on calls, you’ll be able to just deselect collections.
Streaming components are used to listen in real time to webhooks from downstream cloud sources, normalize and transform the data, and forward it to our APIs.
Both sync and streaming components can forward data to our event tracking and objects upsertion API processing layers, but generally sync components are used to fetch objects and streaming components listen for events.
To use cloud sources, we suggest going through the following steps.
Before you connect a source, check out thesources documentation. See what kind of credentials you will need to enable the source. Different sources require different levels of permissioning.
Next, you’ll also need to get the credentials for yourwarehouse.
Once you have the necessary credentials (or are logged in to OAuth for your cloud source), you should be ready to go!
Based on your plan, you can schedule a certain number of syncs per day. We suggest setting these up so your dashboards and reports are fresh for reporting, but not at the same time of day that a lot of people are querying your database.
The most common reason cloud sources have trouble because of authentication or permission issues. When the issue is related to authentication, you’ll see an “access denied” connection error in your source details. When this happens, Segment quits the process early and does not make any further attempts on any collections.
When you successfully authenticate, but your user lacks the required permissions (for example, if you use an agent login instead of an administrator for Zendesk), Segment attempts to pull each collection and reports errors on a per-collection basis. This helps you troubleshoot why source runs fail, because sometimes permission-based denials are scoped to specific resources from the upstream tool.
Segment attempts to make the errors displayed in the UI clear enough so we don’t need to document all of them. However, if it’s not clear what to do to fix an error you encounter,contact supportand let them know.
Sometimes, when the sync job fails due to an unhandled error or is mysteriously hanging for too long, we’ll kill the job and report a failure with instructions to contact support. When this happens, our support and engineering teams have already been notified of the failure and have the complete set of logs to set about debugging and remediating the issue, but  don’t hesitate to get in touch so they can keep you in the loop!
In general, we’ve focused on pulling all of the collections directly related to the customer experience. We do not automatically pull all collections available from a partner API, since many of them aren’t relevant to the customer journey. You can see a list of the collections we pull in the docsfor each cloud source. Each collection reflects a table in your database.
Contact Segment Product Supportif you need additional data collected, or to change the schema to do the analysis you want. We’d love to know what analysis you’re trying to run, what additional data you need, and we’ll share with the product team to evaluate.
Generally, you need intermediate- to advanced SQL experience to explore and analyze cloud source data in a warehouse. The following resources can help you get up and running more quickly!
Joining IDsAs you start to get into joining across different types of sources, you’ll need a way to join user IDs. Thishelp articleexplains how to do this in detail.
Partner DashboardsOur BI partners at Mode, Looker, BIME, Periscope, and Chartio have created out of the box dashboards that work on top of our source schemas.


Headings:
Cloud Sources
Event Cloud-App Sources
Object Cloud-App Sources
How do cloud sources work?
Sync frequency
API call use and collection selection
Streaming
Set up a cloud source
Troubleshooting cloud sources
Using Cloud Source data
What kind of data does Segment pull from each source?
What questions can you answer with data from cloud, web, and mobile sources combined in a single warehouse?
Querying source data
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/sources/debugger/
Paragraphs:
The Source Debugger is a real-time tool that helps you confirm that API calls made from your website, mobile app, or servers arrive to your Segment Source, so you can troubleshoot your Segment set up even quicker. With the Debugger, you can check that calls are sent in the expected format without having to wait for any data processing.
The Source Debugger’s event order may not reflect how events send downstream or are received by connected destinations. The Debugger primarily confirms incoming data and provides a basic view of its structure. For a reliable record of the data you send to Segment, Segment advises you to attach a raw storage destination to your sources.

The Debugger is separate from your workspace’s data pipeline and is not an exhaustive view of all the events ever sent to your Segment workspace. The Debugger only shows a sample of the events that the Source receives in real time, with a cap of 500 events. The Debugger is a great way to test specific parts of your implementation to validate that events are being fired successfully and arriving to your Source.
To see a more complete view of all your events, Segment recommends that you set up awarehouseor anS3 destination.
The Debugger shows a live stream of sampled events arriving into the Source, but you can also pause the stream from displaying new events by toggling “Live” to “Pause”. Events continue to arrive to your Source while you Pause the stream.
You can search in the Debugger to find a specific payload using any information you know is available in the event’s raw payload. You can also use advanced search options to limit the results to a specific event.

Two views are available when viewing a payload:

Headings:
Using the Source Debugger
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/sources/custom-domain/
Paragraphs:
Custom Domain is available to customers on Business tier plans.See theavailable plans, orcontact Support.
On this page
Custom Domain is a fully-managed service that enables you to configure a first-party subdomain over HTTPS.  You can then track event requests through your own domain (for example,cdp.mydomain.com), instead of the default (segment.com). Tracking events through your own domain allows for more secure and complete first-party data collection by reclaiming first-party data lost to browser controls. With a more complete view of your customer behaviors, you can build more robust profiles for greater attribution and ROAS.
Custom Domain is only available to Business Tier customers
Customers not on the Business Tier but who have interest in Custom Domain shouldcontact Segment’s sales teamfor assistance with upgrading to a Business Tier plan. Segment also offers an alternative DNS record service,Custom Proxy.

Segment recommends configuring Custom Domain alongsideConsent Managementto ensure you are respectful of your end users’ consent preferences.
Segment offers two domain delegation solutions:Custom ProxyandCustom Domain. If you use Custom Domain, you can choose to use either DNS delegation or a Cannonical Name (CNAME). Segment recommends using Custom Domain with DNS delegation, which leads to easy setup, maintenance, and monitoring.
*If it’s not possible for you to delegate subdomains to Segment, you can use a CNAME instead. Segment encourages users to delegate a DNS subdomain rather than use use CNAME aliasing due to the evolving privacy standards in browsers, but CNAME aliasing remains an option for users not interested in using nameservers.
DNS subdomain delegation is a process where the control of a specific subdomain is assigned to another DNS server, allowing that server to manage the DNS records for the subdomain. This delegation is useful for distributing the management of DNS records and enables specialized handling of subdomain traffic.
When a user tries to access the alias domain, the DNS resolver looks up the CNAME record, finds the canonical name, and resolves it to the IP address of the target. For example, you could alias your subdomain to point to the Segment domain. If a user accesses your site, they are redirected to the Segment domain, but their browser’s address bar still shows the alias domain.
CNAME records provide flexibility and centralized management, making it easier to handle domain redirections and subdomain configurations.
Implementing a Custom Domain using CNAME delegation requires you to add a CNAME and record for two domains that Segment generates on your behalf: one for the Segment CDN and a second for the Tracking API. You must add a CNAME and DNS record for both domains.
Custom Domain supports the following sources:
Custom Domain configuration won’t disrupt your event tracking. Default Segment domains will continue to function alongside your custom domains once the setup is complete.
To configure Custom Domain:
Segment recommends creating a different subdomain (for example,mysubdomain.mydomain.com) for each source. You cannot connect multiple custom domains to the same source.
For initial setup, Segment requires anAnalytics.jssource. Custom Domain was largely developed to support JavaScript sources. It helps with comprehensive collection of first-party data from your website when accessed over any platform (desktop, mobile, and more). You can use the subdomain for all other non-JavaScript sources as well, for consistency, but it will have no impact on data collection for those sources.
For non-Analytics.js sources, you’ll need to update your implementation to use the subdomain as an endpoint when using the Tracking API. For example:
Server-side tracking is generally more reliable than client-side tracking. For example, when tracking data client-side, you might lose data when users might block all cookies or use tools that interfere with network requests leaving the browser.
For business-critical events, Segment recommends server-side data tracking. This approach means that your data is less susceptible to disruptions from client-side variables, which can result in more accurate and reliable tracking.
Yes, Custom Domain is a fully-managed solution. However, you must set up the following infrastructure on your end:
First, decide on your subdomain and then delegate it to Segment. Segment then asks you to add a DNS NS record to your DNS with specific values to complete the DNS delegation. From there on, Segment fully manages the infrastructure for serving Analytics.js and ingesting events data through the subdomain.
Segment doesn’t recommend that you change the subdomain after the initial setup. If you change the subdomain, Segment must revoke the older certificates for your subdomain and you are required to redo the entire onboarding process, as several underlying components, like certificates, would need to be recreated and reassociated.
Segment hosts and manages SSL Certificate on the Custom Domain. At this time, Segment does not support importing a certificate you may already have, as Segment must request a SSL certificate on your behalf using AWS Certificate Manager (ACM) when initially setting up your Custom Domain.
Segment also uses ACM to manage and renew certificates.
Yes, Custom Domain allows Segment to renamewindow.analyticsto a unique name to avoid being blocked by some ad blocking software.
Customers who have access to the Custom Domain feature can rename analytics to<workspaceid>/<sourceid>.jsby choosing an Alias for Analytics.js within the source settings that are available after the workspace is enabled for Custom Domain.
Analytics.js cookies are not lost in the transition to Custom Domain. When users revisit your website, the previous Analytics.js cookies continue to be fetched and added to events, if available.
No, each workspace requires its own unique subdomain (for example,mysubdomain.mydomain.com).

Headings:
Segment-Managed Custom Domain
Segment’s domain delegation solutions
How DNS subdomain delegation works
How CNAME records work
Supported sources
Getting started
FAQ
Can I set up multiple Custom Domains?
What sources can I use with Custom Domain?
How can I configure non-JavaScript sources to use Custom Domain?
Is there a benefit in migrating server-side sources over to client-side with Custom Domain?
Is this a fully-managed solution? What servers or infrastructure do I need to set up on my side for this proxy?
Can I change my Segment subdomain after the initial setup?
Who is responsible for managing the SSL certificate for the Custom Domain?
Can you renamewindow.analyticswith Custom Domain?
What happens to the Analytics.js cookies already set on the user’s browser prior to a Custom Domain implementation?
Can I use the same subdomain across multiple workspaces?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/sources/catalog/libraries/website/javascript/custom-proxy/
Paragraphs:
On this page
Custom proxies allow you to proxy Analytics.js and all tracking event requests through your own domain.
You cannot use custom proxy setup for Analytics.js CDN or Tracking API with device-mode destinations because it requires that the destination’s native scripts are loaded onto the client, and the requests are sent directly to the destination.
Business Tier customers can also use Custom Domain
Custom Domain is a fully-managed service that enables you to configure a first-party subdomain over HTTPS to track event requests through your domain instead of tracking events through Segment’s default domain. For more information, see theCustom Domaindocumentation.
Segment offers two domain delegation solutions:Custom ProxyandCustom Domain. If you use Custom Domain, you can choose to use either DNS delegation or a Cannonical Name (CNAME). Segment recommends using Custom Domain with DNS delegation, which leads to easy setup, maintenance, and monitoring.
*If it’s not possible for you to delegate subdomains to Segment, you can use a CNAME instead. Segment encourages users to delegate a DNS subdomain rather than use use CNAME aliasing due to the evolving privacy standards in browsers, but CNAME aliasing remains an option for users not interested in using nameservers.
To set up a custom proxy, you need:
Custom Proxy Troubleshooting
If you experience issues configuring a custom proxy, contact your organization’s IT department for help. Segment does not have access to the resources you need to configure a custom proxy.
This guide explains how to set up a custom proxy in CloudFront. You can apply these principles to almost any modern CDN that supports proxies.
You need to set up two important parts, regardless of the CDN provider you use:
If you are using aRegional Workspace, please note that instead of usingapi.segment.ioto proxy the Tracking API, you’ll be usingevents.eu1.segmentapis.com
Segment only has the ability to enable the proxy setting for the Web (Analytics.js) source. Details for mobile source proxies are in theAnalytics-iOSandAnalytics-Androiddocumentation.  It is not currently possible to set up a proxy for server sources using the Segment UI.
Segment loads most integrations through the proxy, except for third-party SDKs
Third-party SDKs are loaded by a partner’s CDN, even with a Segment proxy configured. For example, if you have  a Segment custom proxy enabled and send data to a FullStory destination, FullStory’s CDN would load the FullStory SDK.
There are two options you can choose from when you set up your custom domain proxy.
Follow the directions listed forCloudFrontoruse your own CDN setup. Once you complete those steps and verify that your proxy works for bothcdn.segment.comandapi.segment.io,contact Segment Product Supportwith the following template email:
Double-check the Source URL and the Source ID.
A Segment Customer Success team member will respond that they have enabled this option for your account. When you receive this confirmation, open the source in your workspace, and navigate to Settings > Analytics.js. Update theHost Addresssetting fromapi.segment.io/v1to[your proxy host]/v1.
TheHost Addressfield does not appear in source settings until it’s enabled by Segment Customer Success.
There should be no downtime once the setup is complete, as the default Segment domains continue to work alongside the customer’s domains.
Follow these instructions after setting up a proxy such asCloudFront. Choose between thesnippet instructionsor thenpm instructions.
If you’ve followed the instructions above to have a Segment team member enable the apiHost settings in the UI, you can skip the instructions in this section.
If you’re a snippet user, modify theanalytics snippetlocated inside the<head>of your website:
To proxy CDN settings and destination requests that typically go tohttps://cdn.segment.com, replace:
To proxy API tracking calls that typically go toapi.segment.io/v1, replace:
If you’re using thenpm library, make the following changes directly in your code:
To proxy settings and destination requests that typically go tohttps://cdn.segment.comthrough a custom proxy:
To proxy tracking calls that typically go toapi.segment.io/v1, configure theintegrations['Segment.io'].apiHost:
These instructions refer to Amazon CloudFront, but apply more generally to other providers as well.
To set up your CDN Proxy:
Take note of the Domain Name for use in the next step.
To add a CNAME record for the Segment proxy to your organizations DNS settings:
As events travel through the proxy before reaching the tracking API, set up a proxy for the tracking API so that all calls proxy through your domain. To do this, set up a CloudFront distribution that’s similar to the one in the previous section, with the exception of the Origin Domain Name:
To add a CNAME record to your DNS settings:
These are some common issues that occur for customers implementing a custom proxy. This is not an exhaustive list, and these CloudFront or Cloudflare settings may change.
A 403 error can mean that you’ve misconfigured your Cloudflare CDN distribution. Try one of the following options to fix the error:
If you have a Cloudflare enterprise plan, create a Page Rule in Cloudflare so that Segment’s CDN doesn’t refuse the requests made through the Cloudflare Proxy. Ifcdn.segment.comis another CNAME that resolves toxxx.cloudfront.net, you will need to use a Page Rule in Cloudflare to override the host header to match the hostname for proxy requests. For more information about overriding the host header, see Cloudflare’sRewrite Host headersdocs.
For customers who are not on the Cloudflare Enterprise plan, use Cloudflare Workers. Workers usually run on the main domain (for example,www.domain.com), but if you want Workers to run on a subdomain, likehttp://segment.domain.com, you must record the subdomain in your DNS. For more information, see Cloudflare’sRoutes and domainsdocumentation.
When creating a Worker you can use this example provided by Cloudflare in theirBulk origin overridedocumentation with the origins set to:
In order to resolve a CORS OPTIONS pre-request fetch error, you must specify “Strict (SSL-Only Origin Pull)” as a Cloudflare Page rule for theapi.segment.ioproxy. Please see Cloudflare’sEncryption modesdocumentation for more details.
If your CloudFront Proxy is returing a 403 error, the following change in CloudFront might resolve the issue:
Alternatively, this setting may solve your issue:
To resolve a CORS issue, you might need to add a referrer header in the request you send to Segment. Follow AWS’sHow do I resolve the “No ‘Access-Control-Allow-Origin’ header is present on the requested resource” error from CloudFront?guide, which explains how to add a referrer header.
To reduce fetching assets from Segment’s CDN, you can bundle Analytics.js with your own code.
To bundle Analytics.js with your own code, you can:
Use Analytics.js as an npm package.
Use npm to install your destinations.
Hardcode your settings instead of fetching from the CDN (Segment doesn’t recommend this as it completely bypasses the Segment source GUI).
If you wish to restore the proxied API host to it’s original value:
Any changes made to the CDN host must be update manually in your code.

Headings:
Self-Managed Custom Proxy
Segment’s domain delegation solutions
Custom Proxy prerequisites
Custom Proxy setup
Custom CDN / API Proxy
Snippet instructions
npm instructions
Custom Proxy CloudFront
CDN Proxy
Add CNAME Record to DNS
Tracking API Proxy
Add CNAME Record to DNS
Common issues
Cloudflare returning a 403 error
Cloudflare CORS issue
CloudFront Proxy returning a 403 error
CloudFront CORS issue
Self-hosting Analytics.js
Restore the API host to the Segment default
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/sources/visual-tagger/
Paragraphs:
On this page
Visual Tagger entering maintenance mode
Visual Tagger is entering maintenance mode onApril 5th, 2021.
You can continue to use Visual Tagger with sources on which it’s already enabled. However, the feature will no longer be available to new Segment customers and existing customers will not be able to add new Visual Tagger sources.
Segment is committed to enabling customers to collect and deliver high quality customer data to the tools they need to run their businesses. As a CSS-based event tracking method, Visual Tagger has limitations that can prevent detailed data from being consistently collected. For code-based collection best practices, see theSegment Spec.
Going forward, support for the feature will include:
The following best practices can make your website more compatible with the feature and eliminate common issues:
Visual Tagger is a tool that enables you to collect data about what your customers are doing on your websites without having to write any code. Specifically, it helps you implementtrackevents by pointing and clicking on parts of your website.
With Visual Tagger, you can:
The Visual Tagger has two main views: theVisual Tagger Homeand theEvent Editor, which shows your website in an iframe.
Note: The website you’re tagging must include the Segment analytics.js snippet before you can use the Visual Tagger.
Get the following things set up before you use Visual Tagger:
Note: Your website must use HTTPS.
Once you have all the prerequisites set up, you’re ready to get started:
As you click each event, you’re prompted to select the part of the website that should trigger the event, and describe the properties that event should have.
You are now ready to tag events on your website!
Tip: If you ever need to get back to this screen, you can navigate to the JavaScript website source again, click theVisual taggertab, then clickAdd Event.
To create events, start in theEvent Editoron theBuildscreen. This page shows an iframe with your website.

You can either choose one of the Recommended Events, or you can clickAdd Eventand create a new one. Recommended Events work the same way, except Segment defines the Event Name, and each event comes with a set of default properties.
When you clickAdd Event, three types of events are available:
Button or Link Click. Select anybuttonandlinkelements on the page to create events that fire when a user clicks that button or link. Depending on the construction of your website, some elements that look like buttons might not actually be CSS “button” elements - use the “Any Element Click” event instead for these elements.
Form Submit. Select this option to highlight anyformelements on the page so you can select them. When you choose Form Submit, Segment adds all form fields to your event automatically asproperties.
Any Element Click. Selecting this option will allow you to click on any element on your page. This will allow you to create an event for whenever a user on your website clicks on that element.

Once you choose an event type, mouse over your website in the iframe to highlight elements that you can select to create an event, and click one to start the process.
If the element on the page has siblings, you can tag them all at the same time, or tag just the one specific element you clicked.
When you choose a Recommended Event, it works much in the same way, but the Event Name is pre-set and each event comes with a set of default properties.
The events you create are not saved until you publish them.
When you click on an element on your website, a window appears where you can enter the details for the event.
Event Name. Edit the event name to be simple yet descriptive.
Segment recommends that you use an “Object Action” format (for example,Blog Post Clicked, and use Title Case (capitalize the first letter of each word ) when naming events.
Once you’re satisfied with the event name and properties, clickAdd.
Tip! You can create more than one event before you move on to the next step.

When you use Visual Tagger, you can createstatic propertiesby entering the value that the property should have. When a property is static its value is hardcoded, and is always the same regardless of any actions from the user.
You can also createdynamic propertiesby selecting a piece of text from the website that you want as the value for that property. When a property is dynamic, its value is different depending on what the user clicked.
For example, if you run an e-commerce web shop and want to create an event that fires every time a user clicks on a product on your search results page, you would create aProduct Clickedevent.
To specify where the event was fired from, you would add a property calledlocationto the event. You would hardcode the value of that property as “Search Results Page”. This is an example of a static property.
To show which product the user clicked, you can add a property calledproduct_nameto the event. You can use the Visual Tagger “select from page” feature to select the text on the iframe-version of your website that gives the product name. The value of theproduct_nameproperty would then be different, depending on what users click.
When you tag a form you can track both that the usersubmittedthe form, and also update traits about the user.
This is useful if the form collects information about the user (such as Name, Email, Country). (This wouldn’t be useful on a Search or Add To Cart form.)
This is an illustration of how traits and events might appear for a user in a Destination or Engage.

If you enable the Identify Users feature, you can specify which traits to update in the same way as properties for the event.

By default, events created using the Visual Tagger only fire on the same URL as the one where you tagged the event. This prevents unexpected events if the same CSS selector exists on other pages of your site.
If you have similar pages with different URLs such as/products/1and/products/2and you want to same event to fire on both, you can change theURL Page Targetingto match/productsinstead of/products/1or any page on the entire website.
Once you finish filling out the event details, clickContinueto go to the Test and Publish screen. On this screen you can test your event to confirm that it works as expected before you publish it.
Test your events by clicking around on your website in the iframe, and doing things on the iframe-version of your site that should trigger the event.
If something doesn’t look right, clickBackto return to the Build screen and edit your tags.
If you’re having trouble validating your events, seeTroubleshooting Tips.
When you’ve finished setting up and testing your events, clickPublish.
Events can take up to 10 minutes appear on your website. Once they are live, events begin sending to Segment when people visit your website and interact with the elements that you created events for. The data from these events appears in the Website Source’s Debugger.
After you publish your event and wait for ~10 minutes, do a last test to make sure your tags are working expected and that you see your data landing in your Segment Debugger.
In one window, open up your website where you created the event. In another window (side by side), open theSegment Debuggerfor your JavaScript Source. The Debugger is a Segment tool that shows a live stream of the data coming from that Source.
Good to know: The Debugger automatically pauses after ~1 minute of idle time. Refresh the page if you leave and come back to it, and don’t see new data.
On your website, pretend that you are an end-user and try to trigger the event that you created in Visual Tagger. Watch the Debugger in the other window to confirm that the event fired when you took that action.
All events created using Visual Tagger automatically get a context property that says"visual_tagger" : trueso that you can distinguish between events that you implemented using Visual Tagger and events that you implemented using code.

Once you publish your events, they appear on theVisual Tagger Homeview in theAll Published Eventstable. From here, you can create clickAdd Eventto create new events, and edit or delete existing ones.

If your events are not working as expected, try the following steps to troubleshoot the issue.
Ensure that you toggle Visual Tagger integration on. You find it in the Settings for your Source.
Ensure that your website has analytics.js installed and running. You can confirm this by visiting your website and watching the Segment Debugger. Apagecall should flow into your Debugger whenever someone visits a page on your website if you have implemented analytics.js. Note that if you have an ad blocker enabled when you visit your website, data will not get fired into Segment when you interact with your website.
Confirm that the CSS selector has not changed in any way since you created the event in the Visual Tagger (for example, a button could change locations or be removed entirely). Because Visual Tagger relies on the CSS selector to tie events to user actions, if the CSS selector changes, the event stops sending. If this happens, edit the event in Visual Tagger and update the CSS selector. Segment does not have a way to alert you when events you created using Visual Tagger begin to fail.
Because Visual Tagger relies on stable CSS selectors to fire events, it is not compatible with websites that have CSS selectors that are dynamically generated on every page load.
If your website has any components in iframes (for example, if you embed Typeforms into your site), Visual Tagger cannot create events for those components. Segment recommends that you install analytics.js on the iframed-in site and use Visual Tagger directly on that site.
If you use the same name for multiple events (whether in code or using Visual Tagger), duplicate events arenotcreated downstream. Instead, Segment merges those events into one event.
If your events still don’t work as expected, contactSegment Customer Supportfor help.
Yes! Visual Tagger relies on CSS selectors, which involves “class names” such as “hero” or “footer”. Some web technologies automatically generate these names and change them on a regular basis, which makes the Visual Tagger events stop firing.
Squarespace uses this technique, and you can examine the HTML of your site to see if the “class names” are randomized letters/numbers.
Visual Tagger also does not support embedded elements, such as a YouTube video player or a Hubspot form.
When you load your website in the Visual tagger iframe, you might see unexpected or incorrect behavior. This is because browsers load websites differently inside aniframethan in a regular browser window.
For example, Google Chrome blocks certain types of cookies when a page is loaded inside an iframe, and this can cause problems with authentication or other functions.
Click theOpen in Popupbutton (above the top right corner of the iframed website) if you experience unexpected behavior when you load your website in the VT iframe, including issues with the login or authentication, or errors with form submissions. This opens the website in a new browser window (outside of an iframe) which is connected to the Visual Tagger.
Tip!: You might want to change the width of both the Visual tagger window and your website window so you can view them side by side for easier tagging.
The most stable way for Visual tagger to identify elements is if each one has a unique ID that persists even if the page is reorganized.
Visual Tagger is a great way to get started with tracking, but over time you might need to augment with coded instrumentation.
These are ideal use cases for Visual Tagger:
Understanding how users are engaging with your public website. Beyond page tracking, you can learn which CTA’s are most popular, collect information from forms, learn when users engage with interactive content like a carousel.
Similarly for campaign landing pages, that needs to go live with short turnaround, and require tracking forms, CTA, and other interactive content
Understanding your ecommerce funnel, how users browse and filter products, add them to cart before checking out and completing an order
Learn more about how users use your product or service, after logging in. Track key semantic events in your product such as Project Created (project management app), Account Upgraded, Listing Favorited (apartment rental site) etc to learn about adoption, engagement, and retention
These are examples of when to augment with coded instrumentation:
If your website or application changes frequently, you will need to keep track of each change and update Visual Tagger events accordingly. In that situation, it can be beneficial for the engineering team to have the event tracking in code and update at the same time as changing how a feature work.
The Visual Tagger integration has negligible impact to your site’s performance, because it installs a single event handler that makes an asynchronous call to Segment when a tag’s event is invoked.
However, adding a large number of tags to your site could potentially impact your site’s performance. To guard against this we limit the number of tags you can add using Visual Tagger to a maximum of 50.
Yes. You can track dynamically generated elements like modals (for example) using the Visual Tagger.
Visual Tagger binds its event listeners to thedocumentobject. Forms usingstopPropagationandstopImmediatePropagationmethods prevent the event from bubbling up, causing Visual Tagger to not execute the handlers for emitting track/identify calls. Remove anystopPropagationandstopImmediatePropagationmethod calls from your form handler to allow Visual Tagger to process the event.
Currently, only information that is visually present on the page is available for use in the Visual Tagger.
Events that were added using the Visual Tagger (as opposed to in code) have acontextproperty in the event payload that says"visual_tagger": true. Eventsnotimplemented using the Visual Tagger do not have this property.
Because the new version of Visual Tagger is available in the Segment app, Workspaces that have MFA or SSO enabled are able to access it.

Headings:
Visual Tagger
Setting up Visual Tagger
Before you begin
Enable Visual Tagger
Step 1: Choose the event type and select an element
Step 2: Add details to the event
More information on properties
More information on forms
More information on URLs
Step 3: Test the event(s)
Step 4: Publish the event(s)
Step 5: Test the event to confirm that it works
Managing and editing Visual Tagger events
Troubleshooting your events
FAQs
Are there situations where Visual Tagger will not work?
What do I do if my website does not behave correctly inside the VT iframe?
How can I make my website ideal for Visual Tagger?
When should I use Visual Tagger instead of a coded instrumentation?
Depth of instrumentation
Frequency of change
Will using Visual Tagger impact my site or app’s performance?
Does Visual Tagger work with dynamically generated elements or Single Page Applications?
Why does my form submit event not work?
Does Visual Tagger have a data layer so that I can make use of data that’s not rendered on the page?
How can I tell which events were created using Visual Tagger versus which were implemented using code?
The old version of Visual Tagger didn’t have support for MFA or SSO. What about the new version?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/sources/schema//
Paragraphs:
On this page
Segment Business Tier customers can use Schema Controls to manage which events are allowed to pass through Segment and on to Destinations. These filters are a first-line defense to help you protect the integrity of your data, and the decisions made with it.
Blocking events within the source schema will exclude them from API and MTU calculations. These events are discarded before they reach the pipeline that Segment uses for MTU calculations.
The Schema tab shows the schema of events, properties, and traits for each source that Segment receives over a specific timeframe. It also shows when the events were last seen, how many events were allowed vs. blocked, and the downstream destinations those events are connected to.
You can view events by Segment call type in the Source Schema with theTrack,Identify, andGrouptabs. 
The Schema tracks:
Click the arrow to the left of the event name to view additional event properties for Page or Track events. Since the Schema tracks Identify traits, you will need to make sure you are passing traits into your Identify call in order to view event data in your schema.
The Schema shows “Page Viewed” for all Page calls under theTracktab.
The Source Schema UI changes slightly depending on whether you have aProtocols Tracking Planconnected to the source. If you have a Tracking Plan connected to your source, the UI displays aPlannedcolumn that will indicate if the event is planned or unplanned. This allows you to quickly identify unplanned events and take action to align your schema with your Tracking Plan. If there is no Tracking Plan connected to the source, the UI will display a toggle next to each event where, if you’re a Business Tier customer, you can simply block or allow that event at the source level.
Array properties are represented with an additional nested property representing the array’s items. The nested property is the property’s name with a.$suffix.
If an array property in the connected Tracking Plan does not include theitemsnested property, nested properties might be marked as unplanned in the Source Schema.
If you no longer want to track a specific event, you can either remove it from your code or, if you’re on the Business plan and don’t have a Tracking Plan connected, you can block track calls from the Segment UI. To do so, click on the Schema tab in a Source and toggle the event to enable or block an event.

For sources with a connected Tracking Plan, use Protocols to block unplanned events.
Once you block an event, Segment stops forwarding it to all of your Cloud and Device-mode Destinations, including your warehouses. You can remove the events from your code at your leisure. In addition to blocking track calls, Business plan customers can block all Page and Screen calls, as well as Identify traits and Group properties.
When an event is blocked, the name of the event or property is added to your Schema page with a counter to show how many events have been blocked. By default, data from blocked events and properties is not recoverable. You can always re-enable the event to continue sending it to downstream Destinations.
In most cases, blocking an event immediately stops that event from sending to Destinations. In rare cases, it can takeup to six hoursto fully block an event from delivering to all Destinations.
If you no longer want to capture specific traits within.identify()and.group()calls, you can either remove those traits from your code, or if you’re on the Business plan, you can block specific traits right from the Segment UI. To do so, click on the Schema tab in a Source and navigate to the Identify or Group events where you can block specific traits.

Blocked traits are not omitted from calls to device-mode Destinations.
All customers can filter specific events from being sent to specific Destinations (except for warehouses) by updating their tracking code. Here is an example showing how to send a single message only to Intercom and Google Analytics:
Destination flags are case sensitive and match theDestination’s name in the docs(for example, “AdLearn Open Platform”, “awe.sm”, “MailChimp”, and so on).
Segment Business tier customers can block track calls from delivering to specific Destinations in the Segment UI. Visit a Source Schema page and click on theIntegrationscolumn to view specific schema integration filters. Toggle the filter to block or enable an event to a Destination.

Headings:
Source Schema
Schema view
Event filters
Identify and Group Trait Filters
Schema Integration Filters
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/sources/schema/destination-data-control/
Paragraphs:
On this page
Once you have enabled destinations for a given source, all of thedatayou track will be routed to your connected tools and warehouses. If you no longer wish to send all data to a particular destination, you can disable the destination from the Source overview page.
Segment gives you the power to control exactly what data is allowed into your destinations, so you can protect the integrity of your data, and the decisions you make with it. You can send all of your data to a warehouse and only two specific events to an analytics tool. You can also block rogue events from all of your warehouses and end tools.
Anintegrations objectmay be passed in theoptionsofgroup,identify,pageandtrackmethods, allowing selective destination filtering. By default all destinations are enabled.
All customers can filter specific events from being sent to specific destinations (except for warehouses) by updating their tracking code. Here is an example showing how to send a single message only to Intercom and Google Analytics:
Destination flags arecase sensitiveand matchthe Destination’s name in the docs(for example, “AdLearn Open Platform”, “awe.sm”, “MailChimp”, etc.).
If you’re on Segment’s Business plan, you can filter track calls right from the Segment UI on your Source Schema page by clicking on the field in theIntegrationscolumn and then adjusting the toggle for each tool. Segment recommends using the UI if possible since it’s a much simpler way of managing your filters and can be updated with no code changes on your side.

If you no longer want to track an event, you can either remove it from your code or, if you’re on the Business plan, you can block track calls right from the Segment UI on your Source Schema page by adjusting the toggle for each event.

Once you block an event in Segment, Segment stops forwarding it to all of your destinations, including your warehouses. You can remove it from your code at your leisure. In addition to blocking track calls, Business plan customers can block all Page and Screen calls, as well as Identify traits and Group properties.
TheNew Eventbutton in your source schema adds the event to the source schema only. It does not add any events to your tracking code. If you want to track an event, you still need to manually add it to your source code.
A use case for this feature might be to enableschema filteringfor a new event before it arrives in the source to prevent it from reaching specific downstream destinations.
Segment allows users with Source Read-only permissions to download Source Schemas as a CSV file, maximizing portability and access to event data. You can download a copy of your schema by visiting the Source Schema page.
You can export Track, Identify, and Group Source Schemas.
You can only download one Source Schema CSV schema type (Track, Identify, or Group) per source at the same time.
To download a Source Schema CSV file:
All events and properties are now included in the CSV file
When you export a Source Schema, all events and properties are included in the CSV file regardless of the filters or search parameters currently applied to the Source Schema view.
You can view the Source Schema exports from the last 14 days on the Download History page.
To access the Download History page:
The Track event CSV file contains the following columns:
Labels in your exported CSV
If you uselabels, they appear as columns in your CSV. The column headers are keys, and the column data contains values.
The Identify and Group CSV files contain the following columns:
The exported schema doesn’t include actual values (for example, personal data) for the events, properties, and traits you are tracking for a specific source.
See theSegment Schema Limitsfor more information on how to manage the Source Schema.

Headings:
Using Schema Controls
Filter specific events from being sent to specific destinations
Block or disable specific events and properties from being sent to all destinations
Add a new event using theNew Eventbutton
Export your Source Schema
Download a CSV
View download history
Track event CSV format
Identity and Group event CSV format
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/sources/schema/schema-unique-limits/
Paragraphs:
While you can technically track unlimited events with Segment, only the first 4,000 events will be visible on the Schema page for a given Source. After you hit the 4,000 event limit, all future events will still be tracked and sent to your Destinations. They will not, however, be logged in the Segment Schema table.
While you can track unlimited event properties and traits with Segment, the Schema page has the following default limits:
After you hit the limit for both properties or traits, future properties and traits are still tracked and sent to your Destinations, but they won’t appear on the event details page. This limit includes nested properties in an event’s properties object.
These limits can also affect the traits and properties that you can see in the Computed Trait and Audience builder tools in Engage. If expected traits or properties do not appear in these tools, contact theSegment Support team.
If you hit any of the limits or would like to clear out old events or properties, you can clear the Schema data from your Source Settings. In your Source, navigate to Settings, then Schema Configuration. Scroll down to theClear Schema Historysetting.

Clearing events from the Source Schema only clears them from the Segment interface. It does not impact the data sent to your destinations or warehouses. Once you clear the events, the Schema page starts to repopulate new events.
You can archive events in order to declutter the Source Schema. If your Source Schema is connected to a Tracking Plan, events need to be blocked or unplanned for you to archive them. If your Source Schema not connected to a Tracking Plan, you must disable the event to see the archive button.
Archiving an event triggers an “Schema Event Archived” activity to the Audit Trail.
To view archived events, you can filter your view by “Archived”.
While this is particularly useful for Protocols customers that want to keep events “Unplanned yet acknowledged” and build a process to monitor for unplanned events, Protocols is not required to use this feature.
At this time, you cannot clear or archive old event properties individually. An alternative to this is to archive the event itself and then clear the archive. After you clear the archive, the event will re-populate in the schema with only the current properties.

Headings:
Segment Schema Limits
How many unique events can be logged in my Segment Schema table?
How many unique event properties and traits can be logged on the event details page?
How can I clear the Schema if I have hit the limits?
How can I remove specific events from my Source Schema?
How can I remove properties from my Source Schema?
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/destinations/
Paragraphs:
On this page
Destinations are the business tools or apps that Segment forwards your data to. Adding Destinations allow you to act on your data and learn more about your customers in real time.
Destinations Catalog
If you want to explore the destinations compatible with Segment, check out theDestinations catalog. Select an item from the catalog to learn more about it. The documentation for each destination explains how the Segment Tracking API methods are implemented for that destination.
Segment hasSourcesandDestinations. Sources send dataintoSegment, while Destinations receive datafromSegment.
Segment has three destination connection types:
Event streams destinations are all destinations that aren’t storage or Reverse ETL destinations. Adding these destinations allow you to act on your data and learn more about your customers in real time. These includeDestination Actions.
Storage destinations enable you to store your raw Segment data. This enables data analysts and data scientists to work with the raw data to derive deeper and more customized insights to support your organization. Learn more from thestorage overview page.
Reverse ETLdestinations are the business tools or apps you use that Segment syncs the data from your warehouse to.
If your destination is not listed inthe Reverse ETL catalog, use theSegment Connections destinationto send data from your Reverse ETL warehouse to other destinations listed in thecatalog. The Segment Connections destination enables you to mold data extracted from your warehouse inSegment SpecAPI calls that are then processed bySegment’s HTTP Tracking API. The Segment HTTP Tracking API lets you record analytics data. The requests hit Segment’s servers, and then Segment routes your data to any destination you want. Get started with theSegment Connections destination.
Not all destinations can accept data from specific method types. To know if a destination can accept data from specific method types, look for theQuick Infobox at the top of the destination’s documentation page, or check out theDestinations Methods comparison chart.
Many destinations can accept data from all types of sources, but some are only compatible with specific source types (for example, web only, or server only). To find out which source types a specific destination can accept data from, check the documentation for that destination in theQuick infobox, or in theSupported Sources and Connection Modessection.
Wondering which destinations take which data? Check out the Destination connection modes list by category.
In June 2021, Segment released a new form of destinations calledDestinations Actions. These destinations allow users to createsubscriptions: sets of conditions in which data is sent to the destinations and data mappings, to format that data for the destination tool. Segment watches for data that matches the conditions you create (triggers) for the subscription, and when the conditions are met, uses an explicit mapping to transform the incoming data to an output format that your destination can use.
Segment’s web source (Analytics.js), and native client-side libraries (iOS, Android, React-native) allow you to choose how you send data to Segment from your website or app. There are two ways to send data:
Cloud-mode: The sources send data directly to the Segment servers, which then translate it for each connected downstream destination, and send it on. Translation is done on the Segment servers, keeping your page size, method count, and load time small.
Healthcare and Life Sciences (HLS) customers can encrypt data flowing into their destinations
HLS customers with a HIPAA eligible workspace can encrypt data in fields marked as Yellow in the Privacy Portal before they flow into an event stream, cloud-mode destination.To learn more about data encryption, see theHIPAA Eligible Segment documentation
Device-mode: You include additional code on your website or mobile app which allows Segment to use the data you collect on the device to make calls directly to the destination tool’s API, without sending it to the Segment serversfirst. (You still send your data to the Segment servers, but this occurs asynchronously.) This is also calledwrappingorbundling, and it might be required when the source has to be loaded on the page to work, or loaded directly on the device to function correctly. When you use Analytics.js, you can change the device-mode destinations that a specific source sends from within the Segment web app, without touching any code.

If you use Server source libraries, they only send data directly to Segment in Cloud-mode. Server library implementations operate in the server backend, and can't load additional destination SDKs.
Cloud-mode destinations send data through Segment. Device-mode destinations send data in parallel to Segment. There are tradeoffs between using cloud-mode and device-mode destinations. In general, Cloud-mode is preferred because you then benefit from Segment’s system features, like retries, Replay, Warehouses, Privacy blocking, filtering, and more.
You should consider using device-mode if you use destinations which record information directly on the user’s device. These types of tools might lose functionality if they aren’t loaded directly on the device.
Take a look at the pros and cons chart of device-mode and cloud-mode destinations to determine which connection mode is best for you:
Segment’s website sources use device-mode by default, because so many website-based destinations require that they be loaded on the page, and because size and page performance are less of a concern than on mobile. If your website source only collects information that you can instrument yourself, then you can use cloud-mode.
For example, a web-chat destination must be loaded to connect to the service and collect metrics efficiently - you don’t expect it to route chat messages through Segment! Thisdoesmean that Segment might not receive a small amount of the destination-specific information from your users. In the chat example, if the destination is calculating idle time between messages, that data would appear in the destination’s tooling, but not necessarily in the Segment data.
By default, destinations configured on a mobile source send their data directly to the Segment servers, then translate it and use Cloud-mode to forward it to destinations.Cloud-modemeans that Segment sends the data directly from the Segment servers, to their servers. This means you don’t need to package third-party SDKs for destinations that can accept cloud-mode data. Some primarily web-based destinations also allow cloud-mode, which can help reduce app size, and improve load time and performance. You can read more about theeffects of mobile app size on downloads in Segment’s blog.
Before you turn on or opt-in for cloud-mode for a mobile source, consider if your destinations have features that require interactions on the device or require device-specific data (see the examples above). For example, if you use cloud-mode for Mixpanel, you’ll get your data on reporting and people, but won’t be able to use their features for in-app surveys or auto-tracking. These can be really valuable, but might not be a priority for your team.
There are two main things Segment considers when deciding to use Device-mode or Cloud-mode, or both, for a destination partner:
The anonymous identifiers used on mobile devices are usually static, which means Segment doesn’t need to do additional resolution, and can build Cloud-mode destinations by default. Because Segment uses native advertising identifiers on mobile devices, you don’t need a full SDK on the device to reconcile or identify a user. For example, you might track users who viewed an advertisement in one app and installed another app as a result.
However, some mobile attribution tools do more advanced reconciliation based on more than the native identifier, which requires the SDK on the device to work properly. For those destinations, Segment offers device-mode, which packages the tool’s SDK with the client-side library so that you can get the entire range of tool functionality.
Cross-domain identity resolution for websites requires that the attribution tool use a third-party cookie so it can track a user anonymously across domains. This is a critical component of attribution modeling. As a matter of principle, Segment only uses first-party cookies and doesn’t share cookies with partners, so Analytics.js and the data it collects aren’t enough to generate view-through attribution in ad networks.
Customers can load their libraries and pixels in the context of the browser and trigger requests to attribution providers from their device in response to Segment API calls to take advantage of advertising and attribution tools.
Many of Segment’s destinations offer client-side features beyond data collection in their SDKs and libraries, for both mobile and web. In these cases, Segment offers Device-mode SDKs so that you can collect information on the device using Segment, but still get the destination’s complete native functionality.
Some features that usually require Device-mode include: automatic A/B testing, displaying user surveys, live chat or in-app notifications, touch and hover heatmapping, and accessing rich device data such as CPU usage, network data, or raised exceptions.
The first place to look is the individual destination documentation. Each one includes a matrix of supported Sources and Connection Modes. Segment provides a list ofall destinations and their connection modes.
In order to override the default, check the destination settings pane in the Segment web App either for aConnection Modetoggle or instructions on bundling any additional mobile components required.
Sync modes allow users to define how changes in the source should send downstream to your destination. Depending on which destinations you set up in Segment, you may need to choose a sync mode for your data. This configuration determines how Segment updates your destination based on the source data.
The available sync modes can vary based on the destination, integration type, and actions within the destination. For example, if you sync customer data, you might have the option to Insert, Update, or Upsert records.
Available sync modes include:
To add a Destination:
Learn moreabout what adding a destination entails.
Disabled destinations do not receive data
If you haven’t enabled your destination for the first time after you created it or if you actively disable a destination, Segment prevents any data from reaching the destination. Business Tier customers can requesta Replay, which resends data from the time the destination was disabled to the time it was re-enabled. Replays can also send data to currently disabled destinations.
Some destinations are not compatible with Replays after a certain period of time, for example, 14 days. Check with Segment’s support teamfriends@segment.comto confirm that your intended destination allows historical timestamps.
Segment increases deliverability to destinations usingretriesandreplays. Retries happen automatically for all customers, while replays are available on request forBusiness Tiercustomers.
Segment’s data flow is primarily unidirectional, from Segment to integrated destinations. Segment does not inherently support a bidirectional flow where events, once delivered and processed by a destination, are sent back to Segment.
Segment also usesbatchingto increase deliverability to your destinations. Some destinations have batching enabled by default, and some, like Segment’sWebhook (Actions) Destination, let you opt in to batching.
Some cases of event batching might lead to observability loss
While batching does increase event deliverability, you might experience error amplification, as if the entire batch fails, all events will be marked with the same status. For example, if a batch fails due to one429(Rate Limit) error, it might appear in the UI that there was one 429s request failure for each item in the batch.
Segment’s client libraries ensure delivery of your data to the API reliably in the face of spotty connections, device failure, or network partitions in your data centers.
When you use Segment’s mobile SDK, Segment dispatches each event to a background thread where the event is then written to a queue. Later, Segment’s SDK batches together many requests in to one compressed request and sends it to Segment’s servers. Segment’s SDKs minimize battery use and bandwidth use by powering up the radio less frequently and for shorter time periods.
If the delivery of the payload is not successfully sent due to connection issues, all of your SDKs will automatically retry the request until successful receipt of the payload according to the following policies. Note that retry policies are subject to change / tuning in the future.
All mobile libraries handle retries by periodically attempting to flush their internal queue of events to Segment. If the flush is unsuccessful, the library waits until the next regularly-scheduled flush time to try again. The background queue of requests to Segment is bounded in size so if events are being queued faster than we can successfully flush them to Segment, some events may be dropped.
The destination endpoint APIs have fluctuations in availability due to a number of issues ranging from network failures to bugs to overload. Segment’s internal systems retry failed destination API calls for four hours with a randomized exponential backoff after each attempt. This substantially improves delivery rates.
Here’s an example destination that was only successfully accepting 93.36% of all API requests but was achieving a 99.28% final deliverability rate due to Segment’s retry functionality.

You can see the current destination endpoint API success rates and final delivery rates for Segment’s server-side destinations on Segment’sstatus page.
Replay is available toBusiness tiercustomers.Contact Segmentto learn more.
Replaysallow customers to load historical data from Segment’s S3 logs into downstream destinations which accept cloud-mode data. So, for example, if you wanted to try out a new email or analytics tool, Segment can replay your historical data into that tool. This gives you a great testing environment and prevents data lock-in when vendors try to hold data hostage.
If you submittedsuppress_onlyrequests, Segment still retains historical events for those users, which can be replayed. If you do not want historical events replayed for suppressed users, submitsuppress_and_deleterequests instead.
Segment usesstream batchingfor all destinations that require near-realtime data andbulk batchingfor some data flows in our pipeline.
For all destinations, except for non-realtime Engage syncs and Reverse ETL syncs, Segment processes events from your source as they arrive and then flows the data downstream to your destinations in small batches, in a process calledstream batching. These batches might contain different events between retry attempts, as events in previous batches may have succeeded, failed with a permanent error, or expired. This variability reduces the workload the system processes during partial successes, allows for better per-event handling, and reduces the chance of load-related failures by using variable batch formations.
Some data flows may be able to use a process calledbulk batching, which supports batching for destinations that produce between several thousand and a million events at a time. Real-time workloads or using a Destination Insert Function may prevent bulk batches from being formed. Batches contain the same events between retries.
The following destinations support bulk batching:
You must manually configure bulk batches for Actions destinations
To support bulk batching for the Actions Webhook destination, you must setenable-batching: trueandbatch_size: >= 1000.
IP Allowlisting uses a NAT gateway to route traffic from Segment’s servers to your destination through a limited range of IP addresses, which can prevent malicious actors from establishing TCP and UDP connections with your integrations.
IP Allowlisting is available for customers on Business Tier plans.
Segment supports IP Allowlisting inall destinationsexcept for the following:
Destinations that are not supported receive traffic from randomly assigned IP addresses.
To enable IP Allowlisting for your workspace:
IP restriction might not be supported in all destinations.

Headings:
Destinations Overview
Sources vs Destinations
Destination connection types
Event streams destinations
Storage destinations
Reverse ETL destinations
Method compatibility
Source compatibility
Destinations Compatibility Matrix
Destination Actions
Connection modes
Choosing a connection mode
Website source connection modes
Mobile source connection modes
How Segment determines Device-mode and Cloud-mode destinations
Anonymous attribution methodology
Mobile attribution
Web Attribution
Client-native destination features
How can I tell which connection modes and platforms are supported for a destination?
Sync modes
Add a destination
Data deliverability
Retries
Retries in Segment’s client libraries
Mobile library retries
Retries between Segment and destinations
Replays
Batching
Stream batching
Bulk batching
IP Allowlisting
Supported destinations
Configure IP Allowlisting
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/destinations/actions/
Paragraphs:
Destination Actions are available for all Segment plans. Self-service plans are limited to two conditions per Trigger.See theavailable plans, orcontact Support.
On this page
The Destination Actions framework improves on classic destinations by enabling you to see and control how Segment sends the event data it receives from your sources, to actions-based destinations. Each Action in a destination lists the event data it requires, and the event data that is optional.
You can also choose which event types, event names, or event property values trigger an Action. These Triggers and mappings make it possible to send different versions of the Action, depending on the context from which it is triggered.
Each Actions-framework Destination you see in the Segment catalog represents a feature or capability of the destination which can consume data from your Segment source. The Action clearly lists which data from the events it requires, and which data is optional. For example, Amplitude requires that you always send aLogEvent, or Slack always requires aPostMessage.  Each Action also includes a default mapping which you can modify.
The following Actions-based Destinations are available:
A Destination Action contains a hierarchy of components, that work together to ensure the right data is sent to the destination.
For example, in the Amplitude (Actions) destination, you define your API and Secret keys in the destination’s global settings. Then, the provided Page Calls mapping:
To set up a new Actions-framework destination for the first time:
You must configure and enable at least one mapping to handle a connected source’s event(s) in an Actions-framework destination in order for data to send downstream. 
Events send downstream in the order in which they appear in the mappings UI. There is no mechanism through which you can control the order of events that send to the downstream destinations outside of that.
Moving from a classic destination to an actions-based destination is a manual process. Segment recommends that you follow the procedure below:
You can only migrate your destination filters using the Public API if you’re on the business tier plan. This functionality isn’t available in the Segment app.
To migrate your destination filters to your actions destination from the classic destination:
For a more comprehensive migration from a classic destination to an actions-based destination, follow the steps outlined below. This implementation strategy is only available for customers on a Segment Business Tier plan with access toDestination Filters. By adding additional line of defense with Destination Filters, you remove the possibility of duplicate events or dropped events and ensure that events sent before/after a specifiedreceived_attimestamp are sent to each destination.
This migration strategy involves configuring a destination filter on both the Classic destination and the Actions destination. Configure the classic destination filter to block events by thereceived_atfield with a certain value, and the Actions destination to drop events until thereceived_attimestamp field reaches that same value. Destination Filters within the UI have a limitation where they cannot access any top-level fields, but this is not a limitation forDestination Filterscreated by thePublic APIusingFQL. Because thereceived_atis a top-level field in the payload, you’ll need to create a destination filter with the Public API and submit the request with that FQL information described below.
By combining these Filters, Segment sends events through the Classic integration up until a specified time and then blocks events after that time. Then the Actions integration blocks events until that specified time, and only allows events beginning at that specified time.
The following code samples show you how you can create filters for your destinations using theCreate Filter for DestinationPublic API operation.
Endpoint:POSThttps://api.segmentapis.com/destination/classic_destination_id_from_url/filters
Endpoint:POSThttps://api.segmentapis.com/destination/actions_destination_id_from_url/filters
After configuring the Destination Filter on both the Classic and Actions destination, see each destination’s Filters tab and enable the filters. After completing the migration, you can disable the Classic destination on the Settings page, and remove each of the filters from both destinations.
You can add or remove, disable and re-enable, and rename individual actions from the Actions tab on the destination’s information page in the Segment app. Click an individual action to edit it.
From the edit screen you can change the action’s name and mapping, and toggle it on or off. SeeCustomizing mappingsfor more information.

When an Action is created, it’s disabled by default, to ensure that it’s only used after being fully configured. To begin sending data through an Action, enable it on the Actions page by selecting the toggle so that it appears blue.
If you find that you need to stop an action from running, but don’t want to delete it completely, you can click the action to select it, then click the toggle next to the action’s name to disable it. This takes effect within minutes, and disables the action until you reenable it.
To delete a destination action: click the action to select it, and clickDelete(the trash can icon).
This takes effect within minutes, and removes the action completely. Any data that would have gone to the destination is not delivered. Once deleted, the saved action cannot be restored.
To test a destination action, follow the instructions inTesting Connections. You must enable a mapping in order to test the destination. Otherwise, this error occurs:You may not have any subscriptions that match this event.
You can also test within the mapping itself. To test the mapping:
Test Mapping might not return the events you're looking for
Segment only surfaces a small subset of events for the Test Mapping feature and might not always return the event you’re looking for. If you’d like to test with a specific event, copy a specific event from yourSource Debuggerand paste it into theAdd test eventinterface.
If you use the default mappings for a destination action, you don’tneedto customize the mapping template for the action. You can edit the fields later if you find that the defaults no longer meet your needs.
Actions-based destinations have a limit of 50 individual mappings.
To create a custom destination action, start from the Actions tab.
If necessary, clickNew Mappingto create a new, blank action.
The required fields for a destination mapping appear automatically. Click the + sign to see optional fields.
Suggested mappings is fully available for RETL mappings, and is in public beta for event streams and connections.
Segment offers suggested mappings that automatically propose relevant destination fields for both model columns and payload elements. For example, if your model includes a column or payload field namedtransaction_amount, the feature might suggest mapping it to a destination field likeAmountorTransactionValue. This automation, powered by intelligent autocompletion, matches and identifies near-matching field names to streamline the setup. For more information, seeSegment’s suggested mappings blogpostand theSuggested Mappings Nutrition Label.
Review the suggested mappings for accuracy before finalizing them as the suggestions aren’t guaranteed to be 100% accurate.
The coalesce function takes a primary value and uses it if it is available. If the value isn’t available, the function uses the fallback value instead.
The replace function allows you to replace a string, integer, or boolean with a new value. You have the option to replace up to two values within a single field.
The flatten function allows you to flatten a nested object to an object with a depth of 1. Keys are delimited by the configured separator. For example, an object like {a: { b: { c: 1 }, d: 2 } } will be converted to { ‘a.b.c’: 1, ‘a.d’: 2 }.
Self-service users can add a maximum of two conditions per Trigger.
Mapping fields are case-sensitive. The following type filters and operators are available to help you build conditions:
Event property(is,is not,less than,less than or equal to,greater than,greater than or equal to,contains,does not contain,starts with,ends with,exists,does not exist).  Use these filters to trigger the action only when an event with a specific property occurs.
You can specify nested properties using dot notation, for examplecontext.app.name. If the property might appear in more than one format or location, you can use an ANY statement and add conditions for each of those formats. For example, you might filter for bothcontext.device.type = iosas well ascontext.os.name = "iPhone OS"Thedoesnot existoperator matches both anullvalue or a missing property.
The available operators depend on the property’s data type:
You can combine criteria in a single group usingALLorANY.  Use an ANY to “subscribe” to multiple conditions. Use ALL when you need to filter for very specific conditions. You can only create one group condition per destination action. You cannot created nested conditions.
Unsupported Special Characters
Mappings do not support the use of double quotes “ or a tilde ~ in the trigger fields. In mapping fields, the . character is not supported unless it’s being used to access an object key. If a string has a . in it, that is not supported.
Limitations
Mapping fields don’t support dot notation. For example, properties.amount.cost or properties_amount.cost aren’t supported.
Destination Filters
Destination filters are compatible with Destination Actions. Consider a Destination Filter when:
If your use case does not match these criteria, you might benefit from using Mapping-level Triggers to match only certain events.
You can use the Duplicate Mappings feature to create an exact copy of a mapping. The duplicated mapping has the same configurations and enrichments as your original mapping.
Duplicate Mappings supportsActions destinations,Reverse ETL destinations, and destinations connected to EngageAudiencesandJourneys.
To duplicate your mappings:
Segment creates a disabled mapping with the name “Original Mapping Name (Copy)”. You must enable the mapping for data to flow.
When you send an event with an actions destination Event Tester that doesn’t match the trigger of any configured and enabled mappings, you’ll see an error message that states,You may not have any subscriptions that match this event.To resolve the error, create a mapping with a trigger to handle the event being tested, or update the test event’s payload to match the trigger of any existing mappings.
If no mappings are enabled to trigger on an event that has been received from the connected source, the destination will not send any events. Ensure that at least one mapping has been configured and enabled in the destination mappings for an event that you would like to reach downstream.
Events without mappings enabled to handle them display as being discarded due to “No matching mapping” in a destination’s Delivery Overview.
When the same event triggers multiple mappings, a request will be generated for each mapping that’s configured to trigger on an event. For example, for theSubscription Updatedevent, if two mappings are enabled and both have conditions defined to trigger on theSubscription Updatedevent, the two requests will be generated and sent to the destination for eachSubscription Updatedevent.
Access Tokens that were generated from initial authorization, for example, when you connect a destination via Oauth, are always short-lived. Commonly, the token remains valid for 30 minutes to 1 hour. When Segment receives 401 error responses from the destination after a token has expired, it will automatically make another request to the destination for a new token and will then retry the event. Therefore, 401 responses are sometimes expected and do not indicate an event failure. There are three event flows when events are received and sent to a destination:
The underlying systems for these flows have their own copy of the token, which can expire at different points in time.
Threfore, if you see a 401 error in a sample response, it is likely that you’ll also see another request was made after it, to ask the downstream destination for a new token. Then one more request was made to actually send the data in your payload to the downstream destination.
Segment integrations process events through mappings individially. This means that no context is held that would allow you to map a value from one event to the field of a subsequent event. Each event itself must contain all of the data you’d like to send downstream in regards to it. For example, you cannot sendemailin on an Identify call and then access that sameemailfield on a Track call that comes in later if that Track call doesn’t also haveemailset on it.
This issue can occur due to a browser cache conflict or if an event property name includes a/. To resolve it, try clearing your browser cache or accessing the mapping page in an incognito window. Additionally, check if the mapped property name contains a/. If it does, rename the property to remove the/and update the mapping.

Headings:
Destination Actions
Benefits of Destination Actions
Available Actions-based Destinations
Destination Actions compatibility
Components of a Destination Action
Set up a destination action
Migrate a classic destination to an actions-based destination
Migrate your destination filters from the classic destination to the actions destination
Migrate to an actions-based destination using Destination Filters
Classic destination
Actions destination
Edit a destination action
Disable a destination action
Delete a destination action
Test a destination action
Customize mappings
Suggested mappings
Coalesce function
Replace function
Flatten function
Conditions
Duplicate Mappings
FAQ and troubleshooting
Validation error when using the Event Tester
Data not sending downstream
Multiple mappings triggered by the same event
Oauth “access token expired” message shown in Segment UI
Is it possible to map a field from one event to another?
I’m getting a ‘Couldn’t load page’ error when viewing or editing a mapping
Need support?
Help improve these docs!
Was this page helpful?
Get started with Segment
Crawling: https://segment.com/docs/connections/destinations/add-destination/
